/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.07 from the
 * contents of Magick.xs. Do not edit this file, edit Magick.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Magick.xs"
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                         PPPP   EEEEE  RRRR   L                              %
%                         P   P  E      R   R  L                              %
%                         PPPP   EEE    RRRR   L                              %
%                         P      E      R  R   L                              %
%                         P      EEEEE  R   R  LLLLL                          %
%                                                                             %
%                  M   M   AAA    GGGG  IIIII   CCCC  K   K                   %
%                  MM MM  A   A  G        I    C      K  K                    %
%                  M M M  AAAAA  G GGG    I    C      KKK                     %
%                  M   M  A   A  G   G    I    C      K  K                    %
%                  M   M  A   A   GGGG  IIIII   CCCC  K   K                   %
%                                                                             %
%                                                                             %
%                Object-oriented Perl interface to ImageMagick                %
%                                                                             %
%                                                                             %
%                            Software Design                                  %
%                              Kyle Shorter                                   %
%                              John Cristy                                    %
%                             February 1997                                   %
%                                                                             %
%                                                                             %
%  Copyright 1999 E. I. du Pont de Nemours and Company                        %
%                                                                             %
%  Permission is hereby granted, free of charge, to any person obtaining a    %
%  copy of this software and associated documentation files ("ImageMagick"),  %
%  to deal in ImageMagick without restriction, including without limitation   %
%  the rights to use, copy, modify, merge, publish, distribute, sublicense,   %
%  and/or sell copies of ImageMagick, and to permit persons to whom the       %
%  ImageMagick is furnished to do so, subject to the following conditions:    %
%                                                                             %
%  The above copyright notice and this permission notice shall be included in %
%  all copies or substantial portions of ImageMagick.                         %
%                                                                             %
%  The software is provided "as is", without warranty of any kind, express or %
%  implied, including but not limited to the warranties of merchantability,   %
%  fitness for a particular purpose and noninfringement.  In no event shall   %
%  E. I. du Pont de Nemours and Company be liable for any claim, damages or   %
%  other liability, whether in an action of contract, tort or otherwise,      %
%  arising from, out of or in connection with ImageMagick or the use or other %
%  dealings in ImageMagick.                                                   %
%                                                                             %
%  Except as contained in this notice, the name of the E. I. du Pont de       %
%  Nemours and Company shall not be used in advertising or otherwise to       %
%  promote the sale, use or other dealings in ImageMagick without prior       %
%  written authorization from the E. I. du Pont de Nemours and Company.       %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% PerlMagick, version 4.28, is an objected-oriented Perl interface to
% ImageMagick.  Use the module to read,manipulate,or write an image or
% image sequence from within a Perl script.  This makes it very suitable
% for Web CGI scripts.  You must have ImageMagick 4.1.5 or above and Perl
% version 5.002 or greater installed on your system for either of these
% utilities to work.
%
*/

/*
  Include declarations.
*/
#if !defined(WIN32)
#define Export
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#undef tainted
#include <magick/magick.h>
#include <magick/defines.h>
#include <setjmp.h>

#ifdef __cplusplus
}
#endif

/*
  Define declarations.
*/
#define DoubleReference  (char **) 2
#define EndOf(array)  (&array[NumberOf(array)])
#define ImageReference  (char **) 3
#define IntegerReference  (char **) 1
#define MaxArguments  12
#define NumberOf(array)  (sizeof(array)/sizeof(*array))
#define PackageName   "Image::Magick"
#define StringReference  (char **) 0

/*
  Perl 5.006 no longer defines na and sv_undef.
*/
#ifndef na
#define na  PL_na
#endif
#ifndef sv_undef
#define sv_undef  PL_sv_undef
#endif

/*
  Typedef and structure declarations.
*/
typedef void
  *Image__Magick;  /* data type for the Image::Magick package */

/*
  The data type for remembering options set by the user, which basically
  correspond to ImageMagick's command line options.  Each AV* type of
  Image__Magick has a special variable created for it (see GetPackageInfo) that
  holds one.
*/
struct PackageInfo
{
  ImageInfo
    *image_info;

  QuantizeInfo
    *quantize_info;
};

/*
  The different types of arguments that can be passed as arguments from Perl.
*/
union ArgumentList
{
  int
    int_reference;

  double
    double_reference;

  char
    *string_reference;

  Image
    *image_reference;
};

/*
  Static declarations.
*/
/*
  These arrays match the ImageMagick enums.  The positions must match between
  both.  The names are the minimum length to match, e.g., in NoiseTypes
  AddNoise("laplacian") and AddNoise("LaplacianNoise") both work.
*/
static char
  *BooleanTypes[] =
  {
    "False", "True", (char *) NULL
  },
  *ClassTypes[] =
  {
    "Undefined", "DirectClass", "PseudoClass", (char *) NULL
  },
  *ColorspaceTypes[] =
  {
    "Undefined", "RGB", "Gray", "Transparent", "OHTA", "XYZ", "YCbCr",
    "YCC", "YIQ", "YPbPr", "YUV", "CMYK", "sRGB", (char *) NULL
  },
  *CompositeTypes[] =
  {
    "Undefined", "Over", "In", "Out", "Atop", "Xor", "Plus", "Minus",
    "Add", "Subtract", "Difference", "Bumpmap", "Replace",
    "ReplaceRed", "ReplaceGreen", "ReplaceBlue", "ReplaceMatte",
    "Blend", "Displace", (char *) NULL
  },
  *CompressionTypes[] =
  {
    "Undefined", "None", "BZip", "Fax", "Group4", "JPEG", "LZW", "Runlength",
    "Zip", (char *) NULL
  },
  *FilterTypes[] =
  {
    "Undefined", "Point", "Box", "Triangle", "Hermite", "Hanning",
    "Hamming", "Blackman", "Gaussian", "Quadratic", "Cubic", "Catrom",
    "Mitchell", "Lanczos", "Bessel", "Sinc", (char *) NULL
  },
  *GravityTypes[] =
  {
    "Forget", "NorthWest", "North", "NorthEast", "West", "Center",
    "East", "SouthWest", "South", "SouthEast", "Static", (char *) NULL
  },
  *ImageTypes[] =
  {
    "Undefined", "Bilevel", "Grayscale", "Palette", "TrueColor", "Matte",
    "ColorSeparation", (char *) NULL
  },
  *IntentTypes[] =
  {
    "Undefined", "Saturation", "Perceptual", "Absolute", "Relative",
    (char *) NULL
  },
  *InterlaceTypes[] =
  {
    "Undefined", "None", "Line", "Plane", "Partition", (char *) NULL
  },
  *LayerTypes[] =
  {
    "Undefined", "Red", "Green", "Blue", "Matte", (char *) NULL
  },
  *MethodTypes[] =
  {
    "Point", "Replace", "Floodfill", "FillToBorder", "Reset", (char *) NULL
  },
  *ModeTypes[] =
  {
    "Undefined", "Frame", "Unframe", "Concatenate", (char *) NULL
  },
  *NoiseTypes[] =
  {
    "Uniform", "Gaussian", "Multiplicative", "Impulse", "Laplacian",
    "Poisson", (char *) NULL
  },
  *PreviewTypes[] =
  {
    "Undefined", "Rotate", "Shear", "Roll", "Hue", "Saturation",
    "Brightness", "Gamma", "Spiff", "Dull", "Grayscale", "Quantize",
    "Despeckle", "ReduceNoise", "AddNoise", "Sharpen", "Blur",
    "Threshold", "EdgeDetect", "Spread", "Solarize", "Shade", "Raise",
    "Segment", "Swirl", "Implode", "Wave", "OilPaint", "Charcoal",
    "JPEG", (char *) NULL
  },
  *PrimitiveTypes[] =
  {
    "Undefined", "Point", "Line", "Rectangle", "FillRectangle",
    "Circle", "FillCircle", "Ellipse", "FillEllipse", "Polygon",
    "FillPolygon", "Color", "Matte", "Text", "Image", (char *) NULL
  },
  *ResolutionTypes[] =
  {
    "Undefined", "PixelsPerInch", "PixelsPerCentimeter", (char *) NULL
  };

/*
  The list of ImageMagick methods and their parameters currently
  supported by this interface (except for Read, Write, and new).  I did
  it this way to avoid a lot of duplicated code, and to use the neato
  ALIASes that XS provides.  Parameter names are matched up to the
  name's length so that e.g. the parameter name "comment" matches
  "commentstuff".
*/
static struct
  Methods
  {
    char
      *name;

    struct arguments
    {
      char
        *method,
        **type;
    } arguments[MaxArguments];
  } Methods[] =
  {
    { "Comment", { {"comment", StringReference} } },
    { "Label", { {"label", StringReference} } },
    { "AddNoise", { {"noise", NoiseTypes} } },
    { "Colorize", { {"color", StringReference}, {"pen", StringReference} } },
    { "Border", { {"geom", StringReference}, {"width", IntegerReference},
      {"height", IntegerReference}, {"color", StringReference} } },
    { "Blur", { {"factor", DoubleReference} } },
    { "Chop", { {"geom", StringReference}, {"width", IntegerReference},
      {"height", IntegerReference}, {"x", IntegerReference},
      {"y", IntegerReference} } },
    { "Crop", { {"geom", StringReference}, {"width", IntegerReference},
      {"height", IntegerReference}, {"x", IntegerReference},
      {"y", IntegerReference} } },
    { "Despeckle", },
    { "Edge", { {"factor", DoubleReference} } },
    { "Emboss", },
    { "Enhance", },
    { "Flip", },
    { "Flop", },
    { "Frame", { {"geom", StringReference}, {"width", IntegerReference},
      {"height", IntegerReference}, {"inner", IntegerReference},
      {"outer", IntegerReference}, {"color", StringReference} } },
    { "Implode", { {"factor", DoubleReference} } },
    { "Magnify", },
    { "MedianFilter", },
    { "Minify", },
    { "OilPaint", { {"radius", IntegerReference} } },
    { "ReduceNoise", },
    { "Roll", { {"geom", StringReference}, {"x", IntegerReference},
      {"y", IntegerReference} } },
    { "Rotate", { {"degree", DoubleReference}, {"crop", BooleanTypes},
      {"sharpen", BooleanTypes} } },
    { "Sample", { {"geom", StringReference}, {"width", IntegerReference},
      {"height", IntegerReference} } },
    { "Scale", { {"geom", StringReference}, {"width", IntegerReference},
      {"height", IntegerReference} } },
    { "Shade", { {"geom", StringReference}, {"azimuth", DoubleReference},
      {"elevat", DoubleReference}, {"color", BooleanTypes} } },
    { "Sharpen", { {"factor", DoubleReference} } },
    { "Shear", { {"geom", StringReference}, {"x", DoubleReference},
      {"y", DoubleReference}, {"crop", BooleanTypes} } },
    { "Spread", { {"amount", IntegerReference} } },
    { "Swirl", { {"degree", DoubleReference} } },
    { "Zoom", { {"geom", StringReference}, {"width", IntegerReference},
      {"height", IntegerReference}, {"filter", FilterTypes},
      {"blur", DoubleReference } } },
    { "IsGrayImage", },
    { "Annotate", { {"text", StringReference}, {"font", StringReference},
      {"point", IntegerReference}, {"density", StringReference},
      {"box", StringReference}, {"pen", StringReference},
      {"geom", StringReference}, {"server", StringReference},
      {"x", IntegerReference}, {"y", IntegerReference},
      {"grav", GravityTypes}, {"degree", DoubleReference} } },
    { "ColorFloodfill", { {"geom", StringReference}, {"x", IntegerReference},
      {"y", IntegerReference}, {"pen", StringReference},
      {"bordercolor", StringReference} } },
    { "Composite", { {"compos", CompositeTypes}, {"image", ImageReference},
      {"geom", StringReference}, {"x", IntegerReference},
      {"y", IntegerReference}, {"grav", GravityTypes} } },
    { "Contrast", { {"sharp", BooleanTypes} } },
    { "CycleColormap", { {"amount", IntegerReference} } },
    { "Draw", { {"prim", PrimitiveTypes}, {"points", StringReference},
      {"meth", MethodTypes}, {"pen", StringReference},
      {"linew", IntegerReference}, {"server", StringReference},
      {"borderc", StringReference} } },
    { "Equalize", },
    { "Gamma", { {"gamma", StringReference}, {"red", DoubleReference},
      {"green", DoubleReference}, {"blue", DoubleReference} } },
    { "Map", { {"image", ImageReference}, {"dither", BooleanTypes} } },
    { "MatteFloodfill", { {"geom", StringReference}, {"x", IntegerReference},
      {"y", IntegerReference}, {"matte", IntegerReference},
      {"bordercolor", StringReference} } },
    { "Modulate", { {"factor", StringReference}, {"bright", DoubleReference},
      {"satur", DoubleReference}, {"hue", DoubleReference} } },
    { "Negate", { {"gray", BooleanTypes} } },
    { "Normalize", },
    { "NumberColors", },
    { "Opaque", { {"color", StringReference}, {"pen", StringReference} } },
    { "Quantize", { {"colors", IntegerReference}, {"tree", IntegerReference},
      {"colorsp", ColorspaceTypes}, {"dither", BooleanTypes},
      {"measure", BooleanTypes}, {"global", BooleanTypes} } },
    { "Raise", { {"geom", StringReference}, {"width", IntegerReference},
      {"height", IntegerReference}, {"x", IntegerReference},
      {"y", IntegerReference}, {"raise", BooleanTypes} } },
    { "Segment", { {"colorsp", ColorspaceTypes}, {"verbose", BooleanTypes},
      {"clust", DoubleReference}, {"smooth", DoubleReference} } },
    { "Signature", },
    { "Solarize", { {"factor", DoubleReference} } },
    { "Sync", },
    { "Texture", { {"texture", ImageReference} } },
    { "Transform", { {"crop", StringReference}, {"geom", StringReference},
      {"filter", FilterTypes} } },
    { "Transparent", { {"color", StringReference} } },
    { "Threshold", { {"threshold", DoubleReference} } },
    { "Charcoal", { {"factor", StringReference} } },
    { "Trim", },
    { "Wave", { {"geom", StringReference}, {"ampli", DoubleReference},
      {"wave", DoubleReference} } },
    { "Layer", { {"layer", LayerTypes} } },
    { "Condense", },
    { "Stereo", { {"image", ImageReference} } },
    { "Stegano", { {"image", ImageReference}, {"offset", IntegerReference} } },
    { "Coalesce", },
    { "Deconstruct", },
  };

/*
  Variable declarations.
*/
char
  *client_name = "PerlMagick";

int
  warning_flag = False;  /* if != 0: error messages call Perl warn */

SV
  *error_list;  /* Perl variable for storing messages */

static jmp_buf
  *error_jump;  /* long jump return for FATAL errors */

/*
  Forward declarations.
*/
static int
  strEQcase(const char *,const char *);

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   C l o n e P a c k a g e I n f o                                           %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Method ClonePackageInfo makes a duplicate of the given info, or if info is
%  NULL, a new one.
%
%  The format of the ClonePackageInfo routine is:
%
%      cloned_info=ClonePackageInfo(info)
%
%  A description of each parameter follows:
%
%    o cloned_info: Method ClonePackageInfo returns a duplicate of the given
%      info, or if info is NULL, a new one.
%
%    o info: a structure of type info.
%
%
*/
static struct PackageInfo *ClonePackageInfo(struct PackageInfo *info)
{
  struct PackageInfo
    *cloned_info;

  cloned_info=(struct PackageInfo *) safemalloc(sizeof(struct PackageInfo));
  if (!info)
    {
      (void) SetClientName(client_name);
      cloned_info->image_info=CloneImageInfo((ImageInfo *) NULL);
      cloned_info->quantize_info=CloneQuantizeInfo((QuantizeInfo *) NULL);
      return(cloned_info);
    }
  *cloned_info=(*info);
  cloned_info->image_info=CloneImageInfo(info->image_info);
  cloned_info->quantize_info=CloneQuantizeInfo(info->quantize_info);
  return(cloned_info);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   c o n s t a n t                                                           %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Method constant returns a double value for the specified name.
%
%  The format of the constant routine is:
%
%      value=constant(name,sans)
%
%  A description of each parameter follows:
%
%    o value: Method constant returns a double value for the specified name.
%
%    o name: The name of the constant.
%
%    o sans: This integer value is not used.
%
%
*/
static double constant(char *name,int sans)
{
  errno=0;
  switch (*name)
  {
    case 'C':
    {
      if (strEQ(name,"CorruptImageWarning"))
        return(CorruptImageWarning);
      break;
    }
    case 'D':
    {
      if (strEQ(name,"DelegateWarning"))
        return(DelegateWarning);
      break;
    }
    case 'F':
    {
      if (strEQ(name,"FileOpenWarning"))
        return(FileOpenWarning);
      break;
    }
    case 'M':
    {
      if (strEQ(name,"MissingDelegateWarning"))
        return(MissingDelegateWarning);
      if (strEQ(name,"MissingPluginWarning"))
        return(MissingDelegateWarning);
      break;
    }
    case 'O':
    {
      if (strEQ(name,"Opaque"))
        return(Opaque);
      if (strEQ(name,"OptionError"))
        return(OptionError);
      if (strEQ(name,"OptionWarning"))
        return(OptionWarning);
      break;
    }
    case 'P':
    {
      if (strEQ(name,"PluginWarning"))
        return(DelegateWarning);
      break;
    }
    case 'R':
    {
      if (strEQ(name,"ResourceLimitError"))
        return(ResourceLimitError);
      break;
    }
    case 'S':
    {
      if (strEQ(name,"Success"))
        return(0);
      break;
    }
    case 'T':
    {
      if (strEQ(name,"Transparent"))
        return(Transparent);
      break;
    }
    case 'X':
    {
      if (strEQ(name,"XServerError"))
        return(XServerError);
      if (strEQ(name,"XServerWarning"))
        return(XServerWarning);
      break;
    }
  }
  errno=EINVAL;
  return(0);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   D e s t r o y P a c k a g e I n f o                                       %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Method DestroyPackageInfo frees a previously created info structure.
%
%  The format of the DestroyPackageInfo routine is:
%
%      DestroyPackageInfo(info)
%
%  A description of each parameter follows:
%
%    o info: a structure of type info.
%
%
*/
static void DestroyPackageInfo(struct PackageInfo *info)
{
  DestroyImageInfo(info->image_info);
  DestroyQuantizeInfo(info->quantize_info);
  safefree((char *) info);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   e r r o r h a n d l e r                                                   %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Method errorhandler replaces ImageMagick's fatal error handler.  This
%  stores the message in a Perl variable,and longjmp's to return the error to
%  Perl.  If the error_flag variable is set, it also calls the Perl warn
%  routine.  Note that this doesn't exit but returns control to Perl; the
%  Image::Magick handle may be left in a bad state.
%
%  The format of the errorhandler routine is:
%
%      errorhandler(error,message,qualifier)
%
%  A description of each parameter follows:
%
%    o error: Specifies the numeric error category.
%
%    o message: Specifies the message to display before terminating the
%      program.
%
%    o qualifier: Specifies any qualifier to the message.
%
%
*/
static void errorhandler(const unsigned int error,const char *message,
  const char *qualifier)
{
  char
    text[MaxTextExtent];

  int
    error_number;

  error_number=errno;
  errno=0;
  FormatString(text,"Error %d: %.1024s%s%.1024s%s%s%.64s%s",error,
    (message ? message : "ERROR"),
    qualifier ? " (" : "",qualifier ? qualifier : "",qualifier ? ")" : "",
    error_number ? " [" : "",error_number ? strerror(error_number) : "",
    error_number? "]" : "");
  if ((error_list == NULL) || (error_jump == NULL) || warning_flag)
    {
      /*
        Set up message buffer.
      */
      warn("%s",text);
      if (error_jump == NULL)
        exit(error % 100);
    }
  if (error_list)
    {
      if (SvCUR(error_list))
        sv_catpv(error_list,"\n");
      sv_catpv(error_list,text);
    }
  longjmp(*error_jump,error);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   G e t L i s t                                                             %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Method GetList is recursively called by SetupList to traverse the
%  Image__Magick reference.  If building an reference_vector (see SetupList),
%  *current is the current position in *reference_vector and *last is the final
%  entry in *reference_vector.
%
%  The format of the GetList routine is:
%
%      GetList(info)
%
%  A description of each parameter follows:
%
%    o info: a structure of type info.
%
%
*/
static Image *GetList(SV *reference,SV ***reference_vector,int *current,
  int *last)
{
  Image
    *image;

  if (!reference)
    return(NULL);
  switch (SvTYPE(reference))
  {
    case SVt_PVAV:
    {
      AV
        *av;

      Image
        *head,
        *previous;

      int
        n;

      register int
        i;

      /*
        Array of images.
      */
      previous=(Image *) NULL;
      head=(Image *) NULL;
      av=(AV *) reference;
      n=av_len(av);
      for (i=0; i <= n; i++)
      {
        SV
          **rv;

        rv=av_fetch(av,i,0);
        if (rv && *rv && sv_isobject(*rv))
          {
            image=GetList(SvRV(*rv),reference_vector,current,last);
            if (!image)
              continue;
            if (image == previous)
              {
                MagickError(OptionError,"duplicate image in list",
                  "remove or use method Clone()");
                return(NULL);
              }
            image->previous=previous;
            *(previous ? &previous->next : &head)=image;
            for (previous=image; previous->next; previous=previous->next);
          }
      }
      return(head);
    }
    case SVt_PVMG:
    {
      /*
        Blessed scalar, one image.
      */
      image=(Image *) SvIV(reference);
      if (!image)
        return(NULL);
      image->previous=(Image *) NULL;
      image->next=(Image *) NULL;
      if (reference_vector)
        {
          if (*current == *last)
            {
              *last+=256;
              if (*reference_vector)
                *reference_vector=(SV **) saferealloc((char *)
                  *reference_vector,*last*sizeof(*reference_vector));
              else
                *reference_vector=(SV **)
                  safemalloc(*last*sizeof(*reference_vector));
            }
        (*reference_vector)[*current]=reference;
        (*reference_vector)[++(*current)]=NULL;
      }
      return(image);
    }
  }
  (void) fprintf(stderr,"GetList: Invalid reference type %ld\n",
    SvTYPE(reference));
  return((Image *) NULL);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   G e t P a c k a g e I n f o                                               %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Method GetPackageInfo looks up or creates an info structure for the given
%  Image__Magick reference.  If it does create a new one, the information in
%  oldinfo is used to initialize it.
%
%  The format of the GetPackageInfo routine is:
%
%      GetPackageInfo(info)
%
%  A description of each parameter follows:
%
%    o info: a structure of type info.
%
%
*/
static struct PackageInfo *GetPackageInfo(void *reference,
  struct PackageInfo *oldinfo)
{
  char
    message[MaxTextExtent];

  struct PackageInfo
    *info;

  SV
    *sv;

  FormatString(message,"%s::A_%lx_Z",PackageName,(long) reference);
  sv=perl_get_sv(message,(TRUE | 0x02));
  if (!sv)
    {
      MagickWarning(ResourceLimitWarning,"Unable to create info variable",
        message);
      return(oldinfo);
    }
  if (SvREFCNT(sv) == 0)
    SvREFCNT_inc(sv);
  if (SvIOKp(sv) && (info=(struct PackageInfo *) SvIV(sv)))
    return(info);
  info=ClonePackageInfo(oldinfo);
  sv_setiv(sv,(IV) info);
  return(info);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   L o o k u p S t r                                                         %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Method LookupStr searches through a list of strings matching it to string
%  and return its index in the list, or -1 for not found .
%
%  The format of the LookupStr routine is:
%
%      status=LookupStr(list,string)
%
%  A description of each parameter follows:
%
%    o status: Method LookupStr returns the index of string in the list
%      otherwise -1.
%
%    o list: a list of strings.
%
%    o string: a character string.
%
%
*/
static int LookupStr(char **list,const char *string)
{
  int
    longest,
    offset;

  register char
    **p;

  offset=(-1);
  longest=0;
  for (p=list; *p; p++)
    if (strEQcase(string,*p) > longest)
      {
        offset=p-list;
        longest=strEQcase(string,*p);
      }
  return(offset);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   S e t A t t r i b u t e                                                   %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Method SetAttribute sets the attribute to the value in sval.  This can
%  change either or both of image or info.
%
%  The format of the SetAttribute routine is:
%
%      status=SetAttribute(list,string)
%
%  A description of each parameter follows:
%
%    o status: Method SetAttribute returns the index of string in the list
%      otherwise -1.
%
%    o list: a list of strings.
%
%    o string: a character string.
%
%
*/
static void SetAttribute(struct PackageInfo *info,Image *image,char *attribute,
  SV *sval)
{
  ColorPacket
    *color,
    target_color;

  int
    blue,
    green,
    index,
    red,
    sp;

  register int
    i;

  switch (*attribute)
  {
    case 'A':
    case 'a':
    {
      if (strEQcase(attribute,"adjoin"))
        {
          sp=SvPOK(sval) ? LookupStr(BooleanTypes,SvPV(sval,na)) : SvIV(sval);
          if (sp < 0)
            {
              MagickWarning(OptionWarning,"Invalid adjoin type",SvPV(sval,na));
              return;
            }
          if (info)
            info->image_info->adjoin=sp;
          return;
        }
      if (strEQcase(attribute,"antialias"))
        {
          sp=SvPOK(sval) ? LookupStr(BooleanTypes,SvPV(sval,na)) : SvIV(sval);
          if (sp < 0)
            {
              MagickWarning(OptionWarning,"Invalid antialias type",
                SvPV(sval,na));
              return;
            }
          if (info)
            info->image_info->antialias=sp;
          return;
        }
      break;
    }
    case 'B':
    case 'b':
    {
      if (strEQcase(attribute,"background"))
        {
          if (info)
            (void) CloneString(&info->image_info->background_color,
              SvPV(sval,na));
          (void) QueryColorDatabase(SvPV(sval,na),&target_color);
          for ( ; image; image=image->next)
          {
            image->background_color.red=XDownScale(target_color.red);
            image->background_color.green=XDownScale(target_color.green);
            image->background_color.blue=XDownScale(target_color.blue);
          }
          return;
        }
      if (strEQcase(attribute,"blue_p"))
        {
          for ( ; image; image=image->next)
            (void) sscanf(SvPV(sval,na),"%lf,%lf",
              &image->chromaticity.blue_primary.x,
              &image->chromaticity.blue_primary.y);
          return;
        }
      if (strEQcase(attribute,"bordercolor"))
        {
          if (info)
            (void) CloneString(&info->image_info->border_color,SvPV(sval,na));
          (void) QueryColorDatabase(SvPV(sval,na),&target_color);
          for ( ; image; image=image->next)
          {
            image->border_color.red=XDownScale(target_color.red);
            image->border_color.green=XDownScale(target_color.green);
            image->border_color.blue=XDownScale(target_color.blue);
          }
          return;
        }
      break;
    }
    case 'C':
    case 'c':
    {
      if (strEQcase(attribute,"colormap"))
        {
          for ( ; image; image=image->next)
          {
            int
              i;

            if (image->class == DirectClass)
              continue;
            i=0;
            (void) sscanf(attribute,"%*[^[][%d",&i);
            if (i > image->colors)
              i%=image->colors;
            color=image->colormap+i;
            if (strchr(SvPV(sval,na),',') == 0)
              {
                QueryColorDatabase(SvPV(sval,na),&target_color);
                color->red=XDownScale(target_color.red);
                color->green=XDownScale(target_color.green);
                color->blue=XDownScale(target_color.blue);
              }
            else
              {
                red=color->red;
                green=color->green;
                blue=color->blue;
                (void) sscanf(SvPV(sval,na),"%d,%d,%d",&red,&green,&blue);
                color->red=(Quantum)
                  ((red < 0) ? 0 : (red > MaxRGB) ? MaxRGB : red);
                color->green=(Quantum)
                  ((green < 0) ? 0 : (green > MaxRGB) ? MaxRGB : green);
                color->blue=(Quantum)
                  ((blue < 0) ? 0 : (blue > MaxRGB) ? MaxRGB : blue);
              }
          }
          return;
        }
      if (strEQcase(attribute,"colorsp"))
        {
          if (info)
            {
              sp=SvPOK(sval) ? LookupStr(ColorspaceTypes,SvPV(sval,na)) :
                SvIV(sval);
              if (sp < 0)
                {
                  MagickWarning(OptionWarning,"Invalid colorspace type",
                    SvPV(sval,na));
                  return;
                }
              if (info)
                info->image_info->colorspace=(ColorspaceType) sp;
            }
        }
      if (strEQcase(attribute,"colors"))
        return;
      if (strEQcase(attribute,"compres"))
        {
          sp=SvPOK(sval) ? LookupStr(CompressionTypes,SvPV(sval,na)) :
            SvIV(sval);
          if (sp < 0)
            {
              MagickWarning(OptionWarning,"Invalid compression type",
                SvPV(sval,na));
              return;
            }
          if (info)
            info->image_info->compression=(CompressionType) sp;
          for ( ; image; image=image->next)
            image->compression=(CompressionType) sp;
          return;
        }
      break;
    }
    case 'D':
    case 'd':
    {
      if (strEQcase(attribute,"delay"))
        {
          if (info)
            (void) CloneString(&info->image_info->delay,SvPV(sval,na));
          for ( ; image; image=image->next)
            image->delay=SvIV(sval);
          return;
        }
      if (strEQcase(attribute,"density"))
        {
          if (!IsGeometry(SvPV(sval,na)))
            {
              MagickWarning(OptionWarning,"Invalid geometry on density",
                SvPV(sval,na));
              return;
            }
          if (info)
            (void) CloneString(&info->image_info->density,SvPV(sval,na));
          return;
        }
      if (strEQcase(attribute,"depth"))
        {
          if (info)
            info->image_info->depth=SvIV(sval);
          for ( ; image; image=image->next)
            image->depth=SvIV(sval);
          return;
        }
      if (strEQcase(attribute,"dispose"))
        {
          if (info)
            (void) CloneString(&info->image_info->dispose,SvPV(sval,na));
          for (; image; image=image->next)
            image->dispose=SvIV(sval);
          return;
        }
      if (strEQcase(attribute,"dither"))
        {
          if (info)
            {
              sp=SvPOK(sval) ? LookupStr(BooleanTypes,SvPV(sval,na)) :
                SvIV(sval);
              if (sp < 0)
                {
                  MagickWarning(OptionWarning,"Invalid dither type",
                    SvPV(sval,na));
                  return;
                }
              info->image_info->dither=sp;
            }
          return;
        }
      if (strEQcase(attribute,"display"))
        {
          display:
          if (info)
            (void) CloneString(&info->image_info->server_name,SvPV(sval,na));
          return;
        }
      break;
    }
    case 'E':
    case 'e':
      break;
    case 'F':
    case 'f':
    {
      if (strEQcase(attribute,"filen"))
        {
          if (info)
            (void) strncpy(info->image_info->filename,SvPV(sval,na),
              MaxTextExtent-1);
          for ( ; image; image=image->next)
            (void) strncpy(image->filename,SvPV(sval,na),MaxTextExtent-1);
          return;
        }
      if (strEQcase(attribute,"file"))
        {
          if (info)
            info->image_info->file=IoIFP(sv_2io(sval));
          return;
        }
      if (strEQcase(attribute,"font"))
        {
          if (info)
            (void) CloneString(&info->image_info->font,SvPV(sval,na));
          return;
        }
      if (strEQcase(attribute,"fuzz"))
        {
          if (info)
            info->image_info->fuzz=SvIV(sval);
          for ( ; image; image=image->next)
            image->fuzz=SvIV(sval);
          return;
        }
      break;
    }
    case 'G':
    case 'g':
    {
      if (strEQcase(attribute,"green_p"))
        {
          for ( ; image; image=image->next)
            (void) sscanf(SvPV(sval,na),"%lf,%lf",
              &image->chromaticity.green_primary.x,
              &image->chromaticity.green_primary.y);
          return;
        }
      break;
    }
    case 'H':
    case 'h':
      break;
    case 'I':
    case 'i':
    {
      if (strEQcase(attribute,"iterat"))
        {
  iterations:
          if (info)
            (void) CloneString(&info->image_info->iterations,SvPV(sval,na));
          for ( ; image; image=image->next)
            image->iterations=SvIV(sval);
          return;
        }
      if (strEQcase(attribute,"interla"))
        {
          sp=SvPOK(sval) ? LookupStr(InterlaceTypes,SvPV(sval,na)) : SvIV(sval);
          if (sp < 0)
            {
              MagickWarning(OptionWarning,"Invalid interlace value",
                SvPV(sval,na));
              return;
            }
          if (info)
            info->image_info->interlace=(InterlaceType) sp;
          for ( ; image; image=image->next)
            image->interlace=(InterlaceType) sp;
          return;
        }
      break;
    }
    case 'J':
    case 'j':
      break;
    case 'K':
    case 'k':
      break;
    case 'L':
    case 'l':
    {
      if (strEQcase(attribute,"loop"))
        goto iterations;
      break;
    }
    case 'M':
    case 'm':
    {
      if (strEQcase(attribute,"magick"))
        {
          if (info)
            {
              FormatString(info->image_info->filename,"%.1024s:",
                SvPV(sval,na));
              SetImageInfo(info->image_info,True);
              if (*info->image_info->magick == '\0')
                MagickWarning(OptionWarning,"Unrecognized image format",
                  info->image_info->filename);
              else
                for ( ; image; image=image->next)
                  (void) strcpy(image->magick,info->image_info->magick);
            }
          return;
        }
      if (strEQcase(attribute,"mattec") || strEQcase(attribute,"matte_color"))
        {
          if (info)
            (void) CloneString(&info->image_info->matte_color,SvPV(sval,na));
          (void) QueryColorDatabase(SvPV(sval,na),&target_color);
          for ( ; image; image=image->next)
          {
            image->matte_color.red=XDownScale(target_color.red);
            image->matte_color.green=XDownScale(target_color.green);
            image->matte_color.blue=XDownScale(target_color.blue);
          }
          return;
        }
      if (strEQcase(attribute,"matte"))
        {
          sp=SvPOK(sval) ? LookupStr(BooleanTypes,SvPV(sval,na)) :
            SvIV(sval);
          if (sp < 0)
            {
              MagickWarning(OptionWarning,"Invalid matte type",SvPV(sval,na));
              return;
            }
          for ( ; image; image=image->next)
            image->matte=sp;
          return;
        }
      if (strEQcase(attribute,"monoch"))
        {
          sp=SvPOK(sval) ? LookupStr(BooleanTypes,SvPV(sval,na)) : SvIV(sval);
          if (sp < 0)
            {
              MagickWarning(OptionWarning,"Invalid monochrome type",
                SvPV(sval,na));
              return;
            }
          if (info)
            info->image_info->monochrome=sp;
          return;
        }
      break;
    }
    case 'O':
    case 'o':
      break;
    case 'P':
    case 'p':
    {
      if (strEQcase(attribute,"page"))
        {
          char
            *p;

          p=PostscriptGeometry(SvPV(sval,na));
          if (!p)
            return;
          if (info)
            (void) CloneString(&info->image_info->page,p);
          for ( ; image; image=image->next)
            image->page=PostscriptGeometry(SvPV(sval,na));
          DestroyPostscriptGeometry(p);
          return;
        }
      if (strEQcase(attribute,"pen"))
        {
          if (info)
            (void) CloneString(&info->image_info->pen,SvPV(sval,na));
          return;
        }
      if (strEQcase(attribute,"pixel"))
        {
          int
            x,
            y;

          RunlengthPacket
            *color;

          for ( ; image; image=image->next)
          {
            if (!UncondenseImage(image))
              continue;
            x=0;
            y=0;
            (void) sscanf(attribute,"%*[^[][%d,%d",&x,&y);
            if (y > image->rows)
              y%=image->rows;
            if (x > image->columns)
              x%=image->columns;
            color=image->pixels+(y*image->columns+x);
            image->class=DirectClass;
            if (strchr(SvPV(sval,na),',') == 0)
              {
                QueryColorDatabase(SvPV(sval,na),&target_color);
                color->red=XDownScale(target_color.red);
                color->green=XDownScale(target_color.green);
                color->blue=XDownScale(target_color.blue);
              }
            else
              {
                red=color->red;
                green=color->green;
                blue=color->blue;
                index=color->index;
                (void) sscanf(SvPV(sval,na),"%d,%d,%d,%d",&red,&green,&blue,
                  &index);
                color->red=(Quantum)
                  ((red < 0) ? 0 : (red > MaxRGB) ? MaxRGB : red);
                color->green=(Quantum)
                  ((green < 0) ? 0 : (green > MaxRGB) ? MaxRGB : green);
                color->blue=(Quantum)
                  ((blue < 0) ? 0 : (blue > MaxRGB) ? MaxRGB : blue);
                color->index=(unsigned short) ((index < Transparent) ?
                  Transparent : (index > Opaque) ? Opaque : index);
              }
          }
          return;
        }
      if (strEQcase(attribute,"points"))
        {
          if (info && (info->image_info->pointsize=SvIV(sval)) <= 0)
            info->image_info->pointsize=12;
          return;
        }
      if (strEQcase(attribute,"preview"))
        {
          sp=SvPOK(sval) ? LookupStr(PreviewTypes,SvPV(sval,na)) : SvIV(sval);
          if (sp < 0)
            {
              MagickWarning(OptionWarning,"Invalid preview type",SvPV(sval,na));
              return;
            }
          if (info)
            info->image_info->preview_type=(PreviewType) sp;
          return;
        }
      break;
    }
    case 'Q':
    case 'q':
    {
      if (strEQcase(attribute,"qualit"))
        {
          if (info && (info->image_info->quality=SvIV(sval)) <= 0)
            info->image_info->quality=75;
          return;
        }
      break;
    }
    case 'R':
    case 'r':
    {
      if (strEQcase(attribute,"red_p"))
        {
          for ( ; image; image=image->next)
            (void) sscanf(SvPV(sval,na),"%lf,%lf",
              &image->chromaticity.red_primary.x,
              &image->chromaticity.red_primary.y);
          return;
        }
      if (strEQcase(attribute,"render"))
        {
          sp=SvPOK(sval) ? LookupStr(IntentTypes,SvPV(sval,na)) : SvIV(sval);
          if (sp < 0)
            {
              MagickWarning(OptionWarning,"Invalid rendering intent",
                SvPV(sval,na));
              return;
            }
         for ( ; image; image=image->next)
           image->rendering_intent=(RenderingIntent) sp;
         return;
       }
      break;
    }
    case 'S':
    case 's':
    {
      if (strEQcase(attribute,"scene"))
        {
          for ( ; image; image=image->next)
            image->scene=SvIV(sval);
          return;
        }
      if (strEQcase(attribute,"subim"))
        {
          if (info)
            info->image_info->subimage=SvIV(sval);
          return;
        }
      if (strEQcase(attribute,"subra"))
        {
          if (info)
            info->image_info->subrange=SvIV(sval);
          return;
        }
      if (strEQcase(attribute,"server"))
        goto display;
      if (strEQcase(attribute,"size"))
        {
          if (info)
            {
              if (!IsGeometry(SvPV(sval,na)))
                {
                  MagickWarning(OptionWarning,"Invalid geometry on size",
                    SvPV(sval,na));
                  return;
                }
              (void) CloneString(&info->image_info->size,SvPV(sval,na));
            }
          return;
        }
      break;
    }
    case 'T':
    case 't':
    {
      if (strEQcase(attribute,"tile"))
        {
          if (info)
            (void) CloneString(&info->image_info->tile,SvPV(sval,na));
          return;
        }
      if (strEQcase(attribute,"texture"))
        {
          if (info)
            (void) CloneString(&info->image_info->texture,SvPV(sval,na));
          return;
        }
      break;
    }
    case 'U':
    case 'u':
    {
      if (strEQcase(attribute,"unit"))
        {
          sp=SvPOK(sval) ? LookupStr(ResolutionTypes,SvPV(sval,na)) :
            SvIV(sval);
          if (sp < 0)
            {
              MagickWarning(OptionWarning,"Invalid resolution unit",
                SvPV(sval,na));
              return;
            }
          if (info)
            info->image_info->units=(ResolutionType) sp;
          for ( ; image; image=image->next)
            image->units=(ResolutionType) sp;
          return;
        }
      break;
    }
    case 'V':
    case 'v':
    {
      if (strEQcase(attribute,"verbose"))
        {
          sp=SvPOK(sval) ? LookupStr(BooleanTypes,SvPV(sval,na)) : SvIV(sval);
          if (sp < 0)
            {
              MagickWarning(OptionWarning,"Invalid verbose type",
                SvPV(sval,na));
              return;
            }
          if (info)
            info->image_info->verbose=sp;
          return;
        }
      if (strEQcase(attribute,"view"))
        {
          if (info)
            (void) CloneString(&info->image_info->view,SvPV(sval,na));
          return;
        }
      break;
    }
    case 'W':
    case 'w':
    {
      if (strEQcase(attribute,"white_p"))
        {
          for ( ; image; image=image->next)
            (void) sscanf(SvPV(sval,na),"%lf,%lf",
              &image->chromaticity.white_point.x,
              &image->chromaticity.white_point.y);
          return;
        }
      break;
    }
    case 'X':
    case 'x':
      break;
    case 'Y':
    case 'y':
      break;
    case 'Z':
    case 'z':
      break;
  }
  MagickWarning(OptionWarning,"Invalid attribute",attribute);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   S e t u p L i s t                                                         %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Method SetupList returns the list of all the images linked by their
%  image->next and image->previous link lists for use with ImageMagick.  If
%  info is non-NULL, an info structure is returned in *info.  If
%  reference_vector is non-NULL,an array of SV* are returned in
%  *reference_vector.  Reference_vector is used when the images are going to be
%  replaced with new Image*'s.
%
%  The format of the SetupList routine is:
%
%      status=SetupList(list,string)
%
%  A description of each parameter follows:
%
%    o status: Method SetAttribute returns the index of string in the list
%      otherwise -1.
%
%    o list: a list of strings.
%
%    o string: a character string.
%
%
*/
static Image *SetupList(SV *reference,struct PackageInfo **info,
  SV ***reference_vector)
{
  Image
    *image;

  int
    current,
    last;

  if (reference_vector)
    *reference_vector=NULL;
  if (info)
    *info=NULL;
  current=0;
  last=0;
  image=GetList(reference,reference_vector,&current,&last);
  if (info && (SvTYPE(reference) == SVt_PVAV))
    *info=GetPackageInfo((void *) reference,(struct PackageInfo *) NULL);
  return(image);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   s t r E Q c a s e                                                         %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Method strEQcase compares two strings and returns 0 if they are the
%  same or if the second string runs out first.  The comparison is case
%  insensitive.
%
%  The format of the strEQcase routine is:
%
%      status=strEQcase(p,q)
%
%  A description of each parameter follows:
%
%    o status: Method strEQcase returns zero if strings p and q are the
%      same or if the second string runs out first.
%
%    o p: a character string.
%
%    o q: a character string.
%
%
*/
static int strEQcase(const char *p,const char *q)
{
  char
    c;

  register int
    i;

  for (i=0 ; c=(*q); i++)
  {
    if ((isUPPER(c) ? toLOWER(c) : c) != (isUPPER(*p) ? toLOWER(*p) : *p))
      return(0);
    p++;
    q++;
  }
  return(i);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   w a r n i n g h a n d l e r                                               %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Method warninghandler replaces the ImageMagick warning handler.  This stores
%  the (possibly multiple) messages in a Perl variable for later returning.  If
%  the warning_flag variable is set, it also calls the Perl warn routine.
%
%  The format of the warninghandler routine is:
%
%      warninghandler(warning,message,qualifier)
%
%  A description of each parameter follows:
%
%    o warning: Specifies the numeric warning category.
%
%    o message: Specifies the message to display before terminating the
%      program.
%
%    o qualifier: Specifies any qualifier to the message.
%
%
*/
static void warninghandler(const unsigned int warning,const char *message,
  const char *qualifier)
{
  char
    text[MaxTextExtent];

  int
    error_number;

  error_number=errno;
  errno=0;
  if (!message)
    return;
  FormatString(text,"Warning %d: %.1024s%s%.1024s%s%s%.64s%s",warning,
    message,qualifier ? " (" : "",qualifier ? qualifier : "",
    qualifier? ")" : "",error_number ? " [" : "",
    error_number ? strerror(error_number) : "",error_number ? "]" : "");
  if ((error_list == NULL) || warning_flag)
    {
      /*
        Set up message buffer.
      */
      warn("%s",text);
      if (error_list == NULL)
        return;
    }
  if (SvCUR(error_list))
    sv_catpv(error_list,"\n");  /* add \n separator between messages */
  sv_catpv(error_list,text);
}

/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   I m a g e : : M a g i c k                                                 %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
*/
#line 1717 "Magick.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 1859 "Magick.c"

XS_EUPXS(XS_Image__Magick_constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Image__Magick_constant)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "name, argument");
    {
	char *	name = (char *)SvPV_nolen(ST(0))
;
	int	argument = (int)SvIV(ST(1))
;
	double	RETVAL;
	dXSTARG;

	RETVAL = constant(name, argument);
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Image__Magick_Animate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Image__Magick_Animate)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 1)
       croak_xs_usage(cv,  "ref, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Image__Magick
diff -urN ocaml-3.12.0.orig/asmcomp/arm/emit.mlp ocaml-3.12.0/asmcomp/arm/emit.mlp
--- ocaml-3.12.0.orig/asmcomp/arm/emit.mlp	2010-04-22 18:33:18.000000000 +0900
+++ ocaml-3.12.0/asmcomp/arm/emit.mlp	2010-09-11 03:41:15.000000000 +0900
@@ -30,13 +30,36 @@
 
 (* Output a label *)
 
+let label_prefix =
+  match Config.system with
+    "linux_elf" -> ".L"
+  | "bsd_elf" -> ".L"
+  | "solaris" -> ".L"
+  | "beos" -> ".L"
+  | "gnu" -> ".L"
+  | _ -> "L"
+
 let emit_label lbl =
-  emit_string ".L"; emit_int lbl
+  emit_string label_prefix; emit_int lbl
 
 (* Output a symbol *)
 
+let symbol_prefix =
+  match Config.system with
+    "linux_elf" -> ""
+  | "bsd_elf" -> ""
+  | "solaris" -> ""
+  | "beos" -> ""
+  | "gnu" -> ""
+  | _ -> "_"
+
 let emit_symbol s =
-  Emitaux.emit_symbol '$' s
+  emit_string symbol_prefix; Emitaux.emit_symbol '$' s
+
+let global_dir =
+  match Config.system with
+  | "macosx" -> ".globl"
+  | _ -> ".global"
 
 (* Output a pseudo-register *)
 
@@ -310,7 +333,7 @@
         if alloc then begin
           let lbl = label_constant symbol_constants s 1 in
           `	ldr	r12, {emit_label lbl} @ {emit_symbol s}\n`;
-          `{record_frame i.live}	bl	caml_c_call\n`; 2
+          `{record_frame i.live}	bl	{emit_symbol "caml_c_call"}\n`; 2
         end else begin
           `	bl	{emit_symbol s}\n`; 1
         end
@@ -362,15 +385,15 @@
           let ni = emit_intconst (phys_reg 8 (*r12*)) (Nativeint.of_int n) in
           `	sub	alloc_ptr, alloc_ptr, r12\n`;
           `	cmp	alloc_ptr, alloc_limit\n`;
-          `{record_frame i.live}	blcc    caml_call_gc\n`;
+          `{record_frame i.live}	blcc    {emit_symbol "caml_call_gc"}\n`;
           `	add	{emit_reg i.res.(0)}, alloc_ptr, #4\n`;
           4 + ni
         end else if n = 8 || n = 12 || n = 16 then begin
-          `{record_frame i.live}	bl	caml_alloc{emit_int ((n-4)/4)}\n`;
+          `{record_frame i.live}	bl	{emit_symbol "caml_alloc"}{emit_int ((n-4)/4)}\n`;
           `	add	{emit_reg i.res.(0)}, alloc_ptr, #4\n`; 2
         end else begin
           let ni = emit_intconst (phys_reg 8 (*r12*)) (Nativeint.of_int n) in
-          `{record_frame i.live}	bl	caml_allocN\n`;
+          `{record_frame i.live}	bl	{emit_symbol "caml_allocN"}\n`;
           `	add	{emit_reg i.res.(0)}, alloc_ptr, #4\n`;
           2 + ni
         end
@@ -384,7 +407,7 @@
         `	mov{emit_string	comp}   {emit_reg i.res.(0)}, #1\n`; 3
     | Lop(Iintop(Icheckbound)) ->
         `	cmp	{emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`;
-        `	blls	caml_ml_array_bound_error\n`; 2
+        `	blls	{emit_symbol "caml_ml_array_bound_error"}\n`; 2
     | Lop(Iintop op) ->
         let instr = name_for_int_operation op in
         `	{emit_string	instr}     {emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, {emit_reg i.arg.(1)}\n`; 1
@@ -421,7 +444,7 @@
         `	mov{emit_string	comp}   {emit_reg i.res.(0)}, #1\n`; 3
     | Lop(Iintop_imm(Icheckbound, n)) ->
         `	cmp	{emit_reg i.arg.(0)}, #{emit_int n}\n`;
-        `	blls	caml_ml_array_bound_error\n`; 2
+        `	blls	{emit_symbol "caml_ml_array_bound_error"}\n`; 2
     | Lop(Iintop_imm(op, n)) ->
         let instr = name_for_int_operation op in
         `	{emit_string	instr}     {emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, #{emit_int n}\n`; 1
@@ -440,7 +463,7 @@
         1
     | Lop(Ispecific(Ishiftcheckbound shift)) ->
         `	cmp	{emit_reg i.arg.(1)}, {emit_reg i.arg.(0)}, lsr #{emit_int shift}\n`;
-        `	blcs	caml_ml_array_bound_error\n`; 2
+        `	blcs	{emit_symbol "caml_ml_array_bound_error"}\n`; 2
     | Lop(Ispecific(Irevsubimm n)) ->
         `	rsb	{emit_reg i.res.(0)}, {emit_reg i.arg.(0)}, #{emit_int n}\n`; 1
     | Lreloadretaddr ->
@@ -555,7 +578,7 @@
   Hashtbl.clear float_constants;
   `	.text\n`;
   `	.align	2\n`;
-  `	.global	{emit_symbol fundecl.fun_name}\n`;
+  `	{emit_string global_dir}	{emit_symbol fundecl.fun_name}\n`;
   `{emit_symbol fundecl.fun_name}:\n`;
   let n = frame_size() in
   ignore(emit_stack_adjustment "sub" n);
@@ -569,7 +592,7 @@
 
 let emit_item = function
     Cglobal_symbol s ->
-      `	.global	{emit_symbol s}\n`;
+      `	{emit_string global_dir}	{emit_symbol s}\n`;
   | Cdefine_symbol s ->
       `{emit_symbol s}:\n`
   | Cdefine_label lbl ->
@@ -604,31 +627,31 @@
 (* Beginning / end of an assembly file *)
 
 let begin_assembly() =
-  `trap_ptr     .req    r11\n`;
-  `alloc_ptr    .req    r8\n`;
-  `alloc_limit  .req    r10\n`;
+  `trap_ptr .req r11\n`;
+  `alloc_ptr .req r8\n`;
+  `alloc_limit .req r10\n`;
   let lbl_begin = Compilenv.make_symbol (Some "data_begin") in
   `	.data\n`;
-  `	.global	{emit_symbol lbl_begin}\n`;
+  `	{emit_string global_dir}	{emit_symbol lbl_begin}\n`;
   `{emit_symbol lbl_begin}:\n`;
   let lbl_begin = Compilenv.make_symbol (Some "code_begin") in
   `	.text\n`;
-  `	.global	{emit_symbol lbl_begin}\n`;
+  `	{emit_string global_dir}	{emit_symbol lbl_begin}\n`;
   `{emit_symbol lbl_begin}:\n`
 
 let end_assembly () =
   let lbl_end = Compilenv.make_symbol (Some "code_end") in
   `	.text\n`;
-  `	.global	{emit_symbol lbl_end}\n`;
+  `	{emit_string global_dir}	{emit_symbol lbl_end}\n`;
   `{emit_symbol lbl_end}:\n`;
   let lbl_end = Compilenv.make_symbol (Some "data_end") in
   `	.data\n`;
-  `	.global	{emit_symbol lbl_end}\n`;
+  `	{emit_string global_dir}	{emit_symbol lbl_end}\n`;
   `{emit_symbol lbl_end}:\n`;
   `	.word	0\n`;
   let lbl = Compilenv.make_symbol (Some "frametable") in
   `	.data\n`;
-  `	.global	{emit_symbol lbl}\n`;
+  `	{emit_string global_dir}	{emit_symbol lbl}\n`;
   `{emit_symbol lbl}:\n`;
   `	.word	{emit_int (List.length !frame_descriptors)}\n`;
   List.iter emit_frame !frame_descriptors;
diff -urN ocaml-3.12.0.orig/asmcomp/cmmgen.ml ocaml-3.12.0/asmcomp/cmmgen.ml
--- ocaml-3.12.0.orig/asmcomp/cmmgen.ml	2010-05-19 20:29:38.000000000 +0900
+++ ocaml-3.12.0/asmcomp/cmmgen.ml	2010-09-11 03:35:07.000000000 +0900
@@ -1666,7 +1666,9 @@
   if size_int = 8 then
     Csymbol_address("caml_int64_ops") :: Cint lo :: cont
   else begin
-    let hi = Int64.to_nativeint (Int64.shift_right n 32) in
+    assert (size_int = 4);
+    let lo = Int64.to_nativeint (Int64.shift_right_logical (Int64.shift_left n 32) 32) in
+    let hi = Int64.to_nativeint (Int64.shift_right_logical n 32) in
     if big_endian then
       Csymbol_address("caml_int64_ops") :: Cint hi :: Cint lo :: cont
     else
diff -urN ocaml-3.12.0.orig/asmrun/arm.S ocaml-3.12.0/asmrun/arm.S
--- ocaml-3.12.0.orig/asmrun/arm.S	2009-05-04 22:46:46.000000000 +0900
+++ ocaml-3.12.0/asmrun/arm.S	2010-09-11 03:51:14.000000000 +0900
@@ -15,6 +15,25 @@
 
 /* Asm part of the runtime system, ARM processor */
 
+/* Linux/BSD with ELF binaries and Solaris do not prefix identifiers with _.
+   Linux/BSD with a.out binaries and NextStep do.
+   Copied from asmrun/i386.S */
+
+#if defined(SYS_solaris)
+#define CONCAT(a,b) a/**/b
+#else
+#define CONCAT(a,b) a##b
+#endif
+
+#if defined(SYS_linux_elf) || defined(SYS_bsd_elf) \
+ || defined(SYS_solaris) || defined(SYS_beos) || defined(SYS_gnu)
+#define G(x) x
+#define LBL(x) CONCAT(.L,x)
+#else
+#define G(x) CONCAT(_,x)
+#define LBL(x) CONCAT(L,x)
+#endif
+
 trap_ptr        .req    r11
 alloc_ptr       .req    r8
 alloc_limit     .req    r10
@@ -23,108 +42,108 @@
 
 /* Allocation functions and GC interface */
 
-        .globl caml_call_gc
-caml_call_gc:
+        .globl G(caml_call_gc)
+G(caml_call_gc):
     /* Record return address and desired size */
     /* Can use alloc_limit as a temporary since it will be reloaded by
        invoke_gc */
-        ldr     alloc_limit, .Lcaml_last_return_address
+        ldr     alloc_limit, LBL(caml_last_return_address)
         str     lr, [alloc_limit, #0]
-        ldr     alloc_limit, .Lcaml_requested_size
+        ldr     alloc_limit, LBL(caml_requested_size)
         str     r12, [alloc_limit, #0]
     /* Branch to shared GC code */
-        bl      .Linvoke_gc
+        bl      LBL(invoke_gc)
     /* Finish allocation */
-	ldr	r12, .Lcaml_requested_size
+	ldr	r12, LBL(caml_requested_size)
 	ldr	r12, [r12, #0]
 	sub	alloc_ptr, alloc_ptr, r12
         bx      lr
 
-        .globl caml_alloc1
-caml_alloc1:
+        .globl G(caml_alloc1)
+G(caml_alloc1):
         sub     alloc_ptr, alloc_ptr, #8
         cmp     alloc_ptr, alloc_limit
         movcs   pc, lr                /* Return if alloc_ptr >= alloc_limit */
     /* Record return address */
-        ldr     r12, .Lcaml_last_return_address
+        ldr     r12, LBL(caml_last_return_address)
         str     lr, [r12, #0]
     /* Invoke GC */
-        bl      .Linvoke_gc
+        bl      LBL(invoke_gc)
     /* Try again */
-        b       caml_alloc1
+        b       G(caml_alloc1)
 
-        .globl caml_alloc2
-caml_alloc2:
+        .globl G(caml_alloc2)
+G(caml_alloc2):
         sub     alloc_ptr, alloc_ptr, #12
         cmp     alloc_ptr, alloc_limit
         movcs   pc, lr                /* Return if alloc_ptr >= alloc_limit */
     /* Record return address */
-        ldr     r12, .Lcaml_last_return_address
+        ldr     r12, LBL(caml_last_return_address)
         str     lr, [r12, #0]
     /* Invoke GC */
-        bl      .Linvoke_gc
+        bl      LBL(invoke_gc)
     /* Try again */
-        b       caml_alloc2
+        b       G(caml_alloc2)
 
-        .globl caml_alloc3
-caml_alloc3:
+        .globl G(caml_alloc3)
+G(caml_alloc3):
         sub     alloc_ptr, alloc_ptr, #16
         cmp     alloc_ptr, alloc_limit
         movcs   pc, lr                /* Return if alloc_ptr >= alloc_limit */
     /* Record return address */
-        ldr     r12, .Lcaml_last_return_address
+        ldr     r12, LBL(caml_last_return_address)
         str     lr, [r12, #0]
     /* Invoke GC */
-        bl      .Linvoke_gc
+        bl      LBL(invoke_gc)
     /* Try again */
-        b       caml_alloc3
+        b       G(caml_alloc3)
 
-        .globl caml_allocN
-caml_allocN:
+        .globl G(caml_allocN)
+G(caml_allocN):
         sub     alloc_ptr, alloc_ptr, r12
         cmp     alloc_ptr, alloc_limit
         movcs   pc, lr                /* Return if alloc_ptr >= alloc_limit */
     /* Record return address and desired size */
     /* Can use alloc_limit as a temporary since it will be reloaded by
        invoke_gc */
-        ldr     alloc_limit, .Lcaml_last_return_address
+        ldr     alloc_limit, LBL(caml_last_return_address)
         str     lr, [alloc_limit, #0]
-        ldr     alloc_limit, .Lcaml_requested_size
+        ldr     alloc_limit, LBL(caml_requested_size)
         str     r12, [alloc_limit, #0]
     /* Invoke GC */
-        bl      .Linvoke_gc
+        bl      LBL(invoke_gc)
     /* Try again */
-	ldr	r12, .Lcaml_requested_size
+	ldr	r12, LBL(caml_requested_size)
 	ldr	r12, [r12, #0]
-        b       caml_allocN
+        b       G(caml_allocN)
 
 /* Shared code to invoke the GC */
-.Linvoke_gc:
+LBL(invoke_gc):
     /* Record lowest stack address */
-        ldr     r12, .Lcaml_bottom_of_stack
+        ldr     r12, LBL(caml_bottom_of_stack)
         str     sp, [r12, #0]
     /* Save integer registers and return address on stack */
         stmfd   sp!, {r0,r1,r2,r3,r4,r5,r6,r7,r12,lr}
     /* Store pointer to saved integer registers in caml_gc_regs */
-        ldr     r12, .Lcaml_gc_regs
+        ldr     r12, LBL(caml_gc_regs)
         str     sp, [r12, #0]
     /* Save current allocation pointer for debugging purposes */
-        ldr     r12, .Lcaml_young_ptr
+        ldr     r12, LBL(caml_young_ptr)
         str     alloc_ptr, [r12, #0]
     /* Save trap pointer in case an exception is raised during GC */
-        ldr     r12, .Lcaml_exception_pointer
+        ldr     r12, LBL(caml_exception_pointer)
         str     trap_ptr, [r12, #0]
     /* Call the garbage collector */
-        bl      caml_garbage_collection
+        bl      G(caml_garbage_collection)
     /* Restore the registers from the stack */
         ldmfd   sp!, {r0,r1,r2,r3,r4,r5,r6,r7,r12}
     /* Reload return address */
-        ldr     r12, .Lcaml_last_return_address
+        ldr     r12, LBL(caml_last_return_address)
         ldr     lr, [r12, #0]
     /* Reload new allocation pointer and allocation limit */
-        ldr     r12, .Lcaml_young_ptr
+        ldr     r12, LBL(caml_young_ptr)
         ldr     alloc_ptr, [r12, #0]
-        ldr     r12, .Lcaml_young_limit
+        ldr     r12, LBL(caml_young_limit)
         ldr     alloc_limit, [r12, #0]
     /* Return to caller */
         ldr     r12, [sp], #4
@@ -133,25 +152,25 @@
 /* Call a C function from Caml */
 /* Function to call is in r12 */
 
-        .globl caml_c_call
-caml_c_call:
+        .globl G(caml_c_call)
+G(caml_c_call):
     /* Preserve return address in callee-save register r4 */
         mov     r4, lr
     /* Record lowest stack address and return address */
-        ldr     r5, .Lcaml_last_return_address
-        ldr     r6, .Lcaml_bottom_of_stack
+        ldr     r5, LBL(caml_last_return_address)
+        ldr     r6, LBL(caml_bottom_of_stack)
         str     lr, [r5, #0]
         str     sp, [r6, #0]
     /* Make the exception handler and alloc ptr available to the C code */
-        ldr     r6, .Lcaml_young_ptr
-        ldr     r7, .Lcaml_exception_pointer
+        ldr     r6, LBL(caml_young_ptr)
+        ldr     r7, LBL(caml_exception_pointer)
         str     alloc_ptr, [r6, #0]
         str     trap_ptr, [r7, #0]
     /* Call the function */
         mov     lr, pc
         bx      r12
     /* Reload alloc ptr and alloc limit */
-        ldr     r5, .Lcaml_young_limit
+        ldr     r5, LBL(caml_young_limit)
         ldr     alloc_ptr, [r6, #0]    /* r6 still points to caml_young_ptr */
         ldr     alloc_limit, [r5, #0]
     /* Return */
@@ -159,117 +178,117 @@
 
 /* Start the Caml program */
 
-        .globl caml_start_program
-caml_start_program:
-        ldr     r12, .Lcaml_program
+        .globl G(caml_start_program)
+G(caml_start_program):
+        ldr     r12, LBL(caml_program)
 
 /* Code shared with caml_callback* */
 /* Address of Caml code to call is in r12 */
 /* Arguments to the Caml code are in r0...r3 */
 
-.Ljump_to_caml:
+LBL(jump_to_caml):
     /* Save return address and callee-save registers */
         stmfd   sp!, {r4,r5,r6,r7,r8,r10,r11,lr} /* 8-alignment */
     /* Setup a callback link on the stack */
         sub     sp, sp, #4*4                    /* 8-alignment */
-        ldr     r4, .Lcaml_bottom_of_stack
+        ldr     r4, LBL(caml_bottom_of_stack)
         ldr     r4, [r4, #0]
         str     r4, [sp, #0]
-        ldr     r4, .Lcaml_last_return_address
+        ldr     r4, LBL(caml_last_return_address)
         ldr     r4, [r4, #0]
         str     r4, [sp, #4]
-        ldr     r4, .Lcaml_gc_regs
+        ldr     r4, LBL(caml_gc_regs)
         ldr     r4, [r4, #0]
         str     r4, [sp, #8]
     /* Setup a trap frame to catch exceptions escaping the Caml code */
         sub     sp, sp, #4*2
-        ldr     r4, .Lcaml_exception_pointer
+        ldr     r4, LBL(caml_exception_pointer)
         ldr     r4, [r4, #0]
         str     r4, [sp, #0]
-        ldr     r4, .LLtrap_handler
+        ldr     r4, LBL(Ltrap_handler)
         str     r4, [sp, #4]
         mov     trap_ptr, sp
     /* Reload allocation pointers */
-        ldr     r4, .Lcaml_young_ptr
+        ldr     r4, LBL(caml_young_ptr)
         ldr     alloc_ptr, [r4, #0]
-        ldr     r4, .Lcaml_young_limit
+        ldr     r4, LBL(caml_young_limit)
         ldr     alloc_limit, [r4, #0]
     /* Call the Caml code */
         mov     lr, pc
         bx      r12
-.Lcaml_retaddr:
+LBL(caml_retaddr):
     /* Pop the trap frame, restoring caml_exception_pointer */
-        ldr     r4, .Lcaml_exception_pointer
+        ldr     r4, LBL(caml_exception_pointer)
         ldr     r5, [sp, #0]
         str     r5, [r4, #0]
         add     sp, sp, #2 * 4
     /* Pop the callback link, restoring the global variables */
-.Lreturn_result:
-        ldr     r4, .Lcaml_bottom_of_stack
+LBL(return_result):
+        ldr     r4, LBL(caml_bottom_of_stack)
         ldr     r5, [sp, #0]
         str     r5, [r4, #0]
-        ldr     r4, .Lcaml_last_return_address
+        ldr     r4, LBL(caml_last_return_address)
         ldr     r5, [sp, #4]
         str     r5, [r4, #0]
-        ldr     r4, .Lcaml_gc_regs
+        ldr     r4, LBL(caml_gc_regs)
         ldr     r5, [sp, #8]
         str     r5, [r4, #0]
         add     sp, sp, #4*4
     /* Update allocation pointer */
-        ldr     r4, .Lcaml_young_ptr
+        ldr     r4, LBL(caml_young_ptr)
         str     alloc_ptr, [r4, #0]
     /* Reload callee-save registers and return */
         ldmfd   sp!, {r4,r5,r6,r7,r8,r10,r11,lr}
 	bx	lr
 
     /* The trap handler */
-.Ltrap_handler:
+LBL(trap_handler):
     /* Save exception pointer */
-        ldr     r4, .Lcaml_exception_pointer
+        ldr     r4, LBL(caml_exception_pointer)
         str     trap_ptr, [r4, #0]
     /* Encode exception bucket as an exception result */
         orr     r0, r0, #2
     /* Return it */
-        b       .Lreturn_result
+        b       LBL(return_result)
 
 /* Raise an exception from C */
 
-        .globl caml_raise_exception
-caml_raise_exception:
+        .globl G(caml_raise_exception)
+G(caml_raise_exception):
     /* Reload Caml allocation pointers */
-        ldr     r12, .Lcaml_young_ptr
+        ldr     r12, LBL(caml_young_ptr)
         ldr     alloc_ptr, [r12, #0]
-        ldr     r12, .Lcaml_young_limit
+        ldr     r12, LBL(caml_young_limit)
         ldr     alloc_limit, [r12, #0]
     /* Cut stack at current trap handler */
-        ldr     r12, .Lcaml_exception_pointer
+        ldr     r12, LBL(caml_exception_pointer)
         ldr     sp, [r12, #0]
     /* Pop previous handler and addr of trap, and jump to it */
         ldmfd   sp!, {trap_ptr, pc}
 
 /* Callback from C to Caml */
 
-        .globl caml_callback_exn
-caml_callback_exn:
+        .globl G(caml_callback_exn)
+G(caml_callback_exn):
     /* Initial shuffling of arguments (r0 = closure, r1 = first arg) */
         mov     r12, r0
         mov     r0, r1            /* r0 = first arg */
         mov     r1, r12           /* r1 = closure environment */
         ldr     r12, [r12, #0]    /* code pointer */
-        b       .Ljump_to_caml
+        b       LBL(jump_to_caml)
 
-        .globl caml_callback2_exn
-caml_callback2_exn:
+        .globl G(caml_callback2_exn)
+G(caml_callback2_exn):
     /* Initial shuffling of arguments (r0 = closure, r1 = arg1, r2 = arg2) */
         mov     r12, r0
         mov     r0, r1           /* r0 = first arg */
         mov     r1, r2           /* r1 = second arg */
         mov     r2, r12          /* r2 = closure environment */
-        ldr     r12, .Lcaml_apply2
-        b       .Ljump_to_caml
+        ldr     r12, LBL(caml_apply2)
+        b       LBL(jump_to_caml)
 
-        .globl caml_callback3_exn
-caml_callback3_exn:
+        .globl G(caml_callback3_exn)
+G(caml_callback3_exn):
     /* Initial shuffling of arguments */
     /* (r0 = closure, r1 = arg1, r2 = arg2, r3 = arg3) */
         mov     r12, r0
@@ -277,42 +296,42 @@
         mov     r1, r2          /* r1 = second arg */
         mov     r2, r3          /* r2 = third arg */
         mov     r3, r12         /* r3 = closure environment */
-        ldr     r12, .Lcaml_apply3
-        b       .Ljump_to_caml
+        ldr     r12, LBL(caml_apply3)
+        b       LBL(jump_to_caml)
 
-        .globl caml_ml_array_bound_error
-caml_ml_array_bound_error:
+        .globl G(caml_ml_array_bound_error)
+G(caml_ml_array_bound_error):
     /* Load address of [caml_array_bound_error] in r12 */
-        ldr     r12, .Lcaml_array_bound_error
+        ldr     r12, LBL(caml_array_bound_error)
     /* Call that function */
-        b       caml_c_call
+        b       G(caml_c_call)
 
 /* Global references */
 
-.Lcaml_last_return_address:     .word caml_last_return_address
-.Lcaml_bottom_of_stack:         .word caml_bottom_of_stack
-.Lcaml_gc_regs:                 .word caml_gc_regs
-.Lcaml_young_ptr:               .word caml_young_ptr
-.Lcaml_young_limit:             .word caml_young_limit
-.Lcaml_exception_pointer:       .word caml_exception_pointer
-.Lcaml_program:                 .word caml_program
-.LLtrap_handler:                .word .Ltrap_handler
-.Lcaml_apply2:                  .word caml_apply2
-.Lcaml_apply3:                  .word caml_apply3
-.Lcaml_array_bound_error:       .word caml_array_bound_error
-.Lcaml_requested_size:          .word caml_requested_size
+LBL(caml_last_return_address):     .word G(caml_last_return_address)
+LBL(caml_bottom_of_stack):         .word G(caml_bottom_of_stack)
+LBL(caml_gc_regs):                 .word G(caml_gc_regs)
+LBL(caml_young_ptr):               .word G(caml_young_ptr)
+LBL(caml_young_limit):             .word G(caml_young_limit)
+LBL(caml_exception_pointer):       .word G(caml_exception_pointer)
+LBL(caml_program):                 .word G(caml_program)
+LBL(Ltrap_handler):                .word LBL(trap_handler)
+LBL(caml_apply2):                  .word G(caml_apply2)
+LBL(caml_apply3):                  .word G(caml_apply3)
+LBL(caml_array_bound_error):       .word G(caml_array_bound_error)
+LBL(caml_requested_size):          .word G(caml_requested_size)
 
 	.data
-caml_requested_size:
+G(caml_requested_size):
 	.word	0
 
 /* GC roots for callback */
 
         .data
-        .globl caml_system__frametable
-caml_system__frametable:
+        .globl G(caml_system__frametable)
+G(caml_system__frametable):
         .word   1               /* one descriptor */
-        .word   .Lcaml_retaddr  /* return address into callback */
+        .word   LBL(caml_retaddr)  /* return address into callback */
         .short  -1              /* negative frame size => use callback link */
         .short  0               /* no roots */
         .align  2
diff -urN ocaml-3.12.0.orig/config/auto-aux/cross_compile_conf.arm-apple-darwin10 ocaml-3.12.0/config/auto-aux/cross_compile_conf.arm-apple-darwin10
--- ocaml-3.12.0.orig/config/auto-aux/cross_compile_conf.arm-apple-darwin10	1970-01-01 09:00:00.000000000 +0900
+++ ocaml-3.12.0/config/auto-aux/cross_compile_conf.arm-apple-darwin10	2010-09-11 03:35:07.000000000 +0900
@@ -0,0 +1,20 @@
+#!/bin/sh
+
+case "$1" in
+  ansi.c)
+	exit 0;;
+  sizes.c)
+	echo "4 4 4 2";;
+  longlong.c)
+	exit 0;;
+  endian.c)
+	exit 1;;
+  dblalign.c)
+	exit 0;;
+  int64align.c)
+	exit 0;;
+  divmod.c)
+	exit 0;;
+  *)
+	exit 100;;
+esac
diff -urN ocaml-3.12.0.orig/configure ocaml-3.12.0/configure
--- ocaml-3.12.0.orig/configure	2010-07-28 22:18:22.000000000 +0900
+++ ocaml-3.12.0/configure	2010-09-11 03:35:07.000000000 +0900
@@ -685,6 +697,7 @@
                                 if $arch64; then model=ppc64; else model=ppc; fi;;
   arm*-*-linux*)                arch=arm; system=linux;;
   arm*-*-gnu*)                  arch=arm; system=gnu;;
+  arm*-*-darwin*)               arch=arm; system=macosx;;
   ia64-*-linux*)                arch=ia64; system=linux;;
   ia64-*-gnu*)                  arch=ia64; system=gnu;;
   ia64-*-freebsd*)              arch=ia64; system=freebsd;;

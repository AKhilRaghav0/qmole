/*
 * Generated by gdbus-codegen 2.29.14. DO NOT EDIT.
 *
 * The license of this code is the same as for the source it was derived from.
 */

#ifdef HAVE_CONFIG_H
#  include "config.h"
#endif

#include "gdbus-test-codegen-generated.h"

#ifdef G_OS_UNIX
#  include <gio/gunixfdlist.h>
#endif

typedef struct
{
  GDBusArgInfo parent_struct;
  gboolean use_gvariant;
} _ExtendedGDBusArgInfo;

typedef struct
{
  GDBusMethodInfo parent_struct;
  const gchar *signal_name;
  gboolean pass_fdlist;
} _ExtendedGDBusMethodInfo;

typedef struct
{
  GDBusSignalInfo parent_struct;
  const gchar *signal_name;
} _ExtendedGDBusSignalInfo;

typedef struct
{
  GDBusPropertyInfo parent_struct;
  const gchar *hyphen_name;
  gboolean use_gvariant;
} _ExtendedGDBusPropertyInfo;

typedef struct
{
  GDBusInterfaceInfo parent_struct;
  const gchar *hyphen_name;
} _ExtendedGDBusInterfaceInfo;

typedef struct
{
  const _ExtendedGDBusPropertyInfo *info;
  guint prop_id;
  GValue orig_value; /* the value before the change */
} ChangedProperty;

static void
_changed_property_free (ChangedProperty *data)
{
  g_value_unset (&data->orig_value);
  g_free (data);
}

static gboolean
_g_strv_equal0 (gchar **a, gchar **b)
{
  gboolean ret = FALSE;
  guint n;
  if (a == NULL && b == NULL)
    {
      ret = TRUE;
      goto out;
    }
  if (a == NULL || b == NULL)
    goto out;
  if (g_strv_length (a) != g_strv_length (b))
    goto out;
  for (n = 0; a[n] != NULL; n++)
    if (g_strcmp0 (a[n], b[n]) != 0)
      goto out;
  ret = TRUE;
out:
  return ret;
}

static gboolean
_g_variant_equal0 (GVariant *a, GVariant *b)
{
  gboolean ret = FALSE;
  if (a == NULL && b == NULL)
    {
      ret = TRUE;
      goto out;
    }
  if (a == NULL || b == NULL)
    goto out;
  ret = g_variant_equal (a, b);
out:
  return ret;
}

G_GNUC_UNUSED static gboolean
_g_value_equal (const GValue *a, const GValue *b)
{
  gboolean ret = FALSE;
  g_assert (G_VALUE_TYPE (a) == G_VALUE_TYPE (b));
  switch (G_VALUE_TYPE (a))
    {
      case G_TYPE_BOOLEAN:
        ret = (g_value_get_boolean (a) == g_value_get_boolean (b));
        break;
      case G_TYPE_UCHAR:
        ret = (g_value_get_uchar (a) == g_value_get_uchar (b));
        break;
      case G_TYPE_INT:
        ret = (g_value_get_int (a) == g_value_get_int (b));
        break;
      case G_TYPE_UINT:
        ret = (g_value_get_uint (a) == g_value_get_uint (b));
        break;
      case G_TYPE_INT64:
        ret = (g_value_get_int64 (a) == g_value_get_int64 (b));
        break;
      case G_TYPE_UINT64:
        ret = (g_value_get_uint64 (a) == g_value_get_uint64 (b));
        break;
      case G_TYPE_DOUBLE:
        ret = (g_value_get_double (a) == g_value_get_double (b));
        break;
      case G_TYPE_STRING:
        ret = (g_strcmp0 (g_value_get_string (a), g_value_get_string (b)) == 0);
        break;
      case G_TYPE_VARIANT:
        ret = _g_variant_equal0 (g_value_get_variant (a), g_value_get_variant (b));
        break;
      default:
        if (G_VALUE_TYPE (a) == G_TYPE_STRV)
          ret = _g_strv_equal0 (g_value_get_boxed (a), g_value_get_boxed (b));
        else
          g_critical ("_g_value_equal() does not handle type %s", g_type_name (G_VALUE_TYPE (a)));
        break;
    }
  return ret;
}

/* ------------------------------------------------------------------------
 * Code for interface org.project.Bar
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooBar
 * @title: FooBar
 * @short_description: Generated C code for the org.project.Bar D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.project.Bar ---- */

static const _ExtendedGDBusArgInfo _foo_bar_method_info_hello_world_IN_ARG_greeting =
{
  {
    -1,
    "greeting",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_bar_method_info_hello_world_IN_ARG_pointers[] =
{
  &_foo_bar_method_info_hello_world_IN_ARG_greeting,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_hello_world_OUT_ARG_response =
{
  {
    -1,
    "response",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_bar_method_info_hello_world_OUT_ARG_pointers[] =
{
  &_foo_bar_method_info_hello_world_OUT_ARG_response,
  NULL
};

static const GDBusAnnotationInfo _foo_bar_method_hello_world_annotation_info_0 =
{
  -1,
  "Key3",
  "Value3",
  NULL
};

static const GDBusAnnotationInfo _foo_bar_method_hello_world_annotation_info_1 =
{
  -1,
  "ExistingAnnotation",
  "blah",
  NULL
};

static const GDBusAnnotationInfo * const _foo_bar_method_hello_world_annotation_info_pointers[] =
{
  &_foo_bar_method_hello_world_annotation_info_0,
  &_foo_bar_method_hello_world_annotation_info_1,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_bar_method_info_hello_world =
{
  {
    -1,
    "HelloWorld",
    (GDBusArgInfo **) &_foo_bar_method_info_hello_world_IN_ARG_pointers,
    (GDBusArgInfo **) &_foo_bar_method_info_hello_world_OUT_ARG_pointers,
    (GDBusAnnotationInfo **) &_foo_bar_method_hello_world_annotation_info_pointers
  },
  "handle-hello-world",
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_primitive_types_IN_ARG_val_byte =
{
  {
    -1,
    "val_byte",
    "y",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_primitive_types_IN_ARG_val_boolean =
{
  {
    -1,
    "val_boolean",
    "b",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_primitive_types_IN_ARG_val_int16 =
{
  {
    -1,
    "val_int16",
    "n",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_primitive_types_IN_ARG_val_uint16 =
{
  {
    -1,
    "val_uint16",
    "q",
    NULL
  },
  FALSE
};

static const GDBusAnnotationInfo _foo_bar_method_info_test_primitive_types_IN_ARG_arg_val_int32_annotation_info_0 =
{
  -1,
  "Key6",
  "Value6",
  NULL
};

static const GDBusAnnotationInfo * const _foo_bar_method_info_test_primitive_types_IN_ARG_arg_val_int32_annotation_info_pointers[] =
{
  &_foo_bar_method_info_test_primitive_types_IN_ARG_arg_val_int32_annotation_info_0,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_primitive_types_IN_ARG_val_int32 =
{
  {
    -1,
    "val_int32",
    "i",
    (GDBusAnnotationInfo **) &_foo_bar_method_info_test_primitive_types_IN_ARG_arg_val_int32_annotation_info_pointers
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_primitive_types_IN_ARG_val_uint32 =
{
  {
    -1,
    "val_uint32",
    "u",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_primitive_types_IN_ARG_val_int64 =
{
  {
    -1,
    "val_int64",
    "x",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_primitive_types_IN_ARG_val_uint64 =
{
  {
    -1,
    "val_uint64",
    "t",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_primitive_types_IN_ARG_val_double =
{
  {
    -1,
    "val_double",
    "d",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_primitive_types_IN_ARG_val_string =
{
  {
    -1,
    "val_string",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_primitive_types_IN_ARG_val_objpath =
{
  {
    -1,
    "val_objpath",
    "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_primitive_types_IN_ARG_val_signature =
{
  {
    -1,
    "val_signature",
    "g",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_primitive_types_IN_ARG_val_bytestring =
{
  {
    -1,
    "val_bytestring",
    "ay",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_bar_method_info_test_primitive_types_IN_ARG_pointers[] =
{
  &_foo_bar_method_info_test_primitive_types_IN_ARG_val_byte,
  &_foo_bar_method_info_test_primitive_types_IN_ARG_val_boolean,
  &_foo_bar_method_info_test_primitive_types_IN_ARG_val_int16,
  &_foo_bar_method_info_test_primitive_types_IN_ARG_val_uint16,
  &_foo_bar_method_info_test_primitive_types_IN_ARG_val_int32,
  &_foo_bar_method_info_test_primitive_types_IN_ARG_val_uint32,
  &_foo_bar_method_info_test_primitive_types_IN_ARG_val_int64,
  &_foo_bar_method_info_test_primitive_types_IN_ARG_val_uint64,
  &_foo_bar_method_info_test_primitive_types_IN_ARG_val_double,
  &_foo_bar_method_info_test_primitive_types_IN_ARG_val_string,
  &_foo_bar_method_info_test_primitive_types_IN_ARG_val_objpath,
  &_foo_bar_method_info_test_primitive_types_IN_ARG_val_signature,
  &_foo_bar_method_info_test_primitive_types_IN_ARG_val_bytestring,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_primitive_types_OUT_ARG_ret_byte =
{
  {
    -1,
    "ret_byte",
    "y",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_primitive_types_OUT_ARG_ret_boolean =
{
  {
    -1,
    "ret_boolean",
    "b",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_primitive_types_OUT_ARG_ret_int16 =
{
  {
    -1,
    "ret_int16",
    "n",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_primitive_types_OUT_ARG_ret_uint16 =
{
  {
    -1,
    "ret_uint16",
    "q",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_primitive_types_OUT_ARG_ret_int32 =
{
  {
    -1,
    "ret_int32",
    "i",
    NULL
  },
  FALSE
};

static const GDBusAnnotationInfo _foo_bar_method_info_test_primitive_types_OUT_ARG_arg_ret_uint32_annotation_info_0 =
{
  -1,
  "Key7",
  "Value7",
  NULL
};

static const GDBusAnnotationInfo * const _foo_bar_method_info_test_primitive_types_OUT_ARG_arg_ret_uint32_annotation_info_pointers[] =
{
  &_foo_bar_method_info_test_primitive_types_OUT_ARG_arg_ret_uint32_annotation_info_0,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_primitive_types_OUT_ARG_ret_uint32 =
{
  {
    -1,
    "ret_uint32",
    "u",
    (GDBusAnnotationInfo **) &_foo_bar_method_info_test_primitive_types_OUT_ARG_arg_ret_uint32_annotation_info_pointers
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_primitive_types_OUT_ARG_ret_int64 =
{
  {
    -1,
    "ret_int64",
    "x",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_primitive_types_OUT_ARG_ret_uint64 =
{
  {
    -1,
    "ret_uint64",
    "t",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_primitive_types_OUT_ARG_ret_double =
{
  {
    -1,
    "ret_double",
    "d",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_primitive_types_OUT_ARG_ret_string =
{
  {
    -1,
    "ret_string",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_primitive_types_OUT_ARG_ret_objpath =
{
  {
    -1,
    "ret_objpath",
    "o",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_primitive_types_OUT_ARG_ret_signature =
{
  {
    -1,
    "ret_signature",
    "g",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_primitive_types_OUT_ARG_ret_bytestring =
{
  {
    -1,
    "ret_bytestring",
    "ay",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_bar_method_info_test_primitive_types_OUT_ARG_pointers[] =
{
  &_foo_bar_method_info_test_primitive_types_OUT_ARG_ret_byte,
  &_foo_bar_method_info_test_primitive_types_OUT_ARG_ret_boolean,
  &_foo_bar_method_info_test_primitive_types_OUT_ARG_ret_int16,
  &_foo_bar_method_info_test_primitive_types_OUT_ARG_ret_uint16,
  &_foo_bar_method_info_test_primitive_types_OUT_ARG_ret_int32,
  &_foo_bar_method_info_test_primitive_types_OUT_ARG_ret_uint32,
  &_foo_bar_method_info_test_primitive_types_OUT_ARG_ret_int64,
  &_foo_bar_method_info_test_primitive_types_OUT_ARG_ret_uint64,
  &_foo_bar_method_info_test_primitive_types_OUT_ARG_ret_double,
  &_foo_bar_method_info_test_primitive_types_OUT_ARG_ret_string,
  &_foo_bar_method_info_test_primitive_types_OUT_ARG_ret_objpath,
  &_foo_bar_method_info_test_primitive_types_OUT_ARG_ret_signature,
  &_foo_bar_method_info_test_primitive_types_OUT_ARG_ret_bytestring,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_bar_method_info_test_primitive_types =
{
  {
    -1,
    "TestPrimitiveTypes",
    (GDBusArgInfo **) &_foo_bar_method_info_test_primitive_types_IN_ARG_pointers,
    (GDBusArgInfo **) &_foo_bar_method_info_test_primitive_types_OUT_ARG_pointers,
    NULL
  },
  "handle-test-primitive-types",
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_non_primitive_types_IN_ARG_dict_s_to_s =
{
  {
    -1,
    "dict_s_to_s",
    "a{ss}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_non_primitive_types_IN_ARG_dict_s_to_pairs =
{
  {
    -1,
    "dict_s_to_pairs",
    "a{s(ii)}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_non_primitive_types_IN_ARG_a_struct =
{
  {
    -1,
    "a_struct",
    "(iss)",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_non_primitive_types_IN_ARG_array_of_strings =
{
  {
    -1,
    "array_of_strings",
    "as",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_non_primitive_types_IN_ARG_array_of_objpaths =
{
  {
    -1,
    "array_of_objpaths",
    "ao",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_non_primitive_types_IN_ARG_array_of_signatures =
{
  {
    -1,
    "array_of_signatures",
    "ag",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_non_primitive_types_IN_ARG_array_of_bytestrings =
{
  {
    -1,
    "array_of_bytestrings",
    "aay",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_bar_method_info_test_non_primitive_types_IN_ARG_pointers[] =
{
  &_foo_bar_method_info_test_non_primitive_types_IN_ARG_dict_s_to_s,
  &_foo_bar_method_info_test_non_primitive_types_IN_ARG_dict_s_to_pairs,
  &_foo_bar_method_info_test_non_primitive_types_IN_ARG_a_struct,
  &_foo_bar_method_info_test_non_primitive_types_IN_ARG_array_of_strings,
  &_foo_bar_method_info_test_non_primitive_types_IN_ARG_array_of_objpaths,
  &_foo_bar_method_info_test_non_primitive_types_IN_ARG_array_of_signatures,
  &_foo_bar_method_info_test_non_primitive_types_IN_ARG_array_of_bytestrings,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_test_non_primitive_types_OUT_ARG_result =
{
  {
    -1,
    "result",
    "ay",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_bar_method_info_test_non_primitive_types_OUT_ARG_pointers[] =
{
  &_foo_bar_method_info_test_non_primitive_types_OUT_ARG_result,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_bar_method_info_test_non_primitive_types =
{
  {
    -1,
    "TestNonPrimitiveTypes",
    (GDBusArgInfo **) &_foo_bar_method_info_test_non_primitive_types_IN_ARG_pointers,
    (GDBusArgInfo **) &_foo_bar_method_info_test_non_primitive_types_OUT_ARG_pointers,
    NULL
  },
  "handle-test-non-primitive-types",
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_method_info_request_signal_emission_IN_ARG_which_one =
{
  {
    -1,
    "which_one",
    "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_bar_method_info_request_signal_emission_IN_ARG_pointers[] =
{
  &_foo_bar_method_info_request_signal_emission_IN_ARG_which_one,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_bar_method_info_request_signal_emission =
{
  {
    -1,
    "RequestSignalEmission",
    (GDBusArgInfo **) &_foo_bar_method_info_request_signal_emission_IN_ARG_pointers,
    NULL,
    NULL
  },
  "handle-request-signal-emission",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_bar_method_info_request_multi_property_mods =
{
  {
    -1,
    "RequestMultiPropertyMods",
    NULL,
    NULL,
    NULL
  },
  "handle-request-multi-property-mods",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_bar_method_info_unimplemented_method =
{
  {
    -1,
    "UnimplementedMethod",
    NULL,
    NULL,
    NULL
  },
  "handle-unimplemented-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_bar_method_info_property_cancellation =
{
  {
    -1,
    "PropertyCancellation",
    NULL,
    NULL,
    NULL
  },
  "handle-property-cancellation",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_bar_method_info_pointers[] =
{
  &_foo_bar_method_info_hello_world,
  &_foo_bar_method_info_test_primitive_types,
  &_foo_bar_method_info_test_non_primitive_types,
  &_foo_bar_method_info_request_signal_emission,
  &_foo_bar_method_info_request_multi_property_mods,
  &_foo_bar_method_info_unimplemented_method,
  &_foo_bar_method_info_property_cancellation,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_bar_signal_info_test_signal_ARG_val_int32 =
{
  {
    -1,
    "val_int32",
    "i",
    NULL
  },
  FALSE
};

static const GDBusAnnotationInfo _foo_bar_signal_info_test_signal_ARG_arg_array_of_strings_annotation_info_0 =
{
  -1,
  "Key8",
  "Value8",
  NULL
};

static const GDBusAnnotationInfo * const _foo_bar_signal_info_test_signal_ARG_arg_array_of_strings_annotation_info_pointers[] =
{
  &_foo_bar_signal_info_test_signal_ARG_arg_array_of_strings_annotation_info_0,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_bar_signal_info_test_signal_ARG_array_of_strings =
{
  {
    -1,
    "array_of_strings",
    "as",
    (GDBusAnnotationInfo **) &_foo_bar_signal_info_test_signal_ARG_arg_array_of_strings_annotation_info_pointers
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_signal_info_test_signal_ARG_array_of_bytestrings =
{
  {
    -1,
    "array_of_bytestrings",
    "aay",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_bar_signal_info_test_signal_ARG_dict_s_to_pairs =
{
  {
    -1,
    "dict_s_to_pairs",
    "a{s(ii)}",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_bar_signal_info_test_signal_ARG_pointers[] =
{
  &_foo_bar_signal_info_test_signal_ARG_val_int32,
  &_foo_bar_signal_info_test_signal_ARG_array_of_strings,
  &_foo_bar_signal_info_test_signal_ARG_array_of_bytestrings,
  &_foo_bar_signal_info_test_signal_ARG_dict_s_to_pairs,
  NULL
};

static const GDBusAnnotationInfo _foo_bar_signal_test_signal_annotation_info_0 =
{
  -1,
  "Key4",
  "Value4",
  NULL
};

static const GDBusAnnotationInfo * const _foo_bar_signal_test_signal_annotation_info_pointers[] =
{
  &_foo_bar_signal_test_signal_annotation_info_0,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_bar_signal_info_test_signal =
{
  {
    -1,
    "TestSignal",
    (GDBusArgInfo **) &_foo_bar_signal_info_test_signal_ARG_pointers,
    (GDBusAnnotationInfo **) &_foo_bar_signal_test_signal_annotation_info_pointers
  },
  "test-signal"
};

static const _ExtendedGDBusArgInfo _foo_bar_signal_info_another_signal_ARG_word =
{
  {
    -1,
    "word",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_bar_signal_info_another_signal_ARG_pointers[] =
{
  &_foo_bar_signal_info_another_signal_ARG_word,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_bar_signal_info_another_signal =
{
  {
    -1,
    "AnotherSignal",
    (GDBusArgInfo **) &_foo_bar_signal_info_another_signal_ARG_pointers,
    NULL
  },
  "another-signal"
};

static const _ExtendedGDBusSignalInfo * const _foo_bar_signal_info_pointers[] =
{
  &_foo_bar_signal_info_test_signal,
  &_foo_bar_signal_info_another_signal,
  NULL
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_y =
{
  {
    -1,
    "y",
    "y",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "y",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_b =
{
  {
    -1,
    "b",
    "b",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "b",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_n =
{
  {
    -1,
    "n",
    "n",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "n",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_q =
{
  {
    -1,
    "q",
    "q",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "q",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_i =
{
  {
    -1,
    "i",
    "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "i",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_u =
{
  {
    -1,
    "u",
    "u",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "u",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_x =
{
  {
    -1,
    "x",
    "x",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "x",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_t =
{
  {
    -1,
    "t",
    "t",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "t",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_d =
{
  {
    -1,
    "d",
    "d",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "d",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_s =
{
  {
    -1,
    "s",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "s",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_o =
{
  {
    -1,
    "o",
    "o",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "o",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_g =
{
  {
    -1,
    "g",
    "g",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "g",
  FALSE
};

static const GDBusAnnotationInfo _foo_bar_property_ay_annotation_info_0 =
{
  -1,
  "Key5",
  "Value5",
  NULL
};

static const GDBusAnnotationInfo * const _foo_bar_property_ay_annotation_info_pointers[] =
{
  &_foo_bar_property_ay_annotation_info_0,
  NULL
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_ay =
{
  {
    -1,
    "ay",
    "ay",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    (GDBusAnnotationInfo **) &_foo_bar_property_ay_annotation_info_pointers
  },
  "ay",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_as =
{
  {
    -1,
    "as",
    "as",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "as",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_aay =
{
  {
    -1,
    "aay",
    "aay",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "aay",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_ao =
{
  {
    -1,
    "ao",
    "ao",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "ao",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_ag =
{
  {
    -1,
    "ag",
    "ag",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "ag",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_finally_normal_name =
{
  {
    -1,
    "FinallyNormalName",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "finally-normal-name",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_readonly_property =
{
  {
    -1,
    "ReadonlyProperty",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "readonly-property",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_writeonly_property =
{
  {
    -1,
    "WriteonlyProperty",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "writeonly-property",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_unset_i =
{
  {
    -1,
    "unset_i",
    "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-i",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_unset_d =
{
  {
    -1,
    "unset_d",
    "d",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-d",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_unset_s =
{
  {
    -1,
    "unset_s",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-s",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_unset_o =
{
  {
    -1,
    "unset_o",
    "o",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-o",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_unset_g =
{
  {
    -1,
    "unset_g",
    "g",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-g",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_unset_ay =
{
  {
    -1,
    "unset_ay",
    "ay",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-ay",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_unset_as =
{
  {
    -1,
    "unset_as",
    "as",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-as",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_unset_ao =
{
  {
    -1,
    "unset_ao",
    "ao",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-ao",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_unset_ag =
{
  {
    -1,
    "unset_ag",
    "ag",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-ag",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_bar_property_info_unset_struct =
{
  {
    -1,
    "unset_struct",
    "(idsogayasaoag)",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "unset-struct",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _foo_bar_property_info_pointers[] =
{
  &_foo_bar_property_info_y,
  &_foo_bar_property_info_b,
  &_foo_bar_property_info_n,
  &_foo_bar_property_info_q,
  &_foo_bar_property_info_i,
  &_foo_bar_property_info_u,
  &_foo_bar_property_info_x,
  &_foo_bar_property_info_t,
  &_foo_bar_property_info_d,
  &_foo_bar_property_info_s,
  &_foo_bar_property_info_o,
  &_foo_bar_property_info_g,
  &_foo_bar_property_info_ay,
  &_foo_bar_property_info_as,
  &_foo_bar_property_info_aay,
  &_foo_bar_property_info_ao,
  &_foo_bar_property_info_ag,
  &_foo_bar_property_info_finally_normal_name,
  &_foo_bar_property_info_readonly_property,
  &_foo_bar_property_info_writeonly_property,
  &_foo_bar_property_info_unset_i,
  &_foo_bar_property_info_unset_d,
  &_foo_bar_property_info_unset_s,
  &_foo_bar_property_info_unset_o,
  &_foo_bar_property_info_unset_g,
  &_foo_bar_property_info_unset_ay,
  &_foo_bar_property_info_unset_as,
  &_foo_bar_property_info_unset_ao,
  &_foo_bar_property_info_unset_ag,
  &_foo_bar_property_info_unset_struct,
  NULL
};

static const GDBusAnnotationInfo _foo_bar_annotation_info_0 =
{
  -1,
  "Key1",
  "Value1",
  NULL
};

static const GDBusAnnotationInfo * const _foo_bar_annotation_info_pointers[] =
{
  &_foo_bar_annotation_info_0,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_bar_interface_info =
{
  {
    -1,
    "org.project.Bar",
    (GDBusMethodInfo **) &_foo_bar_method_info_pointers,
    (GDBusSignalInfo **) &_foo_bar_signal_info_pointers,
    (GDBusPropertyInfo **) &_foo_bar_property_info_pointers,
    (GDBusAnnotationInfo **) &_foo_bar_annotation_info_pointers
  },
  "bar",
};


/**
 * foo_bar_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_bar_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_bar_interface_info;
}

/**
 * foo_bar_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooBar interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_bar_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "y");
  g_object_class_override_property (klass, property_id_begin++, "b");
  g_object_class_override_property (klass, property_id_begin++, "n");
  g_object_class_override_property (klass, property_id_begin++, "q");
  g_object_class_override_property (klass, property_id_begin++, "i");
  g_object_class_override_property (klass, property_id_begin++, "u");
  g_object_class_override_property (klass, property_id_begin++, "x");
  g_object_class_override_property (klass, property_id_begin++, "t");
  g_object_class_override_property (klass, property_id_begin++, "d");
  g_object_class_override_property (klass, property_id_begin++, "s");
  g_object_class_override_property (klass, property_id_begin++, "o");
  g_object_class_override_property (klass, property_id_begin++, "g");
  g_object_class_override_property (klass, property_id_begin++, "ay");
  g_object_class_override_property (klass, property_id_begin++, "as");
  g_object_class_override_property (klass, property_id_begin++, "aay");
  g_object_class_override_property (klass, property_id_begin++, "ao");
  g_object_class_override_property (klass, property_id_begin++, "ag");
  g_object_class_override_property (klass, property_id_begin++, "finally-normal-name");
  g_object_class_override_property (klass, property_id_begin++, "readonly-property");
  g_object_class_override_property (klass, property_id_begin++, "writeonly-property");
  g_object_class_override_property (klass, property_id_begin++, "unset-i");
  g_object_class_override_property (klass, property_id_begin++, "unset-d");
  g_object_class_override_property (klass, property_id_begin++, "unset-s");
  g_object_class_override_property (klass, property_id_begin++, "unset-o");
  g_object_class_override_property (klass, property_id_begin++, "unset-g");
  g_object_class_override_property (klass, property_id_begin++, "unset-ay");
  g_object_class_override_property (klass, property_id_begin++, "unset-as");
  g_object_class_override_property (klass, property_id_begin++, "unset-ao");
  g_object_class_override_property (klass, property_id_begin++, "unset-ag");
  g_object_class_override_property (klass, property_id_begin++, "unset-struct");
  return property_id_begin - 1;
}



/**
 * FooBar:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link>.
 */

/**
 * FooBarIface:
 * @parent_iface: The parent interface.
 * @handle_hello_world: Handler for the #FooBar::handle-hello-world signal.
 * @handle_property_cancellation: Handler for the #FooBar::handle-property-cancellation signal.
 * @handle_request_multi_property_mods: Handler for the #FooBar::handle-request-multi-property-mods signal.
 * @handle_request_signal_emission: Handler for the #FooBar::handle-request-signal-emission signal.
 * @handle_test_non_primitive_types: Handler for the #FooBar::handle-test-non-primitive-types signal.
 * @handle_test_primitive_types: Handler for the #FooBar::handle-test-primitive-types signal.
 * @handle_unimplemented_method: Handler for the #FooBar::handle-unimplemented-method signal.
 * @another_signal: Handler for the #FooBar::another-signal signal.
 * @test_signal: Handler for the #FooBar::test-signal signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link>.
 */

static void
foo_bar_default_init (FooBarIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooBar::handle-hello-world:
   * @object: A #FooBar.
   * @invocation: A #GDBusMethodInvocation.
   * @greeting: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bar.HelloWorld">HelloWorld()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_bar_complete_hello_world() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-hello-world",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooBarIface, handle_hello_world),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /**
   * FooBar::handle-test-primitive-types:
   * @object: A #FooBar.
   * @invocation: A #GDBusMethodInvocation.
   * @val_byte: Argument passed by remote caller.
   * @val_boolean: Argument passed by remote caller.
   * @val_int16: Argument passed by remote caller.
   * @val_uint16: Argument passed by remote caller.
   * @val_int32: Argument passed by remote caller.
   * @val_uint32: Argument passed by remote caller.
   * @val_int64: Argument passed by remote caller.
   * @val_uint64: Argument passed by remote caller.
   * @val_double: Argument passed by remote caller.
   * @val_string: Argument passed by remote caller.
   * @val_objpath: Argument passed by remote caller.
   * @val_signature: Argument passed by remote caller.
   * @val_bytestring: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bar.TestPrimitiveTypes">TestPrimitiveTypes()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_bar_complete_test_primitive_types() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-test-primitive-types",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooBarIface, handle_test_primitive_types),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    14,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_UCHAR, G_TYPE_BOOLEAN, G_TYPE_INT, G_TYPE_UINT, G_TYPE_INT, G_TYPE_UINT, G_TYPE_INT64, G_TYPE_UINT64, G_TYPE_DOUBLE, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);

  /**
   * FooBar::handle-test-non-primitive-types:
   * @object: A #FooBar.
   * @invocation: A #GDBusMethodInvocation.
   * @dict_s_to_s: Argument passed by remote caller.
   * @dict_s_to_pairs: Argument passed by remote caller.
   * @a_struct: Argument passed by remote caller.
   * @array_of_strings: Argument passed by remote caller.
   * @array_of_objpaths: Argument passed by remote caller.
   * @array_of_signatures: Argument passed by remote caller.
   * @array_of_bytestrings: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bar.TestNonPrimitiveTypes">TestNonPrimitiveTypes()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_bar_complete_test_non_primitive_types() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-test-non-primitive-types",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooBarIface, handle_test_non_primitive_types),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    8,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_VARIANT, G_TYPE_VARIANT, G_TYPE_VARIANT, G_TYPE_STRV, G_TYPE_STRV, G_TYPE_VARIANT, G_TYPE_STRV);

  /**
   * FooBar::handle-request-signal-emission:
   * @object: A #FooBar.
   * @invocation: A #GDBusMethodInvocation.
   * @which_one: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bar.RequestSignalEmission">RequestSignalEmission()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_bar_complete_request_signal_emission() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-request-signal-emission",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooBarIface, handle_request_signal_emission),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_INT);

  /**
   * FooBar::handle-request-multi-property-mods:
   * @object: A #FooBar.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bar.RequestMultiPropertyMods">RequestMultiPropertyMods()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_bar_complete_request_multi_property_mods() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-request-multi-property-mods",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooBarIface, handle_request_multi_property_mods),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooBar::handle-unimplemented-method:
   * @object: A #FooBar.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bar.UnimplementedMethod">UnimplementedMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_bar_complete_unimplemented_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-unimplemented-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooBarIface, handle_unimplemented_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooBar::handle-property-cancellation:
   * @object: A #FooBar.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bar.PropertyCancellation">PropertyCancellation()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_bar_complete_property_cancellation() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-property-cancellation",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooBarIface, handle_property_cancellation),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooBar::test-signal:
   * @object: A #FooBar.
   * @val_int32: Argument.
   * @array_of_strings: Argument.
   * @array_of_bytestrings: Argument.
   * @dict_s_to_pairs: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-project-Bar.TestSignal">"TestSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("test-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooBarIface, test_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    4, G_TYPE_INT, G_TYPE_STRV, G_TYPE_STRV, G_TYPE_VARIANT);

  /**
   * FooBar::another-signal:
   * @object: A #FooBar.
   * @word: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-project-Bar.AnotherSignal">"AnotherSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("another-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooBarIface, another_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    1, G_TYPE_STRING);

  /* GObject properties for D-Bus properties: */
  /**
   * FooBar:y:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.y">"y"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_uchar ("y", "y", "y", 0, 255, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:b:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.b">"b"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boolean ("b", "b", "b", FALSE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:n:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.n">"n"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("n", "n", "n", G_MININT16, G_MAXINT16, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:q:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.q">"q"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_uint ("q", "q", "q", 0, G_MAXUINT16, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:i:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.i">"i"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("i", "i", "i", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:u:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.u">"u"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_uint ("u", "u", "u", 0, G_MAXUINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:x:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.x">"x"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int64 ("x", "x", "x", G_MININT64, G_MAXINT64, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:t:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.t">"t"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_uint64 ("t", "t", "t", 0, G_MAXUINT64, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:d:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.d">"d"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_double ("d", "d", "d", -G_MAXDOUBLE, G_MAXDOUBLE, 0.0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:s:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.s">"s"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("s", "s", "s", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:o:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.o">"o"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("o", "o", "o", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:g:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.g">"g"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("g", "g", "g", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:ay:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.ay">"ay"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("ay", "ay", "ay", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:as:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.as">"as"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boxed ("as", "as", "as", G_TYPE_STRV, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:aay:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.aay">"aay"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boxed ("aay", "aay", "aay", G_TYPE_STRV, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:ao:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.ao">"ao"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boxed ("ao", "ao", "ao", G_TYPE_STRV, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:ag:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.ag">"ag"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("ag", "ag", "ag", G_VARIANT_TYPE ("ag"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:finally-normal-name:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.FinallyNormalName">"FinallyNormalName"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("finally-normal-name", "FinallyNormalName", "FinallyNormalName", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:readonly-property:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.ReadonlyProperty">"ReadonlyProperty"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("readonly-property", "ReadonlyProperty", "ReadonlyProperty", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:writeonly-property:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.WriteonlyProperty">"WriteonlyProperty"</link>.
   *
   * Since the D-Bus property for this #GObject property is writable but not readable, it is meaningful to write to it on both the client- and service-side. It is only meaningful, however, to read from it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("writeonly-property", "WriteonlyProperty", "WriteonlyProperty", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:unset-i:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_i">"unset_i"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("unset-i", "unset_i", "unset_i", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:unset-d:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_d">"unset_d"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_double ("unset-d", "unset_d", "unset_d", -G_MAXDOUBLE, G_MAXDOUBLE, 0.0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:unset-s:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_s">"unset_s"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("unset-s", "unset_s", "unset_s", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:unset-o:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_o">"unset_o"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("unset-o", "unset_o", "unset_o", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:unset-g:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_g">"unset_g"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("unset-g", "unset_g", "unset_g", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:unset-ay:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_ay">"unset_ay"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("unset-ay", "unset_ay", "unset_ay", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:unset-as:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_as">"unset_as"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boxed ("unset-as", "unset_as", "unset_as", G_TYPE_STRV, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:unset-ao:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_ao">"unset_ao"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_boxed ("unset-ao", "unset_ao", "unset_ao", G_TYPE_STRV, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:unset-ag:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_ag">"unset_ag"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("unset-ag", "unset_ag", "unset_ag", G_VARIANT_TYPE ("ag"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBar:unset-struct:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bar.unset_struct">"unset_struct"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("unset-struct", "unset_struct", "unset_struct", G_VARIANT_TYPE ("(idsogayasaoag)"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

typedef FooBarIface FooBarInterface;
G_DEFINE_INTERFACE (FooBar, foo_bar, G_TYPE_OBJECT);

/**
 * foo_bar_get_y:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.y">"y"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
guchar 
foo_bar_get_y (FooBar *object)
{
  guchar value;
  g_object_get (G_OBJECT (object), "y", &value, NULL);
  return value;
}

/**
 * foo_bar_set_y:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.y">"y"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_y (FooBar *object, guchar value)
{
  g_object_set (G_OBJECT (object), "y", value, NULL);
}

/**
 * foo_bar_get_b:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.b">"b"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
gboolean 
foo_bar_get_b (FooBar *object)
{
  gboolean value;
  g_object_get (G_OBJECT (object), "b", &value, NULL);
  return value;
}

/**
 * foo_bar_set_b:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.b">"b"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_b (FooBar *object, gboolean value)
{
  g_object_set (G_OBJECT (object), "b", value, NULL);
}

/**
 * foo_bar_get_n:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.n">"n"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
gint16 
foo_bar_get_n (FooBar *object)
{
  gint value;
  g_object_get (G_OBJECT (object), "n", &value, NULL);
  return value;
}

/**
 * foo_bar_set_n:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.n">"n"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_n (FooBar *object, gint16 value)
{
  g_object_set (G_OBJECT (object), "n", value, NULL);
}

/**
 * foo_bar_get_q:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.q">"q"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
guint16 
foo_bar_get_q (FooBar *object)
{
  guint value;
  g_object_get (G_OBJECT (object), "q", &value, NULL);
  return value;
}

/**
 * foo_bar_set_q:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.q">"q"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_q (FooBar *object, guint16 value)
{
  g_object_set (G_OBJECT (object), "q", value, NULL);
}

/**
 * foo_bar_get_i:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.i">"i"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
gint 
foo_bar_get_i (FooBar *object)
{
  gint value;
  g_object_get (G_OBJECT (object), "i", &value, NULL);
  return value;
}

/**
 * foo_bar_set_i:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.i">"i"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_i (FooBar *object, gint value)
{
  g_object_set (G_OBJECT (object), "i", value, NULL);
}

/**
 * foo_bar_get_u:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.u">"u"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
guint 
foo_bar_get_u (FooBar *object)
{
  guint value;
  g_object_get (G_OBJECT (object), "u", &value, NULL);
  return value;
}

/**
 * foo_bar_set_u:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.u">"u"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_u (FooBar *object, guint value)
{
  g_object_set (G_OBJECT (object), "u", value, NULL);
}

/**
 * foo_bar_get_x:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.x">"x"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
gint64 
foo_bar_get_x (FooBar *object)
{
  gint64 value;
  g_object_get (G_OBJECT (object), "x", &value, NULL);
  return value;
}

/**
 * foo_bar_set_x:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.x">"x"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_x (FooBar *object, gint64 value)
{
  g_object_set (G_OBJECT (object), "x", value, NULL);
}

/**
 * foo_bar_get_t:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.t">"t"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
guint64 
foo_bar_get_t (FooBar *object)
{
  guint64 value;
  g_object_get (G_OBJECT (object), "t", &value, NULL);
  return value;
}

/**
 * foo_bar_set_t:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.t">"t"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_t (FooBar *object, guint64 value)
{
  g_object_set (G_OBJECT (object), "t", value, NULL);
}

/**
 * foo_bar_get_d:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.d">"d"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
gdouble 
foo_bar_get_d (FooBar *object)
{
  gdouble value;
  g_object_get (G_OBJECT (object), "d", &value, NULL);
  return value;
}

/**
 * foo_bar_set_d:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.d">"d"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_d (FooBar *object, gdouble value)
{
  g_object_set (G_OBJECT (object), "d", value, NULL);
}

/**
 * foo_bar_get_s:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.s">"s"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
const gchar *
foo_bar_get_s (FooBar *object)
{
  const gchar *value;
  g_object_get (G_OBJECT (object), "s", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-s", (gpointer) value, (GDestroyNotify) g_free);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-s", (gpointer) value, NULL);
  return value;
}

/**
 * foo_bar_set_s:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.s">"s"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_s (FooBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "s", value, NULL);
}

/**
 * foo_bar_get_o:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.o">"o"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
const gchar *
foo_bar_get_o (FooBar *object)
{
  const gchar *value;
  g_object_get (G_OBJECT (object), "o", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-o", (gpointer) value, (GDestroyNotify) g_free);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-o", (gpointer) value, NULL);
  return value;
}

/**
 * foo_bar_set_o:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.o">"o"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_o (FooBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "o", value, NULL);
}

/**
 * foo_bar_get_g:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.g">"g"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
const gchar *
foo_bar_get_g (FooBar *object)
{
  const gchar *value;
  g_object_get (G_OBJECT (object), "g", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-g", (gpointer) value, (GDestroyNotify) g_free);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-g", (gpointer) value, NULL);
  return value;
}

/**
 * foo_bar_set_g:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.g">"g"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_g (FooBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "g", value, NULL);
}

/**
 * foo_bar_get_ay:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.ay">"ay"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
const gchar *
foo_bar_get_ay (FooBar *object)
{
  const gchar *value;
  g_object_get (G_OBJECT (object), "ay", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-ay", (gpointer) value, (GDestroyNotify) g_free);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-ay", (gpointer) value, NULL);
  return value;
}

/**
 * foo_bar_set_ay:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.ay">"ay"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_ay (FooBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "ay", value, NULL);
}

/**
 * foo_bar_get_as:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.as">"as"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
const gchar *const *
foo_bar_get_as (FooBar *object)
{
  const gchar *const *value;
  g_object_get (G_OBJECT (object), "as", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-as", (gpointer) value, (GDestroyNotify) g_strfreev);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-as", (gpointer) value, NULL);
  return value;
}

/**
 * foo_bar_set_as:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.as">"as"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_as (FooBar *object, const gchar *const *value)
{
  g_object_set (G_OBJECT (object), "as", value, NULL);
}

/**
 * foo_bar_get_aay:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.aay">"aay"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
const gchar *const *
foo_bar_get_aay (FooBar *object)
{
  const gchar *const *value;
  g_object_get (G_OBJECT (object), "aay", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-aay", (gpointer) value, (GDestroyNotify) g_strfreev);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-aay", (gpointer) value, NULL);
  return value;
}

/**
 * foo_bar_set_aay:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.aay">"aay"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_aay (FooBar *object, const gchar *const *value)
{
  g_object_set (G_OBJECT (object), "aay", value, NULL);
}

/**
 * foo_bar_get_ao:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.ao">"ao"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
const gchar *const *
foo_bar_get_ao (FooBar *object)
{
  const gchar *const *value;
  g_object_get (G_OBJECT (object), "ao", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-ao", (gpointer) value, (GDestroyNotify) g_strfreev);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-ao", (gpointer) value, NULL);
  return value;
}

/**
 * foo_bar_set_ao:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.ao">"ao"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_ao (FooBar *object, const gchar *const *value)
{
  g_object_set (G_OBJECT (object), "ao", value, NULL);
}

/**
 * foo_bar_get_ag:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.ag">"ag"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
GVariant *
foo_bar_get_ag (FooBar *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "ag", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-ag", (gpointer) value, (GDestroyNotify) g_variant_unref);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-ag", (gpointer) value, NULL);
  return value;
}

/**
 * foo_bar_set_ag:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.ag">"ag"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_ag (FooBar *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "ag", value, NULL);
}

/**
 * foo_bar_get_finally_normal_name:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.FinallyNormalName">"FinallyNormalName"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
const gchar *
foo_bar_get_finally_normal_name (FooBar *object)
{
  const gchar *value;
  g_object_get (G_OBJECT (object), "finally-normal-name", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-finally-normal-name", (gpointer) value, (GDestroyNotify) g_free);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-finally-normal-name", (gpointer) value, NULL);
  return value;
}

/**
 * foo_bar_set_finally_normal_name:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.FinallyNormalName">"FinallyNormalName"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_finally_normal_name (FooBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "finally-normal-name", value, NULL);
}

/**
 * foo_bar_get_readonly_property:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.ReadonlyProperty">"ReadonlyProperty"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
const gchar *
foo_bar_get_readonly_property (FooBar *object)
{
  const gchar *value;
  g_object_get (G_OBJECT (object), "readonly-property", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-readonly-property", (gpointer) value, (GDestroyNotify) g_free);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-readonly-property", (gpointer) value, NULL);
  return value;
}

/**
 * foo_bar_set_readonly_property:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.ReadonlyProperty">"ReadonlyProperty"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_bar_set_readonly_property (FooBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "readonly-property", value, NULL);
}

/**
 * foo_bar_get_writeonly_property:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.WriteonlyProperty">"WriteonlyProperty"</link> D-Bus property.
 *
 * Since this D-Bus property is not readable, it is only meaningful to use this function on the service-side.
 *
 * Returns: (transfer none): The property value.
 */
const gchar *
foo_bar_get_writeonly_property (FooBar *object)
{
  const gchar *value;
  g_object_get (G_OBJECT (object), "writeonly-property", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-writeonly-property", (gpointer) value, (GDestroyNotify) g_free);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-writeonly-property", (gpointer) value, NULL);
  return value;
}

/**
 * foo_bar_set_writeonly_property:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.WriteonlyProperty">"WriteonlyProperty"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_writeonly_property (FooBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "writeonly-property", value, NULL);
}

/**
 * foo_bar_get_unset_i:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_i">"unset_i"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
gint 
foo_bar_get_unset_i (FooBar *object)
{
  gint value;
  g_object_get (G_OBJECT (object), "unset-i", &value, NULL);
  return value;
}

/**
 * foo_bar_set_unset_i:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_i">"unset_i"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_unset_i (FooBar *object, gint value)
{
  g_object_set (G_OBJECT (object), "unset-i", value, NULL);
}

/**
 * foo_bar_get_unset_d:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_d">"unset_d"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
gdouble 
foo_bar_get_unset_d (FooBar *object)
{
  gdouble value;
  g_object_get (G_OBJECT (object), "unset-d", &value, NULL);
  return value;
}

/**
 * foo_bar_set_unset_d:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_d">"unset_d"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_unset_d (FooBar *object, gdouble value)
{
  g_object_set (G_OBJECT (object), "unset-d", value, NULL);
}

/**
 * foo_bar_get_unset_s:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_s">"unset_s"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
const gchar *
foo_bar_get_unset_s (FooBar *object)
{
  const gchar *value;
  g_object_get (G_OBJECT (object), "unset-s", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-unset-s", (gpointer) value, (GDestroyNotify) g_free);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-unset-s", (gpointer) value, NULL);
  return value;
}

/**
 * foo_bar_set_unset_s:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_s">"unset_s"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_unset_s (FooBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "unset-s", value, NULL);
}

/**
 * foo_bar_get_unset_o:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_o">"unset_o"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
const gchar *
foo_bar_get_unset_o (FooBar *object)
{
  const gchar *value;
  g_object_get (G_OBJECT (object), "unset-o", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-unset-o", (gpointer) value, (GDestroyNotify) g_free);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-unset-o", (gpointer) value, NULL);
  return value;
}

/**
 * foo_bar_set_unset_o:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_o">"unset_o"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_unset_o (FooBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "unset-o", value, NULL);
}

/**
 * foo_bar_get_unset_g:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_g">"unset_g"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
const gchar *
foo_bar_get_unset_g (FooBar *object)
{
  const gchar *value;
  g_object_get (G_OBJECT (object), "unset-g", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-unset-g", (gpointer) value, (GDestroyNotify) g_free);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-unset-g", (gpointer) value, NULL);
  return value;
}

/**
 * foo_bar_set_unset_g:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_g">"unset_g"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_unset_g (FooBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "unset-g", value, NULL);
}

/**
 * foo_bar_get_unset_ay:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_ay">"unset_ay"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
const gchar *
foo_bar_get_unset_ay (FooBar *object)
{
  const gchar *value;
  g_object_get (G_OBJECT (object), "unset-ay", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-unset-ay", (gpointer) value, (GDestroyNotify) g_free);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-unset-ay", (gpointer) value, NULL);
  return value;
}

/**
 * foo_bar_set_unset_ay:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_ay">"unset_ay"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_unset_ay (FooBar *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "unset-ay", value, NULL);
}

/**
 * foo_bar_get_unset_as:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_as">"unset_as"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
const gchar *const *
foo_bar_get_unset_as (FooBar *object)
{
  const gchar *const *value;
  g_object_get (G_OBJECT (object), "unset-as", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-unset-as", (gpointer) value, (GDestroyNotify) g_strfreev);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-unset-as", (gpointer) value, NULL);
  return value;
}

/**
 * foo_bar_set_unset_as:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_as">"unset_as"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_unset_as (FooBar *object, const gchar *const *value)
{
  g_object_set (G_OBJECT (object), "unset-as", value, NULL);
}

/**
 * foo_bar_get_unset_ao:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_ao">"unset_ao"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
const gchar *const *
foo_bar_get_unset_ao (FooBar *object)
{
  const gchar *const *value;
  g_object_get (G_OBJECT (object), "unset-ao", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-unset-ao", (gpointer) value, (GDestroyNotify) g_strfreev);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-unset-ao", (gpointer) value, NULL);
  return value;
}

/**
 * foo_bar_set_unset_ao:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_ao">"unset_ao"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_unset_ao (FooBar *object, const gchar *const *value)
{
  g_object_set (G_OBJECT (object), "unset-ao", value, NULL);
}

/**
 * foo_bar_get_unset_ag:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_ag">"unset_ag"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
GVariant *
foo_bar_get_unset_ag (FooBar *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "unset-ag", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-unset-ag", (gpointer) value, (GDestroyNotify) g_variant_unref);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-unset-ag", (gpointer) value, NULL);
  return value;
}

/**
 * foo_bar_set_unset_ag:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_ag">"unset_ag"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_unset_ag (FooBar *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "unset-ag", value, NULL);
}

/**
 * foo_bar_get_unset_struct:
 * @object: A #FooBar.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bar.unset_struct">"unset_struct"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
GVariant *
foo_bar_get_unset_struct (FooBar *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "unset-struct", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-unset-struct", (gpointer) value, (GDestroyNotify) g_variant_unref);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-unset-struct", (gpointer) value, NULL);
  return value;
}

/**
 * foo_bar_set_unset_struct:
 * @object: A #FooBar.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bar.unset_struct">"unset_struct"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bar_set_unset_struct (FooBar *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "unset-struct", value, NULL);
}

/**
 * foo_bar_emit_test_signal:
 * @object: A #FooBar.
 * @val_int32: Argument to pass with the signal.
 * @array_of_strings: Argument to pass with the signal.
 * @array_of_bytestrings: Argument to pass with the signal.
 * @dict_s_to_pairs: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-org-project-Bar.TestSignal">"TestSignal"</link> D-Bus signal.
 */
void
foo_bar_emit_test_signal (
    FooBar *object,
    gint val_int32,
    const gchar *const *array_of_strings,
    const gchar *const *array_of_bytestrings,
    GVariant *dict_s_to_pairs)
{
  g_signal_emit_by_name (object, "test-signal", val_int32, array_of_strings, array_of_bytestrings, dict_s_to_pairs);
}

/**
 * foo_bar_emit_another_signal:
 * @object: A #FooBar.
 * @word: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-org-project-Bar.AnotherSignal">"AnotherSignal"</link> D-Bus signal.
 */
void
foo_bar_emit_another_signal (
    FooBar *object,
    const gchar *word)
{
  g_signal_emit_by_name (object, "another-signal", word);
}

/**
 * foo_bar_call_hello_world:
 * @proxy: A #FooBarProxy.
 * @greeting: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bar.HelloWorld">HelloWorld()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_bar_call_hello_world_finish() to get the result of the operation.
 *
 * See foo_bar_call_hello_world_sync() for the synchronous, blocking version of this method.
 */
void
foo_bar_call_hello_world (
    FooBar *proxy,
    const gchar *greeting,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "HelloWorld",
    g_variant_new ("(s)",
                   greeting),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_bar_call_hello_world_finish:
 * @proxy: A #FooBarProxy.
 * @out_response: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_bar_call_hello_world().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_bar_call_hello_world().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_bar_call_hello_world_finish (
    FooBar *proxy,
    gchar **out_response,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_response);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_bar_call_hello_world_sync:
 * @proxy: A #FooBarProxy.
 * @greeting: Argument to pass with the method invocation.
 * @out_response: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bar.HelloWorld">HelloWorld()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_bar_call_hello_world() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_bar_call_hello_world_sync (
    FooBar *proxy,
    const gchar *greeting,
    gchar **out_response,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "HelloWorld",
    g_variant_new ("(s)",
                   greeting),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_response);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_bar_call_test_primitive_types:
 * @proxy: A #FooBarProxy.
 * @val_byte: Argument to pass with the method invocation.
 * @val_boolean: Argument to pass with the method invocation.
 * @val_int16: Argument to pass with the method invocation.
 * @val_uint16: Argument to pass with the method invocation.
 * @val_int32: Argument to pass with the method invocation.
 * @val_uint32: Argument to pass with the method invocation.
 * @val_int64: Argument to pass with the method invocation.
 * @val_uint64: Argument to pass with the method invocation.
 * @val_double: Argument to pass with the method invocation.
 * @val_string: Argument to pass with the method invocation.
 * @val_objpath: Argument to pass with the method invocation.
 * @val_signature: Argument to pass with the method invocation.
 * @val_bytestring: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bar.TestPrimitiveTypes">TestPrimitiveTypes()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_bar_call_test_primitive_types_finish() to get the result of the operation.
 *
 * See foo_bar_call_test_primitive_types_sync() for the synchronous, blocking version of this method.
 */
void
foo_bar_call_test_primitive_types (
    FooBar *proxy,
    guchar val_byte,
    gboolean val_boolean,
    gint16 val_int16,
    guint16 val_uint16,
    gint val_int32,
    guint val_uint32,
    gint64 val_int64,
    guint64 val_uint64,
    gdouble val_double,
    const gchar *val_string,
    const gchar *val_objpath,
    const gchar *val_signature,
    const gchar *val_bytestring,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "TestPrimitiveTypes",
    g_variant_new ("(ybnqiuxtdsog^ay)",
                   val_byte,
                   val_boolean,
                   val_int16,
                   val_uint16,
                   val_int32,
                   val_uint32,
                   val_int64,
                   val_uint64,
                   val_double,
                   val_string,
                   val_objpath,
                   val_signature,
                   val_bytestring),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_bar_call_test_primitive_types_finish:
 * @proxy: A #FooBarProxy.
 * @out_ret_byte: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_boolean: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_int16: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_uint16: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_int32: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_uint32: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_int64: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_uint64: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_double: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_string: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_objpath: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_signature: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_bytestring: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_bar_call_test_primitive_types().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_bar_call_test_primitive_types().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_bar_call_test_primitive_types_finish (
    FooBar *proxy,
    guchar *out_ret_byte,
    gboolean *out_ret_boolean,
    gint16 *out_ret_int16,
    guint16 *out_ret_uint16,
    gint *out_ret_int32,
    guint *out_ret_uint32,
    gint64 *out_ret_int64,
    guint64 *out_ret_uint64,
    gdouble *out_ret_double,
    gchar **out_ret_string,
    gchar **out_ret_objpath,
    gchar **out_ret_signature,
    gchar **out_ret_bytestring,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(ybnqiuxtdsog^ay)",
                 out_ret_byte,
                 out_ret_boolean,
                 out_ret_int16,
                 out_ret_uint16,
                 out_ret_int32,
                 out_ret_uint32,
                 out_ret_int64,
                 out_ret_uint64,
                 out_ret_double,
                 out_ret_string,
                 out_ret_objpath,
                 out_ret_signature,
                 out_ret_bytestring);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_bar_call_test_primitive_types_sync:
 * @proxy: A #FooBarProxy.
 * @val_byte: Argument to pass with the method invocation.
 * @val_boolean: Argument to pass with the method invocation.
 * @val_int16: Argument to pass with the method invocation.
 * @val_uint16: Argument to pass with the method invocation.
 * @val_int32: Argument to pass with the method invocation.
 * @val_uint32: Argument to pass with the method invocation.
 * @val_int64: Argument to pass with the method invocation.
 * @val_uint64: Argument to pass with the method invocation.
 * @val_double: Argument to pass with the method invocation.
 * @val_string: Argument to pass with the method invocation.
 * @val_objpath: Argument to pass with the method invocation.
 * @val_signature: Argument to pass with the method invocation.
 * @val_bytestring: Argument to pass with the method invocation.
 * @out_ret_byte: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_boolean: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_int16: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_uint16: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_int32: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_uint32: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_int64: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_uint64: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_double: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_string: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_objpath: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_signature: (out): Return location for return parameter or %NULL to ignore.
 * @out_ret_bytestring: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bar.TestPrimitiveTypes">TestPrimitiveTypes()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_bar_call_test_primitive_types() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_bar_call_test_primitive_types_sync (
    FooBar *proxy,
    guchar val_byte,
    gboolean val_boolean,
    gint16 val_int16,
    guint16 val_uint16,
    gint val_int32,
    guint val_uint32,
    gint64 val_int64,
    guint64 val_uint64,
    gdouble val_double,
    const gchar *val_string,
    const gchar *val_objpath,
    const gchar *val_signature,
    const gchar *val_bytestring,
    guchar *out_ret_byte,
    gboolean *out_ret_boolean,
    gint16 *out_ret_int16,
    guint16 *out_ret_uint16,
    gint *out_ret_int32,
    guint *out_ret_uint32,
    gint64 *out_ret_int64,
    guint64 *out_ret_uint64,
    gdouble *out_ret_double,
    gchar **out_ret_string,
    gchar **out_ret_objpath,
    gchar **out_ret_signature,
    gchar **out_ret_bytestring,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "TestPrimitiveTypes",
    g_variant_new ("(ybnqiuxtdsog^ay)",
                   val_byte,
                   val_boolean,
                   val_int16,
                   val_uint16,
                   val_int32,
                   val_uint32,
                   val_int64,
                   val_uint64,
                   val_double,
                   val_string,
                   val_objpath,
                   val_signature,
                   val_bytestring),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(ybnqiuxtdsog^ay)",
                 out_ret_byte,
                 out_ret_boolean,
                 out_ret_int16,
                 out_ret_uint16,
                 out_ret_int32,
                 out_ret_uint32,
                 out_ret_int64,
                 out_ret_uint64,
                 out_ret_double,
                 out_ret_string,
                 out_ret_objpath,
                 out_ret_signature,
                 out_ret_bytestring);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_bar_call_test_non_primitive_types:
 * @proxy: A #FooBarProxy.
 * @dict_s_to_s: Argument to pass with the method invocation.
 * @dict_s_to_pairs: Argument to pass with the method invocation.
 * @a_struct: Argument to pass with the method invocation.
 * @array_of_strings: Argument to pass with the method invocation.
 * @array_of_objpaths: Argument to pass with the method invocation.
 * @array_of_signatures: Argument to pass with the method invocation.
 * @array_of_bytestrings: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bar.TestNonPrimitiveTypes">TestNonPrimitiveTypes()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_bar_call_test_non_primitive_types_finish() to get the result of the operation.
 *
 * See foo_bar_call_test_non_primitive_types_sync() for the synchronous, blocking version of this method.
 */
void
foo_bar_call_test_non_primitive_types (
    FooBar *proxy,
    GVariant *dict_s_to_s,
    GVariant *dict_s_to_pairs,
    GVariant *a_struct,
    const gchar *const *array_of_strings,
    const gchar *const *array_of_objpaths,
    GVariant *array_of_signatures,
    const gchar *const *array_of_bytestrings,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "TestNonPrimitiveTypes",
    g_variant_new ("(@a{ss}@a{s(ii)}@(iss)^as^ao@ag^aay)",
                   dict_s_to_s,
                   dict_s_to_pairs,
                   a_struct,
                   array_of_strings,
                   array_of_objpaths,
                   array_of_signatures,
                   array_of_bytestrings),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_bar_call_test_non_primitive_types_finish:
 * @proxy: A #FooBarProxy.
 * @out_result: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_bar_call_test_non_primitive_types().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_bar_call_test_non_primitive_types().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_bar_call_test_non_primitive_types_finish (
    FooBar *proxy,
    gchar **out_result,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(^ay)",
                 out_result);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_bar_call_test_non_primitive_types_sync:
 * @proxy: A #FooBarProxy.
 * @dict_s_to_s: Argument to pass with the method invocation.
 * @dict_s_to_pairs: Argument to pass with the method invocation.
 * @a_struct: Argument to pass with the method invocation.
 * @array_of_strings: Argument to pass with the method invocation.
 * @array_of_objpaths: Argument to pass with the method invocation.
 * @array_of_signatures: Argument to pass with the method invocation.
 * @array_of_bytestrings: Argument to pass with the method invocation.
 * @out_result: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bar.TestNonPrimitiveTypes">TestNonPrimitiveTypes()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_bar_call_test_non_primitive_types() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_bar_call_test_non_primitive_types_sync (
    FooBar *proxy,
    GVariant *dict_s_to_s,
    GVariant *dict_s_to_pairs,
    GVariant *a_struct,
    const gchar *const *array_of_strings,
    const gchar *const *array_of_objpaths,
    GVariant *array_of_signatures,
    const gchar *const *array_of_bytestrings,
    gchar **out_result,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "TestNonPrimitiveTypes",
    g_variant_new ("(@a{ss}@a{s(ii)}@(iss)^as^ao@ag^aay)",
                   dict_s_to_s,
                   dict_s_to_pairs,
                   a_struct,
                   array_of_strings,
                   array_of_objpaths,
                   array_of_signatures,
                   array_of_bytestrings),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(^ay)",
                 out_result);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_bar_call_request_signal_emission:
 * @proxy: A #FooBarProxy.
 * @which_one: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bar.RequestSignalEmission">RequestSignalEmission()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_bar_call_request_signal_emission_finish() to get the result of the operation.
 *
 * See foo_bar_call_request_signal_emission_sync() for the synchronous, blocking version of this method.
 */
void
foo_bar_call_request_signal_emission (
    FooBar *proxy,
    gint which_one,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "RequestSignalEmission",
    g_variant_new ("(i)",
                   which_one),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_bar_call_request_signal_emission_finish:
 * @proxy: A #FooBarProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_bar_call_request_signal_emission().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_bar_call_request_signal_emission().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_bar_call_request_signal_emission_finish (
    FooBar *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_bar_call_request_signal_emission_sync:
 * @proxy: A #FooBarProxy.
 * @which_one: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bar.RequestSignalEmission">RequestSignalEmission()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_bar_call_request_signal_emission() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_bar_call_request_signal_emission_sync (
    FooBar *proxy,
    gint which_one,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "RequestSignalEmission",
    g_variant_new ("(i)",
                   which_one),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_bar_call_request_multi_property_mods:
 * @proxy: A #FooBarProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bar.RequestMultiPropertyMods">RequestMultiPropertyMods()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_bar_call_request_multi_property_mods_finish() to get the result of the operation.
 *
 * See foo_bar_call_request_multi_property_mods_sync() for the synchronous, blocking version of this method.
 */
void
foo_bar_call_request_multi_property_mods (
    FooBar *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "RequestMultiPropertyMods",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_bar_call_request_multi_property_mods_finish:
 * @proxy: A #FooBarProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_bar_call_request_multi_property_mods().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_bar_call_request_multi_property_mods().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_bar_call_request_multi_property_mods_finish (
    FooBar *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_bar_call_request_multi_property_mods_sync:
 * @proxy: A #FooBarProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bar.RequestMultiPropertyMods">RequestMultiPropertyMods()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_bar_call_request_multi_property_mods() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_bar_call_request_multi_property_mods_sync (
    FooBar *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "RequestMultiPropertyMods",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_bar_call_unimplemented_method:
 * @proxy: A #FooBarProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bar.UnimplementedMethod">UnimplementedMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_bar_call_unimplemented_method_finish() to get the result of the operation.
 *
 * See foo_bar_call_unimplemented_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_bar_call_unimplemented_method (
    FooBar *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "UnimplementedMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_bar_call_unimplemented_method_finish:
 * @proxy: A #FooBarProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_bar_call_unimplemented_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_bar_call_unimplemented_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_bar_call_unimplemented_method_finish (
    FooBar *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_bar_call_unimplemented_method_sync:
 * @proxy: A #FooBarProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bar.UnimplementedMethod">UnimplementedMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_bar_call_unimplemented_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_bar_call_unimplemented_method_sync (
    FooBar *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "UnimplementedMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_bar_call_property_cancellation:
 * @proxy: A #FooBarProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bar.PropertyCancellation">PropertyCancellation()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_bar_call_property_cancellation_finish() to get the result of the operation.
 *
 * See foo_bar_call_property_cancellation_sync() for the synchronous, blocking version of this method.
 */
void
foo_bar_call_property_cancellation (
    FooBar *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "PropertyCancellation",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_bar_call_property_cancellation_finish:
 * @proxy: A #FooBarProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_bar_call_property_cancellation().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_bar_call_property_cancellation().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_bar_call_property_cancellation_finish (
    FooBar *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_bar_call_property_cancellation_sync:
 * @proxy: A #FooBarProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bar.PropertyCancellation">PropertyCancellation()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_bar_call_property_cancellation() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_bar_call_property_cancellation_sync (
    FooBar *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "PropertyCancellation",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_bar_complete_hello_world:
 * @object: A #FooBar.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @response: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bar.HelloWorld">HelloWorld()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_bar_complete_hello_world (
    FooBar *object,
    GDBusMethodInvocation *invocation,
    const gchar *response)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(s)",
                   response));
}

/**
 * foo_bar_complete_test_primitive_types:
 * @object: A #FooBar.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @ret_byte: Parameter to return.
 * @ret_boolean: Parameter to return.
 * @ret_int16: Parameter to return.
 * @ret_uint16: Parameter to return.
 * @ret_int32: Parameter to return.
 * @ret_uint32: Parameter to return.
 * @ret_int64: Parameter to return.
 * @ret_uint64: Parameter to return.
 * @ret_double: Parameter to return.
 * @ret_string: Parameter to return.
 * @ret_objpath: Parameter to return.
 * @ret_signature: Parameter to return.
 * @ret_bytestring: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bar.TestPrimitiveTypes">TestPrimitiveTypes()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_bar_complete_test_primitive_types (
    FooBar *object,
    GDBusMethodInvocation *invocation,
    guchar ret_byte,
    gboolean ret_boolean,
    gint16 ret_int16,
    guint16 ret_uint16,
    gint ret_int32,
    guint ret_uint32,
    gint64 ret_int64,
    guint64 ret_uint64,
    gdouble ret_double,
    const gchar *ret_string,
    const gchar *ret_objpath,
    const gchar *ret_signature,
    const gchar *ret_bytestring)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(ybnqiuxtdsog^ay)",
                   ret_byte,
                   ret_boolean,
                   ret_int16,
                   ret_uint16,
                   ret_int32,
                   ret_uint32,
                   ret_int64,
                   ret_uint64,
                   ret_double,
                   ret_string,
                   ret_objpath,
                   ret_signature,
                   ret_bytestring));
}

/**
 * foo_bar_complete_test_non_primitive_types:
 * @object: A #FooBar.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @result: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bar.TestNonPrimitiveTypes">TestNonPrimitiveTypes()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_bar_complete_test_non_primitive_types (
    FooBar *object,
    GDBusMethodInvocation *invocation,
    const gchar *result)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(^ay)",
                   result));
}

/**
 * foo_bar_complete_request_signal_emission:
 * @object: A #FooBar.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bar.RequestSignalEmission">RequestSignalEmission()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_bar_complete_request_signal_emission (
    FooBar *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_bar_complete_request_multi_property_mods:
 * @object: A #FooBar.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bar.RequestMultiPropertyMods">RequestMultiPropertyMods()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_bar_complete_request_multi_property_mods (
    FooBar *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_bar_complete_unimplemented_method:
 * @object: A #FooBar.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bar.UnimplementedMethod">UnimplementedMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_bar_complete_unimplemented_method (
    FooBar *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_bar_complete_property_cancellation:
 * @object: A #FooBar.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bar.PropertyCancellation">PropertyCancellation()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_bar_complete_property_cancellation (
    FooBar *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FooBarProxy:
 *
 * The #FooBarProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooBarProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooBarProxy.
 */

static void
foo_bar_proxy_iface_init (FooBarIface *iface)
{
}

#define foo_bar_proxy_get_type foo_bar_proxy_get_type
G_DEFINE_TYPE_WITH_CODE (FooBarProxy, foo_bar_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_BAR, foo_bar_proxy_iface_init));
#undef foo_bar_proxy_get_type

static void
foo_bar_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 30);
  info = _foo_bar_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
foo_bar_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  error = NULL;
  if (!g_dbus_proxy_call_finish (proxy, res, &error))
    {
      g_warning ("Error setting property `%s' on interface org.project.Bar: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
}

static void
foo_bar_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 30);
  info = _foo_bar_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.project.Bar", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) foo_bar_proxy_set_property_cb, (gpointer) info);
  g_variant_unref (variant);
}

static void
foo_bar_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_bar_interface_info, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_TYPE_BAR);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_BAR);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_bar_proxy_g_properties_changed (GDBusProxy *proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_bar_interface_info, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_bar_interface_info, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_bar_proxy_init (FooBarProxy *proxy)
{
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_bar_interface_info ());
}

static void
foo_bar_proxy_class_init (FooBarProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->get_property = foo_bar_proxy_get_property;
  gobject_class->set_property = foo_bar_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_bar_proxy_g_signal;
  proxy_class->g_properties_changed = foo_bar_proxy_g_properties_changed;


  foo_bar_override_properties (gobject_class, 1);
}

/**
 * foo_bar_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_bar_proxy_new_finish() to get the result of the operation.
 *
 * See foo_bar_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_bar_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_BAR_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Bar", NULL);
}

/**
 * foo_bar_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_bar_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_bar_proxy_new().
 *
 * Returns: (transfer full) (type FooBarProxy): The constructed proxy object or %NULL if @error is set.
 */
FooBar *
foo_bar_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_BAR (ret);
  else
    return NULL;
}

/**
 * foo_bar_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_bar_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooBarProxy): The constructed proxy object or %NULL if @error is set.
 */
FooBar *
foo_bar_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_BAR_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Bar", NULL);
  if (ret != NULL)
    return FOO_BAR (ret);
  else
    return NULL;
}


/**
 * foo_bar_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_bar_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_bar_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_bar_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_bar_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_BAR_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Bar", NULL);
}

/**
 * foo_bar_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_bar_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_bar_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooBarProxy): The constructed proxy object or %NULL if @error is set.
 */
FooBar *
foo_bar_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_BAR (ret);
  else
    return NULL;
}

/**
 * foo_bar_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_bar_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_bar_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooBarProxy): The constructed proxy object or %NULL if @error is set.
 */
FooBar *
foo_bar_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_BAR_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Bar", NULL);
  if (ret != NULL)
    return FOO_BAR (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooBarSkeleton:
 *
 * The #FooBarSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooBarSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooBarSkeleton.
 */

struct _FooBarSkeletonPrivate
{
  GValueArray *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex *lock;
};

static void
_foo_bar_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooBarSkeleton *skeleton = FOO_BAR_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = {0};
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_TYPE_BAR);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
  {
    g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
    g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
  }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_BAR);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_bar_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooBarSkeleton *skeleton = FOO_BAR_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_bar_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_bar_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooBarSkeleton *skeleton = FOO_BAR_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_bar_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_bar_skeleton_vtable =
{
  _foo_bar_skeleton_handle_method_call,
  _foo_bar_skeleton_handle_get_property,
  _foo_bar_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
foo_bar_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return foo_bar_interface_info ();
}

static GDBusInterfaceVTable *
foo_bar_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_foo_bar_skeleton_vtable;
}

static GVariant *
foo_bar_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooBarSkeleton *skeleton = FOO_BAR_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_bar_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_bar_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_bar_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_bar_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.Bar", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _foo_bar_emit_changed (gpointer user_data);

static void
foo_bar_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  FooBarSkeleton *skeleton = FOO_BAR_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (skeleton->priv->lock);

  if (emit_changed)
    _foo_bar_emit_changed (skeleton);
}

static void
_foo_bar_on_signal_test_signal (
    FooBar *object,
    gint val_int32,
    const gchar *const *array_of_strings,
    const gchar *const *array_of_bytestrings,
    GVariant *dict_s_to_pairs)
{
  FooBarSkeleton *skeleton = FOO_BAR_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.Bar", "TestSignal",
    g_variant_new ("(i^as^aay@a{s(ii)})",
                   val_int32,
                   array_of_strings,
                   array_of_bytestrings,
                   dict_s_to_pairs), NULL);
}

static void
_foo_bar_on_signal_another_signal (
    FooBar *object,
    const gchar *word)
{
  FooBarSkeleton *skeleton = FOO_BAR_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.Bar", "AnotherSignal",
    g_variant_new ("(s)",
                   word), NULL);
}

static void
foo_bar_skeleton_iface_init (FooBarIface *iface)
{
  iface->test_signal = _foo_bar_on_signal_test_signal;
  iface->another_signal = _foo_bar_on_signal_another_signal;
}

#define foo_bar_skeleton_get_type foo_bar_skeleton_get_type
G_DEFINE_TYPE_WITH_CODE (FooBarSkeleton, foo_bar_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_BAR, foo_bar_skeleton_iface_init));
#undef foo_bar_skeleton_get_type

static void
foo_bar_skeleton_finalize (GObject *object)
{
  FooBarSkeleton *skeleton = FOO_BAR_SKELETON (object);
  g_value_array_free (skeleton->priv->properties);
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  if (skeleton->priv->context != NULL)
    g_main_context_unref (skeleton->priv->context);
  g_mutex_free (skeleton->priv->lock);
  G_OBJECT_CLASS (foo_bar_skeleton_parent_class)->finalize (object);
}

static void
foo_bar_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  FooBarSkeleton *skeleton = FOO_BAR_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 30);
  g_mutex_lock (skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties->values[prop_id - 1], value);
  g_mutex_unlock (skeleton->priv->lock);
}

static gboolean
_foo_bar_emit_changed (gpointer user_data)
{
  FooBarSkeleton *skeleton = FOO_BAR_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties->values[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      g_dbus_connection_emit_signal (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                     NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                     "org.freedesktop.DBus.Properties",
                                     "PropertiesChanged",
                                     g_variant_new ("(sa{sv}as)",
                                                    "org.project.Bar",
                                                    &builder, &invalidated_builder),
                                     NULL);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (skeleton->priv->lock);
  return FALSE;
}

static void
_foo_bar_schedule_emit_changed (FooBarSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
foo_bar_skeleton_notify (GObject      *object,
  GParamSpec *pspec)
{
  FooBarSkeleton *skeleton = FOO_BAR_SKELETON (object);
  g_mutex_lock (skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _foo_bar_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (skeleton->priv->lock);
}

static void
foo_bar_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  FooBarSkeleton *skeleton = FOO_BAR_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 30);
  g_mutex_lock (skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties->values[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _foo_bar_schedule_emit_changed (skeleton, _foo_bar_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties->values[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties->values[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
foo_bar_skeleton_init (FooBarSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_TYPE_BAR_SKELETON, FooBarSkeletonPrivate);
  skeleton->priv->lock = g_mutex_new ();
  skeleton->priv->context = g_main_context_get_thread_default ();
  if (skeleton->priv->context != NULL)
    g_main_context_ref (skeleton->priv->context);
  skeleton->priv->properties = g_value_array_new (30);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[0], G_TYPE_UCHAR);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[1], G_TYPE_BOOLEAN);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[2], G_TYPE_INT);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[3], G_TYPE_UINT);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[4], G_TYPE_INT);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[5], G_TYPE_UINT);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[6], G_TYPE_INT64);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[7], G_TYPE_UINT64);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[8], G_TYPE_DOUBLE);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[9], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[10], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[11], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[12], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[13], G_TYPE_STRV);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[14], G_TYPE_STRV);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[15], G_TYPE_STRV);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[16], G_TYPE_VARIANT);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[17], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[18], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[19], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[20], G_TYPE_INT);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[21], G_TYPE_DOUBLE);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[22], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[23], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[24], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[25], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[26], G_TYPE_STRV);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[27], G_TYPE_STRV);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[28], G_TYPE_VARIANT);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[29], G_TYPE_VARIANT);
}

static void
foo_bar_skeleton_class_init (FooBarSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (FooBarSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_bar_skeleton_finalize;
  gobject_class->get_property = foo_bar_skeleton_get_property;
  gobject_class->set_property = foo_bar_skeleton_set_property;
  gobject_class->notify       = foo_bar_skeleton_notify;


  foo_bar_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_bar_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_bar_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_bar_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_bar_skeleton_dbus_interface_get_vtable;
}

/**
 * foo_bar_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link>.
 *
 * Returns: (transfer full) (type FooBarSkeleton): The skeleton object.
 */
FooBar *
foo_bar_skeleton_new (void)
{
  return FOO_BAR (g_object_new (FOO_TYPE_BAR_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.project.Bar.Frobnicator
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooBarFrobnicator
 * @title: FooBarFrobnicator
 * @short_description: Generated C code for the org.project.Bar.Frobnicator D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.project.Bar.Frobnicator ---- */

static const _ExtendedGDBusMethodInfo _foo_bar_frobnicator_method_info_random_method =
{
  {
    -1,
    "RandomMethod",
    NULL,
    NULL,
    NULL
  },
  "handle-random-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_bar_frobnicator_method_info_pointers[] =
{
  &_foo_bar_frobnicator_method_info_random_method,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_bar_frobnicator_interface_info =
{
  {
    -1,
    "org.project.Bar.Frobnicator",
    (GDBusMethodInfo **) &_foo_bar_frobnicator_method_info_pointers,
    NULL,
    NULL,
    NULL
  },
  "bar-frobnicator",
};


/**
 * foo_bar_frobnicator_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_bar_frobnicator_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_bar_frobnicator_interface_info;
}



/**
 * FooBarFrobnicator:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link>.
 */

/**
 * FooBarFrobnicatorIface:
 * @parent_iface: The parent interface.
 * @handle_random_method: Handler for the #FooBarFrobnicator::handle-random-method signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link>.
 */

static void
foo_bar_frobnicator_default_init (FooBarFrobnicatorIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooBarFrobnicator::handle-random-method:
   * @object: A #FooBarFrobnicator.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bar-Frobnicator.RandomMethod">RandomMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_bar_frobnicator_complete_random_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-random-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooBarFrobnicatorIface, handle_random_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

}

typedef FooBarFrobnicatorIface FooBarFrobnicatorInterface;
G_DEFINE_INTERFACE (FooBarFrobnicator, foo_bar_frobnicator, G_TYPE_OBJECT);

/**
 * foo_bar_frobnicator_call_random_method:
 * @proxy: A #FooBarFrobnicatorProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bar-Frobnicator.RandomMethod">RandomMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_bar_frobnicator_call_random_method_finish() to get the result of the operation.
 *
 * See foo_bar_frobnicator_call_random_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_bar_frobnicator_call_random_method (
    FooBarFrobnicator *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "RandomMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_bar_frobnicator_call_random_method_finish:
 * @proxy: A #FooBarFrobnicatorProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_bar_frobnicator_call_random_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_bar_frobnicator_call_random_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_bar_frobnicator_call_random_method_finish (
    FooBarFrobnicator *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_bar_frobnicator_call_random_method_sync:
 * @proxy: A #FooBarFrobnicatorProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bar-Frobnicator.RandomMethod">RandomMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_bar_frobnicator_call_random_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_bar_frobnicator_call_random_method_sync (
    FooBarFrobnicator *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "RandomMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_bar_frobnicator_complete_random_method:
 * @object: A #FooBarFrobnicator.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bar-Frobnicator.RandomMethod">RandomMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_bar_frobnicator_complete_random_method (
    FooBarFrobnicator *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FooBarFrobnicatorProxy:
 *
 * The #FooBarFrobnicatorProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooBarFrobnicatorProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooBarFrobnicatorProxy.
 */

static void
foo_bar_frobnicator_proxy_iface_init (FooBarFrobnicatorIface *iface)
{
}

#define foo_bar_frobnicator_proxy_get_type foo_bar_frobnicator_proxy_get_type
G_DEFINE_TYPE_WITH_CODE (FooBarFrobnicatorProxy, foo_bar_frobnicator_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_BAR_FROBNICATOR, foo_bar_frobnicator_proxy_iface_init));
#undef foo_bar_frobnicator_proxy_get_type

static void
foo_bar_frobnicator_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
}

static void
foo_bar_frobnicator_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
}

static void
foo_bar_frobnicator_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_bar_frobnicator_interface_info, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_TYPE_BAR_FROBNICATOR);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_BAR_FROBNICATOR);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_bar_frobnicator_proxy_g_properties_changed (GDBusProxy *proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_bar_frobnicator_interface_info, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_bar_frobnicator_interface_info, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_bar_frobnicator_proxy_init (FooBarFrobnicatorProxy *proxy)
{
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_bar_frobnicator_interface_info ());
}

static void
foo_bar_frobnicator_proxy_class_init (FooBarFrobnicatorProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->get_property = foo_bar_frobnicator_proxy_get_property;
  gobject_class->set_property = foo_bar_frobnicator_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_bar_frobnicator_proxy_g_signal;
  proxy_class->g_properties_changed = foo_bar_frobnicator_proxy_g_properties_changed;

}

/**
 * foo_bar_frobnicator_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_bar_frobnicator_proxy_new_finish() to get the result of the operation.
 *
 * See foo_bar_frobnicator_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_bar_frobnicator_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_BAR_FROBNICATOR_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Bar.Frobnicator", NULL);
}

/**
 * foo_bar_frobnicator_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_bar_frobnicator_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_bar_frobnicator_proxy_new().
 *
 * Returns: (transfer full) (type FooBarFrobnicatorProxy): The constructed proxy object or %NULL if @error is set.
 */
FooBarFrobnicator *
foo_bar_frobnicator_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_BAR_FROBNICATOR (ret);
  else
    return NULL;
}

/**
 * foo_bar_frobnicator_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_bar_frobnicator_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooBarFrobnicatorProxy): The constructed proxy object or %NULL if @error is set.
 */
FooBarFrobnicator *
foo_bar_frobnicator_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_BAR_FROBNICATOR_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Bar.Frobnicator", NULL);
  if (ret != NULL)
    return FOO_BAR_FROBNICATOR (ret);
  else
    return NULL;
}


/**
 * foo_bar_frobnicator_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_bar_frobnicator_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_bar_frobnicator_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_bar_frobnicator_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_bar_frobnicator_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_BAR_FROBNICATOR_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Bar.Frobnicator", NULL);
}

/**
 * foo_bar_frobnicator_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_bar_frobnicator_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_bar_frobnicator_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooBarFrobnicatorProxy): The constructed proxy object or %NULL if @error is set.
 */
FooBarFrobnicator *
foo_bar_frobnicator_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_BAR_FROBNICATOR (ret);
  else
    return NULL;
}

/**
 * foo_bar_frobnicator_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_bar_frobnicator_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_bar_frobnicator_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooBarFrobnicatorProxy): The constructed proxy object or %NULL if @error is set.
 */
FooBarFrobnicator *
foo_bar_frobnicator_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_BAR_FROBNICATOR_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Bar.Frobnicator", NULL);
  if (ret != NULL)
    return FOO_BAR_FROBNICATOR (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooBarFrobnicatorSkeleton:
 *
 * The #FooBarFrobnicatorSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooBarFrobnicatorSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooBarFrobnicatorSkeleton.
 */

struct _FooBarFrobnicatorSkeletonPrivate
{
  GValueArray *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex *lock;
};

static void
_foo_bar_frobnicator_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooBarFrobnicatorSkeleton *skeleton = FOO_BAR_FROBNICATOR_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = {0};
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_TYPE_BAR_FROBNICATOR);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
  {
    g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
    g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
  }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_BAR_FROBNICATOR);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_bar_frobnicator_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooBarFrobnicatorSkeleton *skeleton = FOO_BAR_FROBNICATOR_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_bar_frobnicator_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_bar_frobnicator_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooBarFrobnicatorSkeleton *skeleton = FOO_BAR_FROBNICATOR_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_bar_frobnicator_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_bar_frobnicator_skeleton_vtable =
{
  _foo_bar_frobnicator_skeleton_handle_method_call,
  _foo_bar_frobnicator_skeleton_handle_get_property,
  _foo_bar_frobnicator_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
foo_bar_frobnicator_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return foo_bar_frobnicator_interface_info ();
}

static GDBusInterfaceVTable *
foo_bar_frobnicator_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_foo_bar_frobnicator_skeleton_vtable;
}

static GVariant *
foo_bar_frobnicator_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooBarFrobnicatorSkeleton *skeleton = FOO_BAR_FROBNICATOR_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_bar_frobnicator_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_bar_frobnicator_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_bar_frobnicator_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_bar_frobnicator_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.Bar.Frobnicator", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
foo_bar_frobnicator_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void
foo_bar_frobnicator_skeleton_iface_init (FooBarFrobnicatorIface *iface)
{
}

#define foo_bar_frobnicator_skeleton_get_type foo_bar_frobnicator_skeleton_get_type
G_DEFINE_TYPE_WITH_CODE (FooBarFrobnicatorSkeleton, foo_bar_frobnicator_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_BAR_FROBNICATOR, foo_bar_frobnicator_skeleton_iface_init));
#undef foo_bar_frobnicator_skeleton_get_type

static void
foo_bar_frobnicator_skeleton_finalize (GObject *object)
{
  FooBarFrobnicatorSkeleton *skeleton = FOO_BAR_FROBNICATOR_SKELETON (object);
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  if (skeleton->priv->context != NULL)
    g_main_context_unref (skeleton->priv->context);
  g_mutex_free (skeleton->priv->lock);
  G_OBJECT_CLASS (foo_bar_frobnicator_skeleton_parent_class)->finalize (object);
}

static void
foo_bar_frobnicator_skeleton_init (FooBarFrobnicatorSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_TYPE_BAR_FROBNICATOR_SKELETON, FooBarFrobnicatorSkeletonPrivate);
  skeleton->priv->lock = g_mutex_new ();
  skeleton->priv->context = g_main_context_get_thread_default ();
  if (skeleton->priv->context != NULL)
    g_main_context_ref (skeleton->priv->context);
}

static void
foo_bar_frobnicator_skeleton_class_init (FooBarFrobnicatorSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (FooBarFrobnicatorSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_bar_frobnicator_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_bar_frobnicator_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_bar_frobnicator_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_bar_frobnicator_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_bar_frobnicator_skeleton_dbus_interface_get_vtable;
}

/**
 * foo_bar_frobnicator_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link>.
 *
 * Returns: (transfer full) (type FooBarFrobnicatorSkeleton): The skeleton object.
 */
FooBarFrobnicator *
foo_bar_frobnicator_skeleton_new (void)
{
  return FOO_BAR_FROBNICATOR (g_object_new (FOO_TYPE_BAR_FROBNICATOR_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.project.Baz
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooBaz
 * @title: FooBaz
 * @short_description: Generated C code for the org.project.Baz D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.project.Baz ---- */

static const _ExtendedGDBusInterfaceInfo _foo_baz_interface_info =
{
  {
    -1,
    "org.project.Baz",
    NULL,
    NULL,
    NULL,
    NULL
  },
  "baz",
};


/**
 * foo_baz_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_baz_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_baz_interface_info;
}



/**
 * FooBaz:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link>.
 */

/**
 * FooBazIface:
 * @parent_iface: The parent interface.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link>.
 */

static void
foo_baz_default_init (FooBazIface *iface)
{
}

typedef FooBazIface FooBazInterface;
G_DEFINE_INTERFACE (FooBaz, foo_baz, G_TYPE_OBJECT);

/* ------------------------------------------------------------------------ */

/**
 * FooBazProxy:
 *
 * The #FooBazProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooBazProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooBazProxy.
 */

static void
foo_baz_proxy_iface_init (FooBazIface *iface)
{
}

#define foo_baz_proxy_get_type foo_baz_proxy_get_type
G_DEFINE_TYPE_WITH_CODE (FooBazProxy, foo_baz_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_BAZ, foo_baz_proxy_iface_init));
#undef foo_baz_proxy_get_type

static void
foo_baz_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
}

static void
foo_baz_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
}

static void
foo_baz_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_baz_interface_info, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_TYPE_BAZ);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_BAZ);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_baz_proxy_g_properties_changed (GDBusProxy *proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_baz_interface_info, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_baz_interface_info, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_baz_proxy_init (FooBazProxy *proxy)
{
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_baz_interface_info ());
}

static void
foo_baz_proxy_class_init (FooBazProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->get_property = foo_baz_proxy_get_property;
  gobject_class->set_property = foo_baz_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_baz_proxy_g_signal;
  proxy_class->g_properties_changed = foo_baz_proxy_g_properties_changed;

}

/**
 * foo_baz_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_baz_proxy_new_finish() to get the result of the operation.
 *
 * See foo_baz_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_baz_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_BAZ_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Baz", NULL);
}

/**
 * foo_baz_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_baz_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_baz_proxy_new().
 *
 * Returns: (transfer full) (type FooBazProxy): The constructed proxy object or %NULL if @error is set.
 */
FooBaz *
foo_baz_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_BAZ (ret);
  else
    return NULL;
}

/**
 * foo_baz_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_baz_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooBazProxy): The constructed proxy object or %NULL if @error is set.
 */
FooBaz *
foo_baz_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_BAZ_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Baz", NULL);
  if (ret != NULL)
    return FOO_BAZ (ret);
  else
    return NULL;
}


/**
 * foo_baz_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_baz_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_baz_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_baz_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_baz_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_BAZ_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Baz", NULL);
}

/**
 * foo_baz_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_baz_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_baz_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooBazProxy): The constructed proxy object or %NULL if @error is set.
 */
FooBaz *
foo_baz_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_BAZ (ret);
  else
    return NULL;
}

/**
 * foo_baz_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_baz_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_baz_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooBazProxy): The constructed proxy object or %NULL if @error is set.
 */
FooBaz *
foo_baz_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_BAZ_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Baz", NULL);
  if (ret != NULL)
    return FOO_BAZ (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooBazSkeleton:
 *
 * The #FooBazSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooBazSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooBazSkeleton.
 */

struct _FooBazSkeletonPrivate
{
  GValueArray *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex *lock;
};

static void
_foo_baz_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooBazSkeleton *skeleton = FOO_BAZ_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = {0};
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_TYPE_BAZ);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
  {
    g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
    g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
  }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_BAZ);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_baz_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooBazSkeleton *skeleton = FOO_BAZ_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_baz_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_baz_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooBazSkeleton *skeleton = FOO_BAZ_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_baz_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_baz_skeleton_vtable =
{
  _foo_baz_skeleton_handle_method_call,
  _foo_baz_skeleton_handle_get_property,
  _foo_baz_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
foo_baz_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return foo_baz_interface_info ();
}

static GDBusInterfaceVTable *
foo_baz_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_foo_baz_skeleton_vtable;
}

static GVariant *
foo_baz_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooBazSkeleton *skeleton = FOO_BAZ_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_baz_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_baz_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_baz_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_baz_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.Baz", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
foo_baz_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void
foo_baz_skeleton_iface_init (FooBazIface *iface)
{
}

#define foo_baz_skeleton_get_type foo_baz_skeleton_get_type
G_DEFINE_TYPE_WITH_CODE (FooBazSkeleton, foo_baz_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_BAZ, foo_baz_skeleton_iface_init));
#undef foo_baz_skeleton_get_type

static void
foo_baz_skeleton_finalize (GObject *object)
{
  FooBazSkeleton *skeleton = FOO_BAZ_SKELETON (object);
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  if (skeleton->priv->context != NULL)
    g_main_context_unref (skeleton->priv->context);
  g_mutex_free (skeleton->priv->lock);
  G_OBJECT_CLASS (foo_baz_skeleton_parent_class)->finalize (object);
}

static void
foo_baz_skeleton_init (FooBazSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_TYPE_BAZ_SKELETON, FooBazSkeletonPrivate);
  skeleton->priv->lock = g_mutex_new ();
  skeleton->priv->context = g_main_context_get_thread_default ();
  if (skeleton->priv->context != NULL)
    g_main_context_ref (skeleton->priv->context);
}

static void
foo_baz_skeleton_class_init (FooBazSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (FooBazSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_baz_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_baz_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_baz_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_baz_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_baz_skeleton_dbus_interface_get_vtable;
}

/**
 * foo_baz_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link>.
 *
 * Returns: (transfer full) (type FooBazSkeleton): The skeleton object.
 */
FooBaz *
foo_baz_skeleton_new (void)
{
  return FOO_BAZ (g_object_new (FOO_TYPE_BAZ_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface com.acme.Coyote
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooComAcmeCoyote
 * @title: FooComAcmeCoyote
 * @short_description: Generated C code for the com.acme.Coyote D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link> D-Bus interface in C.
 */

/* ---- Introspection data for com.acme.Coyote ---- */

static const _ExtendedGDBusMethodInfo _foo_com_acme_coyote_method_info_run =
{
  {
    -1,
    "Run",
    NULL,
    NULL,
    NULL
  },
  "handle-run",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_com_acme_coyote_method_info_sleep =
{
  {
    -1,
    "Sleep",
    NULL,
    NULL,
    NULL
  },
  "handle-sleep",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_com_acme_coyote_method_info_attack =
{
  {
    -1,
    "Attack",
    NULL,
    NULL,
    NULL
  },
  "handle-attack",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_com_acme_coyote_method_info_pointers[] =
{
  &_foo_com_acme_coyote_method_info_run,
  &_foo_com_acme_coyote_method_info_sleep,
  &_foo_com_acme_coyote_method_info_attack,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_com_acme_coyote_signal_info_surprised =
{
  {
    -1,
    "Surprised",
    NULL,
    NULL
  },
  "surprised"
};

static const _ExtendedGDBusSignalInfo * const _foo_com_acme_coyote_signal_info_pointers[] =
{
  &_foo_com_acme_coyote_signal_info_surprised,
  NULL
};

static const _ExtendedGDBusPropertyInfo _foo_com_acme_coyote_property_info_mood =
{
  {
    -1,
    "Mood",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "mood",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _foo_com_acme_coyote_property_info_pointers[] =
{
  &_foo_com_acme_coyote_property_info_mood,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_com_acme_coyote_interface_info =
{
  {
    -1,
    "com.acme.Coyote",
    (GDBusMethodInfo **) &_foo_com_acme_coyote_method_info_pointers,
    (GDBusSignalInfo **) &_foo_com_acme_coyote_signal_info_pointers,
    (GDBusPropertyInfo **) &_foo_com_acme_coyote_property_info_pointers,
    NULL
  },
  "com-acme-coyote",
};


/**
 * foo_com_acme_coyote_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_com_acme_coyote_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_com_acme_coyote_interface_info;
}

/**
 * foo_com_acme_coyote_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooComAcmeCoyote interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_com_acme_coyote_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "mood");
  return property_id_begin - 1;
}



/**
 * FooComAcmeCoyote:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link>.
 */

/**
 * FooComAcmeCoyoteIface:
 * @parent_iface: The parent interface.
 * @handle_attack: Handler for the #FooComAcmeCoyote::handle-attack signal.
 * @handle_run: Handler for the #FooComAcmeCoyote::handle-run signal.
 * @handle_sleep: Handler for the #FooComAcmeCoyote::handle-sleep signal.
 * @surprised: Handler for the #FooComAcmeCoyote::surprised signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link>.
 */

static void
foo_com_acme_coyote_default_init (FooComAcmeCoyoteIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooComAcmeCoyote::handle-run:
   * @object: A #FooComAcmeCoyote.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-acme-Coyote.Run">Run()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_com_acme_coyote_complete_run() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-run",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooComAcmeCoyoteIface, handle_run),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooComAcmeCoyote::handle-sleep:
   * @object: A #FooComAcmeCoyote.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-acme-Coyote.Sleep">Sleep()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_com_acme_coyote_complete_sleep() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-sleep",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooComAcmeCoyoteIface, handle_sleep),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooComAcmeCoyote::handle-attack:
   * @object: A #FooComAcmeCoyote.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-acme-Coyote.Attack">Attack()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_com_acme_coyote_complete_attack() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-attack",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooComAcmeCoyoteIface, handle_attack),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooComAcmeCoyote::surprised:
   * @object: A #FooComAcmeCoyote.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-com-acme-Coyote.Surprised">"Surprised"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("surprised",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooComAcmeCoyoteIface, surprised),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /* GObject properties for D-Bus properties: */
  /**
   * FooComAcmeCoyote:mood:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-com-acme-Coyote.Mood">"Mood"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("mood", "Mood", "Mood", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

typedef FooComAcmeCoyoteIface FooComAcmeCoyoteInterface;
G_DEFINE_INTERFACE (FooComAcmeCoyote, foo_com_acme_coyote, G_TYPE_OBJECT);

/**
 * foo_com_acme_coyote_get_mood:
 * @object: A #FooComAcmeCoyote.
 *
 * Gets the value of the <link linkend="gdbus-property-com-acme-Coyote.Mood">"Mood"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
const gchar *
foo_com_acme_coyote_get_mood (FooComAcmeCoyote *object)
{
  const gchar *value;
  g_object_get (G_OBJECT (object), "mood", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-mood", (gpointer) value, (GDestroyNotify) g_free);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-mood", (gpointer) value, NULL);
  return value;
}

/**
 * foo_com_acme_coyote_set_mood:
 * @object: A #FooComAcmeCoyote.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-com-acme-Coyote.Mood">"Mood"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_com_acme_coyote_set_mood (FooComAcmeCoyote *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "mood", value, NULL);
}

/**
 * foo_com_acme_coyote_emit_surprised:
 * @object: A #FooComAcmeCoyote.
 *
 * Emits the <link linkend="gdbus-signal-com-acme-Coyote.Surprised">"Surprised"</link> D-Bus signal.
 */
void
foo_com_acme_coyote_emit_surprised (
    FooComAcmeCoyote *object)
{
  g_signal_emit_by_name (object, "surprised");
}

/**
 * foo_com_acme_coyote_call_run:
 * @proxy: A #FooComAcmeCoyoteProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-com-acme-Coyote.Run">Run()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_com_acme_coyote_call_run_finish() to get the result of the operation.
 *
 * See foo_com_acme_coyote_call_run_sync() for the synchronous, blocking version of this method.
 */
void
foo_com_acme_coyote_call_run (
    FooComAcmeCoyote *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Run",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_com_acme_coyote_call_run_finish:
 * @proxy: A #FooComAcmeCoyoteProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_com_acme_coyote_call_run().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_com_acme_coyote_call_run().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_com_acme_coyote_call_run_finish (
    FooComAcmeCoyote *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_com_acme_coyote_call_run_sync:
 * @proxy: A #FooComAcmeCoyoteProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-com-acme-Coyote.Run">Run()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_com_acme_coyote_call_run() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_com_acme_coyote_call_run_sync (
    FooComAcmeCoyote *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Run",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_com_acme_coyote_call_sleep:
 * @proxy: A #FooComAcmeCoyoteProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-com-acme-Coyote.Sleep">Sleep()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_com_acme_coyote_call_sleep_finish() to get the result of the operation.
 *
 * See foo_com_acme_coyote_call_sleep_sync() for the synchronous, blocking version of this method.
 */
void
foo_com_acme_coyote_call_sleep (
    FooComAcmeCoyote *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Sleep",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_com_acme_coyote_call_sleep_finish:
 * @proxy: A #FooComAcmeCoyoteProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_com_acme_coyote_call_sleep().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_com_acme_coyote_call_sleep().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_com_acme_coyote_call_sleep_finish (
    FooComAcmeCoyote *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_com_acme_coyote_call_sleep_sync:
 * @proxy: A #FooComAcmeCoyoteProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-com-acme-Coyote.Sleep">Sleep()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_com_acme_coyote_call_sleep() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_com_acme_coyote_call_sleep_sync (
    FooComAcmeCoyote *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Sleep",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_com_acme_coyote_call_attack:
 * @proxy: A #FooComAcmeCoyoteProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-com-acme-Coyote.Attack">Attack()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_com_acme_coyote_call_attack_finish() to get the result of the operation.
 *
 * See foo_com_acme_coyote_call_attack_sync() for the synchronous, blocking version of this method.
 */
void
foo_com_acme_coyote_call_attack (
    FooComAcmeCoyote *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Attack",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_com_acme_coyote_call_attack_finish:
 * @proxy: A #FooComAcmeCoyoteProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_com_acme_coyote_call_attack().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_com_acme_coyote_call_attack().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_com_acme_coyote_call_attack_finish (
    FooComAcmeCoyote *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_com_acme_coyote_call_attack_sync:
 * @proxy: A #FooComAcmeCoyoteProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-com-acme-Coyote.Attack">Attack()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_com_acme_coyote_call_attack() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_com_acme_coyote_call_attack_sync (
    FooComAcmeCoyote *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Attack",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_com_acme_coyote_complete_run:
 * @object: A #FooComAcmeCoyote.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-acme-Coyote.Run">Run()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_com_acme_coyote_complete_run (
    FooComAcmeCoyote *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_com_acme_coyote_complete_sleep:
 * @object: A #FooComAcmeCoyote.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-acme-Coyote.Sleep">Sleep()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_com_acme_coyote_complete_sleep (
    FooComAcmeCoyote *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_com_acme_coyote_complete_attack:
 * @object: A #FooComAcmeCoyote.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-acme-Coyote.Attack">Attack()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_com_acme_coyote_complete_attack (
    FooComAcmeCoyote *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FooComAcmeCoyoteProxy:
 *
 * The #FooComAcmeCoyoteProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooComAcmeCoyoteProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooComAcmeCoyoteProxy.
 */

static void
foo_com_acme_coyote_proxy_iface_init (FooComAcmeCoyoteIface *iface)
{
}

#define foo_com_acme_coyote_proxy_get_type foo_com_acme_coyote_proxy_get_type
G_DEFINE_TYPE_WITH_CODE (FooComAcmeCoyoteProxy, foo_com_acme_coyote_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_COM_ACME_COYOTE, foo_com_acme_coyote_proxy_iface_init));
#undef foo_com_acme_coyote_proxy_get_type

static void
foo_com_acme_coyote_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  info = _foo_com_acme_coyote_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
foo_com_acme_coyote_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  error = NULL;
  if (!g_dbus_proxy_call_finish (proxy, res, &error))
    {
      g_warning ("Error setting property `%s' on interface com.acme.Coyote: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
}

static void
foo_com_acme_coyote_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  info = _foo_com_acme_coyote_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "com.acme.Coyote", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) foo_com_acme_coyote_proxy_set_property_cb, (gpointer) info);
  g_variant_unref (variant);
}

static void
foo_com_acme_coyote_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_com_acme_coyote_interface_info, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_TYPE_COM_ACME_COYOTE);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_COM_ACME_COYOTE);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_com_acme_coyote_proxy_g_properties_changed (GDBusProxy *proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_com_acme_coyote_interface_info, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_com_acme_coyote_interface_info, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_com_acme_coyote_proxy_init (FooComAcmeCoyoteProxy *proxy)
{
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_com_acme_coyote_interface_info ());
}

static void
foo_com_acme_coyote_proxy_class_init (FooComAcmeCoyoteProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->get_property = foo_com_acme_coyote_proxy_get_property;
  gobject_class->set_property = foo_com_acme_coyote_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_com_acme_coyote_proxy_g_signal;
  proxy_class->g_properties_changed = foo_com_acme_coyote_proxy_g_properties_changed;


  foo_com_acme_coyote_override_properties (gobject_class, 1);
}

/**
 * foo_com_acme_coyote_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_com_acme_coyote_proxy_new_finish() to get the result of the operation.
 *
 * See foo_com_acme_coyote_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_com_acme_coyote_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_COM_ACME_COYOTE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "com.acme.Coyote", NULL);
}

/**
 * foo_com_acme_coyote_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_com_acme_coyote_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_com_acme_coyote_proxy_new().
 *
 * Returns: (transfer full) (type FooComAcmeCoyoteProxy): The constructed proxy object or %NULL if @error is set.
 */
FooComAcmeCoyote *
foo_com_acme_coyote_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_COM_ACME_COYOTE (ret);
  else
    return NULL;
}

/**
 * foo_com_acme_coyote_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_com_acme_coyote_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooComAcmeCoyoteProxy): The constructed proxy object or %NULL if @error is set.
 */
FooComAcmeCoyote *
foo_com_acme_coyote_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_COM_ACME_COYOTE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "com.acme.Coyote", NULL);
  if (ret != NULL)
    return FOO_COM_ACME_COYOTE (ret);
  else
    return NULL;
}


/**
 * foo_com_acme_coyote_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_com_acme_coyote_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_com_acme_coyote_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_com_acme_coyote_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_com_acme_coyote_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_COM_ACME_COYOTE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "com.acme.Coyote", NULL);
}

/**
 * foo_com_acme_coyote_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_com_acme_coyote_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_com_acme_coyote_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooComAcmeCoyoteProxy): The constructed proxy object or %NULL if @error is set.
 */
FooComAcmeCoyote *
foo_com_acme_coyote_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_COM_ACME_COYOTE (ret);
  else
    return NULL;
}

/**
 * foo_com_acme_coyote_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_com_acme_coyote_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_com_acme_coyote_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooComAcmeCoyoteProxy): The constructed proxy object or %NULL if @error is set.
 */
FooComAcmeCoyote *
foo_com_acme_coyote_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_COM_ACME_COYOTE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "com.acme.Coyote", NULL);
  if (ret != NULL)
    return FOO_COM_ACME_COYOTE (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooComAcmeCoyoteSkeleton:
 *
 * The #FooComAcmeCoyoteSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooComAcmeCoyoteSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooComAcmeCoyoteSkeleton.
 */

struct _FooComAcmeCoyoteSkeletonPrivate
{
  GValueArray *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex *lock;
};

static void
_foo_com_acme_coyote_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooComAcmeCoyoteSkeleton *skeleton = FOO_COM_ACME_COYOTE_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = {0};
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_TYPE_COM_ACME_COYOTE);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
  {
    g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
    g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
  }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_COM_ACME_COYOTE);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_com_acme_coyote_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooComAcmeCoyoteSkeleton *skeleton = FOO_COM_ACME_COYOTE_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_com_acme_coyote_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_com_acme_coyote_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooComAcmeCoyoteSkeleton *skeleton = FOO_COM_ACME_COYOTE_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_com_acme_coyote_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_com_acme_coyote_skeleton_vtable =
{
  _foo_com_acme_coyote_skeleton_handle_method_call,
  _foo_com_acme_coyote_skeleton_handle_get_property,
  _foo_com_acme_coyote_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
foo_com_acme_coyote_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return foo_com_acme_coyote_interface_info ();
}

static GDBusInterfaceVTable *
foo_com_acme_coyote_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_foo_com_acme_coyote_skeleton_vtable;
}

static GVariant *
foo_com_acme_coyote_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooComAcmeCoyoteSkeleton *skeleton = FOO_COM_ACME_COYOTE_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_com_acme_coyote_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_com_acme_coyote_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_com_acme_coyote_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_com_acme_coyote_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "com.acme.Coyote", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _foo_com_acme_coyote_emit_changed (gpointer user_data);

static void
foo_com_acme_coyote_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  FooComAcmeCoyoteSkeleton *skeleton = FOO_COM_ACME_COYOTE_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (skeleton->priv->lock);

  if (emit_changed)
    _foo_com_acme_coyote_emit_changed (skeleton);
}

static void
_foo_com_acme_coyote_on_signal_surprised (
    FooComAcmeCoyote *object)
{
  FooComAcmeCoyoteSkeleton *skeleton = FOO_COM_ACME_COYOTE_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "com.acme.Coyote", "Surprised",
    g_variant_new ("()"), NULL);
}

static void
foo_com_acme_coyote_skeleton_iface_init (FooComAcmeCoyoteIface *iface)
{
  iface->surprised = _foo_com_acme_coyote_on_signal_surprised;
}

#define foo_com_acme_coyote_skeleton_get_type foo_com_acme_coyote_skeleton_get_type
G_DEFINE_TYPE_WITH_CODE (FooComAcmeCoyoteSkeleton, foo_com_acme_coyote_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_COM_ACME_COYOTE, foo_com_acme_coyote_skeleton_iface_init));
#undef foo_com_acme_coyote_skeleton_get_type

static void
foo_com_acme_coyote_skeleton_finalize (GObject *object)
{
  FooComAcmeCoyoteSkeleton *skeleton = FOO_COM_ACME_COYOTE_SKELETON (object);
  g_value_array_free (skeleton->priv->properties);
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  if (skeleton->priv->context != NULL)
    g_main_context_unref (skeleton->priv->context);
  g_mutex_free (skeleton->priv->lock);
  G_OBJECT_CLASS (foo_com_acme_coyote_skeleton_parent_class)->finalize (object);
}

static void
foo_com_acme_coyote_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  FooComAcmeCoyoteSkeleton *skeleton = FOO_COM_ACME_COYOTE_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  g_mutex_lock (skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties->values[prop_id - 1], value);
  g_mutex_unlock (skeleton->priv->lock);
}

static gboolean
_foo_com_acme_coyote_emit_changed (gpointer user_data)
{
  FooComAcmeCoyoteSkeleton *skeleton = FOO_COM_ACME_COYOTE_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties->values[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      g_dbus_connection_emit_signal (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                     NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                     "org.freedesktop.DBus.Properties",
                                     "PropertiesChanged",
                                     g_variant_new ("(sa{sv}as)",
                                                    "com.acme.Coyote",
                                                    &builder, &invalidated_builder),
                                     NULL);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (skeleton->priv->lock);
  return FALSE;
}

static void
_foo_com_acme_coyote_schedule_emit_changed (FooComAcmeCoyoteSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
foo_com_acme_coyote_skeleton_notify (GObject      *object,
  GParamSpec *pspec)
{
  FooComAcmeCoyoteSkeleton *skeleton = FOO_COM_ACME_COYOTE_SKELETON (object);
  g_mutex_lock (skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _foo_com_acme_coyote_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (skeleton->priv->lock);
}

static void
foo_com_acme_coyote_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  FooComAcmeCoyoteSkeleton *skeleton = FOO_COM_ACME_COYOTE_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  g_mutex_lock (skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties->values[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _foo_com_acme_coyote_schedule_emit_changed (skeleton, _foo_com_acme_coyote_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties->values[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties->values[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
foo_com_acme_coyote_skeleton_init (FooComAcmeCoyoteSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_TYPE_COM_ACME_COYOTE_SKELETON, FooComAcmeCoyoteSkeletonPrivate);
  skeleton->priv->lock = g_mutex_new ();
  skeleton->priv->context = g_main_context_get_thread_default ();
  if (skeleton->priv->context != NULL)
    g_main_context_ref (skeleton->priv->context);
  skeleton->priv->properties = g_value_array_new (1);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[0], G_TYPE_STRING);
}

static void
foo_com_acme_coyote_skeleton_class_init (FooComAcmeCoyoteSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (FooComAcmeCoyoteSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_com_acme_coyote_skeleton_finalize;
  gobject_class->get_property = foo_com_acme_coyote_skeleton_get_property;
  gobject_class->set_property = foo_com_acme_coyote_skeleton_set_property;
  gobject_class->notify       = foo_com_acme_coyote_skeleton_notify;


  foo_com_acme_coyote_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_com_acme_coyote_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_com_acme_coyote_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_com_acme_coyote_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_com_acme_coyote_skeleton_dbus_interface_get_vtable;
}

/**
 * foo_com_acme_coyote_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link>.
 *
 * Returns: (transfer full) (type FooComAcmeCoyoteSkeleton): The skeleton object.
 */
FooComAcmeCoyote *
foo_com_acme_coyote_skeleton_new (void)
{
  return FOO_COM_ACME_COYOTE (g_object_new (FOO_TYPE_COM_ACME_COYOTE_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface com.acme.Rocket
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooRocket123
 * @title: FooRocket123
 * @short_description: Generated C code for the com.acme.Rocket D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link> D-Bus interface in C.
 */

/* ---- Introspection data for com.acme.Rocket ---- */

static const _ExtendedGDBusMethodInfo _foo_rocket123_method_info_ignite_xyz =
{
  {
    -1,
    "Ignite",
    NULL,
    NULL,
    NULL
  },
  "handle-ignite-xyz",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_rocket123_method_info_pointers[] =
{
  &_foo_rocket123_method_info_ignite_xyz,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_rocket123_signal_info_exploded_xyz =
{
  {
    -1,
    "Exploded",
    NULL,
    NULL
  },
  "exploded-xyz"
};

static const _ExtendedGDBusSignalInfo * const _foo_rocket123_signal_info_pointers[] =
{
  &_foo_rocket123_signal_info_exploded_xyz,
  NULL
};

static const _ExtendedGDBusPropertyInfo _foo_rocket123_property_info_speed_xyz =
{
  {
    -1,
    "Speed",
    "d",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "speed-xyz",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_rocket123_property_info_direction =
{
  {
    -1,
    "Direction",
    "(ddd)",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "direction",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_rocket123_property_info_type_ =
{
  {
    -1,
    "Type",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "type-",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _foo_rocket123_property_info_pointers[] =
{
  &_foo_rocket123_property_info_speed_xyz,
  &_foo_rocket123_property_info_direction,
  &_foo_rocket123_property_info_type_,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_rocket123_interface_info =
{
  {
    -1,
    "com.acme.Rocket",
    (GDBusMethodInfo **) &_foo_rocket123_method_info_pointers,
    (GDBusSignalInfo **) &_foo_rocket123_signal_info_pointers,
    (GDBusPropertyInfo **) &_foo_rocket123_property_info_pointers,
    NULL
  },
  "rocket123",
};


/**
 * foo_rocket123_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_rocket123_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_rocket123_interface_info;
}

/**
 * foo_rocket123_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooRocket123 interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_rocket123_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "speed-xyz");
  g_object_class_override_property (klass, property_id_begin++, "direction");
  g_object_class_override_property (klass, property_id_begin++, "type-");
  return property_id_begin - 1;
}



/**
 * FooRocket123:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link>.
 */

/**
 * FooRocket123Iface:
 * @parent_iface: The parent interface.
 * @handle_ignite_xyz: Handler for the #FooRocket123::handle-ignite-xyz signal.
 * @exploded_xyz: Handler for the #FooRocket123::exploded-xyz signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link>.
 */

static void
foo_rocket123_default_init (FooRocket123Iface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooRocket123::handle-ignite-xyz:
   * @object: A #FooRocket123.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-acme-Rocket.Ignite">Ignite()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_rocket123_complete_ignite_xyz() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-ignite-xyz",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooRocket123Iface, handle_ignite_xyz),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooRocket123::exploded-xyz:
   * @object: A #FooRocket123.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-com-acme-Rocket.Exploded">"Exploded"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("exploded-xyz",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooRocket123Iface, exploded_xyz),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /* GObject properties for D-Bus properties: */
  /**
   * FooRocket123:speed-xyz:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-com-acme-Rocket.Speed">"Speed"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_double ("speed-xyz", "Speed", "Speed", -G_MAXDOUBLE, G_MAXDOUBLE, 0.0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooRocket123:direction:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-com-acme-Rocket.Direction">"Direction"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("direction", "Direction", "Direction", G_VARIANT_TYPE ("(ddd)"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooRocket123:type-:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-com-acme-Rocket.Type">"Type"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("type-", "Type", "Type", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

typedef FooRocket123Iface FooRocket123Interface;
G_DEFINE_INTERFACE (FooRocket123, foo_rocket123, G_TYPE_OBJECT);

/**
 * foo_rocket123_get_speed_xyz:
 * @object: A #FooRocket123.
 *
 * Gets the value of the <link linkend="gdbus-property-com-acme-Rocket.Speed">"Speed"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
gdouble 
foo_rocket123_get_speed_xyz (FooRocket123 *object)
{
  gdouble value;
  g_object_get (G_OBJECT (object), "speed-xyz", &value, NULL);
  return value;
}

/**
 * foo_rocket123_set_speed_xyz:
 * @object: A #FooRocket123.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-com-acme-Rocket.Speed">"Speed"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_rocket123_set_speed_xyz (FooRocket123 *object, gdouble value)
{
  g_object_set (G_OBJECT (object), "speed-xyz", value, NULL);
}

/**
 * foo_rocket123_get_direction:
 * @object: A #FooRocket123.
 *
 * Gets the value of the <link linkend="gdbus-property-com-acme-Rocket.Direction">"Direction"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
GVariant *
foo_rocket123_get_direction (FooRocket123 *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "direction", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-direction", (gpointer) value, (GDestroyNotify) g_variant_unref);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-direction", (gpointer) value, NULL);
  return value;
}

/**
 * foo_rocket123_set_direction:
 * @object: A #FooRocket123.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-com-acme-Rocket.Direction">"Direction"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_rocket123_set_direction (FooRocket123 *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "direction", value, NULL);
}

/**
 * foo_rocket123_get_type_:
 * @object: A #FooRocket123.
 *
 * Gets the value of the <link linkend="gdbus-property-com-acme-Rocket.Type">"Type"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
const gchar *
foo_rocket123_get_type_ (FooRocket123 *object)
{
  const gchar *value;
  g_object_get (G_OBJECT (object), "type-", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-type-", (gpointer) value, (GDestroyNotify) g_free);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-type-", (gpointer) value, NULL);
  return value;
}

/**
 * foo_rocket123_set_type_:
 * @object: A #FooRocket123.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-com-acme-Rocket.Type">"Type"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_rocket123_set_type_ (FooRocket123 *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "type-", value, NULL);
}

/**
 * foo_rocket123_emit_exploded_xyz:
 * @object: A #FooRocket123.
 *
 * Emits the <link linkend="gdbus-signal-com-acme-Rocket.Exploded">"Exploded"</link> D-Bus signal.
 */
void
foo_rocket123_emit_exploded_xyz (
    FooRocket123 *object)
{
  g_signal_emit_by_name (object, "exploded-xyz");
}

/**
 * foo_rocket123_call_ignite_xyz:
 * @proxy: A #FooRocket123Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-com-acme-Rocket.Ignite">Ignite()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_rocket123_call_ignite_xyz_finish() to get the result of the operation.
 *
 * See foo_rocket123_call_ignite_xyz_sync() for the synchronous, blocking version of this method.
 */
void
foo_rocket123_call_ignite_xyz (
    FooRocket123 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Ignite",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_rocket123_call_ignite_xyz_finish:
 * @proxy: A #FooRocket123Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_rocket123_call_ignite_xyz().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_rocket123_call_ignite_xyz().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_rocket123_call_ignite_xyz_finish (
    FooRocket123 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_rocket123_call_ignite_xyz_sync:
 * @proxy: A #FooRocket123Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-com-acme-Rocket.Ignite">Ignite()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_rocket123_call_ignite_xyz() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_rocket123_call_ignite_xyz_sync (
    FooRocket123 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Ignite",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_rocket123_complete_ignite_xyz:
 * @object: A #FooRocket123.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-acme-Rocket.Ignite">Ignite()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_rocket123_complete_ignite_xyz (
    FooRocket123 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FooRocket123Proxy:
 *
 * The #FooRocket123Proxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooRocket123ProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooRocket123Proxy.
 */

static void
foo_rocket123_proxy_iface_init (FooRocket123Iface *iface)
{
}

#define foo_rocket123_proxy_get_type foo_rocket123_proxy_get_type
G_DEFINE_TYPE_WITH_CODE (FooRocket123Proxy, foo_rocket123_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_ROCKET123, foo_rocket123_proxy_iface_init));
#undef foo_rocket123_proxy_get_type

static void
foo_rocket123_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  info = _foo_rocket123_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
foo_rocket123_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  error = NULL;
  if (!g_dbus_proxy_call_finish (proxy, res, &error))
    {
      g_warning ("Error setting property `%s' on interface com.acme.Rocket: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
}

static void
foo_rocket123_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  info = _foo_rocket123_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "com.acme.Rocket", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) foo_rocket123_proxy_set_property_cb, (gpointer) info);
  g_variant_unref (variant);
}

static void
foo_rocket123_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_rocket123_interface_info, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_TYPE_ROCKET123);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_ROCKET123);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_rocket123_proxy_g_properties_changed (GDBusProxy *proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_rocket123_interface_info, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_rocket123_interface_info, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_rocket123_proxy_init (FooRocket123Proxy *proxy)
{
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_rocket123_interface_info ());
}

static void
foo_rocket123_proxy_class_init (FooRocket123ProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->get_property = foo_rocket123_proxy_get_property;
  gobject_class->set_property = foo_rocket123_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_rocket123_proxy_g_signal;
  proxy_class->g_properties_changed = foo_rocket123_proxy_g_properties_changed;


  foo_rocket123_override_properties (gobject_class, 1);
}

/**
 * foo_rocket123_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_rocket123_proxy_new_finish() to get the result of the operation.
 *
 * See foo_rocket123_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_rocket123_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_ROCKET123_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "com.acme.Rocket", NULL);
}

/**
 * foo_rocket123_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_rocket123_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_rocket123_proxy_new().
 *
 * Returns: (transfer full) (type FooRocket123Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooRocket123 *
foo_rocket123_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_ROCKET123 (ret);
  else
    return NULL;
}

/**
 * foo_rocket123_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_rocket123_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooRocket123Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooRocket123 *
foo_rocket123_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_ROCKET123_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "com.acme.Rocket", NULL);
  if (ret != NULL)
    return FOO_ROCKET123 (ret);
  else
    return NULL;
}


/**
 * foo_rocket123_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_rocket123_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_rocket123_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_rocket123_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_rocket123_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_ROCKET123_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "com.acme.Rocket", NULL);
}

/**
 * foo_rocket123_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_rocket123_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_rocket123_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooRocket123Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooRocket123 *
foo_rocket123_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_ROCKET123 (ret);
  else
    return NULL;
}

/**
 * foo_rocket123_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_rocket123_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_rocket123_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooRocket123Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooRocket123 *
foo_rocket123_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_ROCKET123_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "com.acme.Rocket", NULL);
  if (ret != NULL)
    return FOO_ROCKET123 (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooRocket123Skeleton:
 *
 * The #FooRocket123Skeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooRocket123SkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooRocket123Skeleton.
 */

struct _FooRocket123SkeletonPrivate
{
  GValueArray *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex *lock;
};

static void
_foo_rocket123_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooRocket123Skeleton *skeleton = FOO_ROCKET123_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = {0};
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_TYPE_ROCKET123);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
  {
    g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
    g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
  }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_ROCKET123);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_rocket123_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooRocket123Skeleton *skeleton = FOO_ROCKET123_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_rocket123_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_rocket123_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooRocket123Skeleton *skeleton = FOO_ROCKET123_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_rocket123_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_rocket123_skeleton_vtable =
{
  _foo_rocket123_skeleton_handle_method_call,
  _foo_rocket123_skeleton_handle_get_property,
  _foo_rocket123_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
foo_rocket123_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return foo_rocket123_interface_info ();
}

static GDBusInterfaceVTable *
foo_rocket123_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_foo_rocket123_skeleton_vtable;
}

static GVariant *
foo_rocket123_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooRocket123Skeleton *skeleton = FOO_ROCKET123_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_rocket123_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_rocket123_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_rocket123_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_rocket123_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "com.acme.Rocket", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _foo_rocket123_emit_changed (gpointer user_data);

static void
foo_rocket123_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  FooRocket123Skeleton *skeleton = FOO_ROCKET123_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (skeleton->priv->lock);

  if (emit_changed)
    _foo_rocket123_emit_changed (skeleton);
}

static void
_foo_rocket123_on_signal_exploded_xyz (
    FooRocket123 *object)
{
  FooRocket123Skeleton *skeleton = FOO_ROCKET123_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "com.acme.Rocket", "Exploded",
    g_variant_new ("()"), NULL);
}

static void
foo_rocket123_skeleton_iface_init (FooRocket123Iface *iface)
{
  iface->exploded_xyz = _foo_rocket123_on_signal_exploded_xyz;
}

#define foo_rocket123_skeleton_get_type foo_rocket123_skeleton_get_type
G_DEFINE_TYPE_WITH_CODE (FooRocket123Skeleton, foo_rocket123_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_ROCKET123, foo_rocket123_skeleton_iface_init));
#undef foo_rocket123_skeleton_get_type

static void
foo_rocket123_skeleton_finalize (GObject *object)
{
  FooRocket123Skeleton *skeleton = FOO_ROCKET123_SKELETON (object);
  g_value_array_free (skeleton->priv->properties);
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  if (skeleton->priv->context != NULL)
    g_main_context_unref (skeleton->priv->context);
  g_mutex_free (skeleton->priv->lock);
  G_OBJECT_CLASS (foo_rocket123_skeleton_parent_class)->finalize (object);
}

static void
foo_rocket123_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  FooRocket123Skeleton *skeleton = FOO_ROCKET123_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  g_mutex_lock (skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties->values[prop_id - 1], value);
  g_mutex_unlock (skeleton->priv->lock);
}

static gboolean
_foo_rocket123_emit_changed (gpointer user_data)
{
  FooRocket123Skeleton *skeleton = FOO_ROCKET123_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties->values[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      g_dbus_connection_emit_signal (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                     NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                     "org.freedesktop.DBus.Properties",
                                     "PropertiesChanged",
                                     g_variant_new ("(sa{sv}as)",
                                                    "com.acme.Rocket",
                                                    &builder, &invalidated_builder),
                                     NULL);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (skeleton->priv->lock);
  return FALSE;
}

static void
_foo_rocket123_schedule_emit_changed (FooRocket123Skeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
foo_rocket123_skeleton_notify (GObject      *object,
  GParamSpec *pspec)
{
  FooRocket123Skeleton *skeleton = FOO_ROCKET123_SKELETON (object);
  g_mutex_lock (skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _foo_rocket123_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (skeleton->priv->lock);
}

static void
foo_rocket123_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  FooRocket123Skeleton *skeleton = FOO_ROCKET123_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 3);
  g_mutex_lock (skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties->values[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _foo_rocket123_schedule_emit_changed (skeleton, _foo_rocket123_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties->values[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties->values[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
foo_rocket123_skeleton_init (FooRocket123Skeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_TYPE_ROCKET123_SKELETON, FooRocket123SkeletonPrivate);
  skeleton->priv->lock = g_mutex_new ();
  skeleton->priv->context = g_main_context_get_thread_default ();
  if (skeleton->priv->context != NULL)
    g_main_context_ref (skeleton->priv->context);
  skeleton->priv->properties = g_value_array_new (3);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[0], G_TYPE_DOUBLE);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[1], G_TYPE_VARIANT);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[2], G_TYPE_STRING);
}

static void
foo_rocket123_skeleton_class_init (FooRocket123SkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (FooRocket123SkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_rocket123_skeleton_finalize;
  gobject_class->get_property = foo_rocket123_skeleton_get_property;
  gobject_class->set_property = foo_rocket123_skeleton_set_property;
  gobject_class->notify       = foo_rocket123_skeleton_notify;


  foo_rocket123_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_rocket123_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_rocket123_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_rocket123_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_rocket123_skeleton_dbus_interface_get_vtable;
}

/**
 * foo_rocket123_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link>.
 *
 * Returns: (transfer full) (type FooRocket123Skeleton): The skeleton object.
 */
FooRocket123 *
foo_rocket123_skeleton_new (void)
{
  return FOO_ROCKET123 (g_object_new (FOO_TYPE_ROCKET123_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.project.Bat
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooBat
 * @title: FooBat
 * @short_description: Generated C code for the org.project.Bat D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.project.Bat ---- */

static const _ExtendedGDBusArgInfo _foo_bat_method_info_force_method_IN_ARG_force_in_i =
{
  {
    -1,
    "force_in_i",
    "i",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_bat_method_info_force_method_IN_ARG_force_in_s =
{
  {
    -1,
    "force_in_s",
    "s",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_bat_method_info_force_method_IN_ARG_force_in_ay =
{
  {
    -1,
    "force_in_ay",
    "ay",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_bat_method_info_force_method_IN_ARG_force_in_struct =
{
  {
    -1,
    "force_in_struct",
    "(i)",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo * const _foo_bat_method_info_force_method_IN_ARG_pointers[] =
{
  &_foo_bat_method_info_force_method_IN_ARG_force_in_i,
  &_foo_bat_method_info_force_method_IN_ARG_force_in_s,
  &_foo_bat_method_info_force_method_IN_ARG_force_in_ay,
  &_foo_bat_method_info_force_method_IN_ARG_force_in_struct,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_bat_method_info_force_method_OUT_ARG_force_out_i =
{
  {
    -1,
    "force_out_i",
    "i",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_bat_method_info_force_method_OUT_ARG_force_out_s =
{
  {
    -1,
    "force_out_s",
    "s",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_bat_method_info_force_method_OUT_ARG_force_out_ay =
{
  {
    -1,
    "force_out_ay",
    "ay",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_bat_method_info_force_method_OUT_ARG_force_out_struct =
{
  {
    -1,
    "force_out_struct",
    "(i)",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo * const _foo_bat_method_info_force_method_OUT_ARG_pointers[] =
{
  &_foo_bat_method_info_force_method_OUT_ARG_force_out_i,
  &_foo_bat_method_info_force_method_OUT_ARG_force_out_s,
  &_foo_bat_method_info_force_method_OUT_ARG_force_out_ay,
  &_foo_bat_method_info_force_method_OUT_ARG_force_out_struct,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_bat_method_info_force_method =
{
  {
    -1,
    "ForceMethod",
    (GDBusArgInfo **) &_foo_bat_method_info_force_method_IN_ARG_pointers,
    (GDBusArgInfo **) &_foo_bat_method_info_force_method_OUT_ARG_pointers,
    NULL
  },
  "handle-force-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_bat_method_info_pointers[] =
{
  &_foo_bat_method_info_force_method,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_bat_signal_info_force_signal_ARG_force_i =
{
  {
    -1,
    "force_i",
    "i",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_bat_signal_info_force_signal_ARG_force_s =
{
  {
    -1,
    "force_s",
    "s",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_bat_signal_info_force_signal_ARG_force_ay =
{
  {
    -1,
    "force_ay",
    "ay",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo _foo_bat_signal_info_force_signal_ARG_force_struct =
{
  {
    -1,
    "force_struct",
    "(i)",
    NULL
  },
  TRUE
};

static const _ExtendedGDBusArgInfo * const _foo_bat_signal_info_force_signal_ARG_pointers[] =
{
  &_foo_bat_signal_info_force_signal_ARG_force_i,
  &_foo_bat_signal_info_force_signal_ARG_force_s,
  &_foo_bat_signal_info_force_signal_ARG_force_ay,
  &_foo_bat_signal_info_force_signal_ARG_force_struct,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_bat_signal_info_force_signal =
{
  {
    -1,
    "ForceSignal",
    (GDBusArgInfo **) &_foo_bat_signal_info_force_signal_ARG_pointers,
    NULL
  },
  "force-signal"
};

static const _ExtendedGDBusSignalInfo * const _foo_bat_signal_info_pointers[] =
{
  &_foo_bat_signal_info_force_signal,
  NULL
};

static const _ExtendedGDBusPropertyInfo _foo_bat_property_info_force_i =
{
  {
    -1,
    "force_i",
    "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "force-i",
  TRUE
};

static const _ExtendedGDBusPropertyInfo _foo_bat_property_info_force_s =
{
  {
    -1,
    "force_s",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "force-s",
  TRUE
};

static const _ExtendedGDBusPropertyInfo _foo_bat_property_info_force_ay =
{
  {
    -1,
    "force_ay",
    "ay",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "force-ay",
  TRUE
};

static const _ExtendedGDBusPropertyInfo _foo_bat_property_info_force_struct =
{
  {
    -1,
    "force_struct",
    "(i)",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "force-struct",
  TRUE
};

static const _ExtendedGDBusPropertyInfo * const _foo_bat_property_info_pointers[] =
{
  &_foo_bat_property_info_force_i,
  &_foo_bat_property_info_force_s,
  &_foo_bat_property_info_force_ay,
  &_foo_bat_property_info_force_struct,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_bat_interface_info =
{
  {
    -1,
    "org.project.Bat",
    (GDBusMethodInfo **) &_foo_bat_method_info_pointers,
    (GDBusSignalInfo **) &_foo_bat_signal_info_pointers,
    (GDBusPropertyInfo **) &_foo_bat_property_info_pointers,
    NULL
  },
  "bat",
};


/**
 * foo_bat_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_bat_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_bat_interface_info;
}

/**
 * foo_bat_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooBat interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_bat_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "force-i");
  g_object_class_override_property (klass, property_id_begin++, "force-s");
  g_object_class_override_property (klass, property_id_begin++, "force-ay");
  g_object_class_override_property (klass, property_id_begin++, "force-struct");
  return property_id_begin - 1;
}



/**
 * FooBat:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link>.
 */

/**
 * FooBatIface:
 * @parent_iface: The parent interface.
 * @handle_force_method: Handler for the #FooBat::handle-force-method signal.
 * @force_signal: Handler for the #FooBat::force-signal signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link>.
 */

static void
foo_bat_default_init (FooBatIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooBat::handle-force-method:
   * @object: A #FooBat.
   * @invocation: A #GDBusMethodInvocation.
   * @force_in_i: Argument passed by remote caller.
   * @force_in_s: Argument passed by remote caller.
   * @force_in_ay: Argument passed by remote caller.
   * @force_in_struct: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Bat.ForceMethod">ForceMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_bat_complete_force_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-force-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooBatIface, handle_force_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    5,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_VARIANT, G_TYPE_VARIANT, G_TYPE_VARIANT, G_TYPE_VARIANT);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooBat::force-signal:
   * @object: A #FooBat.
   * @force_i: Argument.
   * @force_s: Argument.
   * @force_ay: Argument.
   * @force_struct: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-project-Bat.ForceSignal">"ForceSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("force-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooBatIface, force_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    4, G_TYPE_VARIANT, G_TYPE_VARIANT, G_TYPE_VARIANT, G_TYPE_VARIANT);

  /* GObject properties for D-Bus properties: */
  /**
   * FooBat:force-i:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bat.force_i">"force_i"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("force-i", "force_i", "force_i", G_VARIANT_TYPE ("i"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBat:force-s:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bat.force_s">"force_s"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("force-s", "force_s", "force_s", G_VARIANT_TYPE ("s"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBat:force-ay:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bat.force_ay">"force_ay"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("force-ay", "force_ay", "force_ay", G_VARIANT_TYPE ("ay"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooBat:force-struct:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-Bat.force_struct">"force_struct"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_variant ("force-struct", "force_struct", "force_struct", G_VARIANT_TYPE ("(i)"), NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

typedef FooBatIface FooBatInterface;
G_DEFINE_INTERFACE (FooBat, foo_bat, G_TYPE_OBJECT);

/**
 * foo_bat_get_force_i:
 * @object: A #FooBat.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bat.force_i">"force_i"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
GVariant *
foo_bat_get_force_i (FooBat *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "force-i", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-force-i", (gpointer) value, (GDestroyNotify) g_variant_unref);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-force-i", (gpointer) value, NULL);
  return value;
}

/**
 * foo_bat_set_force_i:
 * @object: A #FooBat.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bat.force_i">"force_i"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bat_set_force_i (FooBat *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "force-i", value, NULL);
}

/**
 * foo_bat_get_force_s:
 * @object: A #FooBat.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bat.force_s">"force_s"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
GVariant *
foo_bat_get_force_s (FooBat *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "force-s", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-force-s", (gpointer) value, (GDestroyNotify) g_variant_unref);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-force-s", (gpointer) value, NULL);
  return value;
}

/**
 * foo_bat_set_force_s:
 * @object: A #FooBat.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bat.force_s">"force_s"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bat_set_force_s (FooBat *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "force-s", value, NULL);
}

/**
 * foo_bat_get_force_ay:
 * @object: A #FooBat.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bat.force_ay">"force_ay"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
GVariant *
foo_bat_get_force_ay (FooBat *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "force-ay", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-force-ay", (gpointer) value, (GDestroyNotify) g_variant_unref);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-force-ay", (gpointer) value, NULL);
  return value;
}

/**
 * foo_bat_set_force_ay:
 * @object: A #FooBat.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bat.force_ay">"force_ay"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bat_set_force_ay (FooBat *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "force-ay", value, NULL);
}

/**
 * foo_bat_get_force_struct:
 * @object: A #FooBat.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-Bat.force_struct">"force_struct"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
GVariant *
foo_bat_get_force_struct (FooBat *object)
{
  GVariant *value;
  g_object_get (G_OBJECT (object), "force-struct", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-force-struct", (gpointer) value, (GDestroyNotify) g_variant_unref);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-force-struct", (gpointer) value, NULL);
  return value;
}

/**
 * foo_bat_set_force_struct:
 * @object: A #FooBat.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-Bat.force_struct">"force_struct"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_bat_set_force_struct (FooBat *object, GVariant *value)
{
  g_object_set (G_OBJECT (object), "force-struct", value, NULL);
}

/**
 * foo_bat_emit_force_signal:
 * @object: A #FooBat.
 * @force_i: Argument to pass with the signal.
 * @force_s: Argument to pass with the signal.
 * @force_ay: Argument to pass with the signal.
 * @force_struct: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-org-project-Bat.ForceSignal">"ForceSignal"</link> D-Bus signal.
 */
void
foo_bat_emit_force_signal (
    FooBat *object,
    GVariant *force_i,
    GVariant *force_s,
    GVariant *force_ay,
    GVariant *force_struct)
{
  g_signal_emit_by_name (object, "force-signal", force_i, force_s, force_ay, force_struct);
}

/**
 * foo_bat_call_force_method:
 * @proxy: A #FooBatProxy.
 * @force_in_i: Argument to pass with the method invocation.
 * @force_in_s: Argument to pass with the method invocation.
 * @force_in_ay: Argument to pass with the method invocation.
 * @force_in_struct: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Bat.ForceMethod">ForceMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_bat_call_force_method_finish() to get the result of the operation.
 *
 * See foo_bat_call_force_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_bat_call_force_method (
    FooBat *proxy,
    GVariant *force_in_i,
    GVariant *force_in_s,
    GVariant *force_in_ay,
    GVariant *force_in_struct,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "ForceMethod",
    g_variant_new ("(@i@s@ay@(i))",
                   force_in_i,
                   force_in_s,
                   force_in_ay,
                   force_in_struct),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_bat_call_force_method_finish:
 * @proxy: A #FooBatProxy.
 * @out_force_out_i: (out): Return location for return parameter or %NULL to ignore.
 * @out_force_out_s: (out): Return location for return parameter or %NULL to ignore.
 * @out_force_out_ay: (out): Return location for return parameter or %NULL to ignore.
 * @out_force_out_struct: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_bat_call_force_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_bat_call_force_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_bat_call_force_method_finish (
    FooBat *proxy,
    GVariant **out_force_out_i,
    GVariant **out_force_out_s,
    GVariant **out_force_out_ay,
    GVariant **out_force_out_struct,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(@i@s@ay@(i))",
                 out_force_out_i,
                 out_force_out_s,
                 out_force_out_ay,
                 out_force_out_struct);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_bat_call_force_method_sync:
 * @proxy: A #FooBatProxy.
 * @force_in_i: Argument to pass with the method invocation.
 * @force_in_s: Argument to pass with the method invocation.
 * @force_in_ay: Argument to pass with the method invocation.
 * @force_in_struct: Argument to pass with the method invocation.
 * @out_force_out_i: (out): Return location for return parameter or %NULL to ignore.
 * @out_force_out_s: (out): Return location for return parameter or %NULL to ignore.
 * @out_force_out_ay: (out): Return location for return parameter or %NULL to ignore.
 * @out_force_out_struct: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Bat.ForceMethod">ForceMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_bat_call_force_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_bat_call_force_method_sync (
    FooBat *proxy,
    GVariant *force_in_i,
    GVariant *force_in_s,
    GVariant *force_in_ay,
    GVariant *force_in_struct,
    GVariant **out_force_out_i,
    GVariant **out_force_out_s,
    GVariant **out_force_out_ay,
    GVariant **out_force_out_struct,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "ForceMethod",
    g_variant_new ("(@i@s@ay@(i))",
                   force_in_i,
                   force_in_s,
                   force_in_ay,
                   force_in_struct),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(@i@s@ay@(i))",
                 out_force_out_i,
                 out_force_out_s,
                 out_force_out_ay,
                 out_force_out_struct);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_bat_complete_force_method:
 * @object: A #FooBat.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @force_out_i: Parameter to return.
 * @force_out_s: Parameter to return.
 * @force_out_ay: Parameter to return.
 * @force_out_struct: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Bat.ForceMethod">ForceMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_bat_complete_force_method (
    FooBat *object,
    GDBusMethodInvocation *invocation,
    GVariant *force_out_i,
    GVariant *force_out_s,
    GVariant *force_out_ay,
    GVariant *force_out_struct)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(@i@s@ay@(i))",
                   force_out_i,
                   force_out_s,
                   force_out_ay,
                   force_out_struct));
}

/* ------------------------------------------------------------------------ */

/**
 * FooBatProxy:
 *
 * The #FooBatProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooBatProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooBatProxy.
 */

static void
foo_bat_proxy_iface_init (FooBatIface *iface)
{
}

#define foo_bat_proxy_get_type foo_bat_proxy_get_type
G_DEFINE_TYPE_WITH_CODE (FooBatProxy, foo_bat_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_BAT, foo_bat_proxy_iface_init));
#undef foo_bat_proxy_get_type

static void
foo_bat_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 4);
  info = _foo_bat_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
foo_bat_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  error = NULL;
  if (!g_dbus_proxy_call_finish (proxy, res, &error))
    {
      g_warning ("Error setting property `%s' on interface org.project.Bat: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
}

static void
foo_bat_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 4);
  info = _foo_bat_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.project.Bat", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) foo_bat_proxy_set_property_cb, (gpointer) info);
  g_variant_unref (variant);
}

static void
foo_bat_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_bat_interface_info, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_TYPE_BAT);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_BAT);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_bat_proxy_g_properties_changed (GDBusProxy *proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_bat_interface_info, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_bat_interface_info, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_bat_proxy_init (FooBatProxy *proxy)
{
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_bat_interface_info ());
}

static void
foo_bat_proxy_class_init (FooBatProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->get_property = foo_bat_proxy_get_property;
  gobject_class->set_property = foo_bat_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_bat_proxy_g_signal;
  proxy_class->g_properties_changed = foo_bat_proxy_g_properties_changed;


  foo_bat_override_properties (gobject_class, 1);
}

/**
 * foo_bat_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_bat_proxy_new_finish() to get the result of the operation.
 *
 * See foo_bat_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_bat_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_BAT_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Bat", NULL);
}

/**
 * foo_bat_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_bat_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_bat_proxy_new().
 *
 * Returns: (transfer full) (type FooBatProxy): The constructed proxy object or %NULL if @error is set.
 */
FooBat *
foo_bat_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_BAT (ret);
  else
    return NULL;
}

/**
 * foo_bat_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_bat_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooBatProxy): The constructed proxy object or %NULL if @error is set.
 */
FooBat *
foo_bat_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_BAT_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Bat", NULL);
  if (ret != NULL)
    return FOO_BAT (ret);
  else
    return NULL;
}


/**
 * foo_bat_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_bat_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_bat_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_bat_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_bat_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_BAT_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Bat", NULL);
}

/**
 * foo_bat_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_bat_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_bat_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooBatProxy): The constructed proxy object or %NULL if @error is set.
 */
FooBat *
foo_bat_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_BAT (ret);
  else
    return NULL;
}

/**
 * foo_bat_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_bat_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_bat_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooBatProxy): The constructed proxy object or %NULL if @error is set.
 */
FooBat *
foo_bat_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_BAT_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Bat", NULL);
  if (ret != NULL)
    return FOO_BAT (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooBatSkeleton:
 *
 * The #FooBatSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooBatSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooBatSkeleton.
 */

struct _FooBatSkeletonPrivate
{
  GValueArray *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex *lock;
};

static void
_foo_bat_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooBatSkeleton *skeleton = FOO_BAT_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = {0};
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_TYPE_BAT);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
  {
    g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
    g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
  }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_BAT);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_bat_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooBatSkeleton *skeleton = FOO_BAT_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_bat_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_bat_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooBatSkeleton *skeleton = FOO_BAT_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_bat_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_bat_skeleton_vtable =
{
  _foo_bat_skeleton_handle_method_call,
  _foo_bat_skeleton_handle_get_property,
  _foo_bat_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
foo_bat_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return foo_bat_interface_info ();
}

static GDBusInterfaceVTable *
foo_bat_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_foo_bat_skeleton_vtable;
}

static GVariant *
foo_bat_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooBatSkeleton *skeleton = FOO_BAT_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_bat_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_bat_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_bat_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_bat_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.Bat", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _foo_bat_emit_changed (gpointer user_data);

static void
foo_bat_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  FooBatSkeleton *skeleton = FOO_BAT_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (skeleton->priv->lock);

  if (emit_changed)
    _foo_bat_emit_changed (skeleton);
}

static void
_foo_bat_on_signal_force_signal (
    FooBat *object,
    GVariant *force_i,
    GVariant *force_s,
    GVariant *force_ay,
    GVariant *force_struct)
{
  FooBatSkeleton *skeleton = FOO_BAT_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.Bat", "ForceSignal",
    g_variant_new ("(@i@s@ay@(i))",
                   force_i,
                   force_s,
                   force_ay,
                   force_struct), NULL);
}

static void
foo_bat_skeleton_iface_init (FooBatIface *iface)
{
  iface->force_signal = _foo_bat_on_signal_force_signal;
}

#define foo_bat_skeleton_get_type foo_bat_skeleton_get_type
G_DEFINE_TYPE_WITH_CODE (FooBatSkeleton, foo_bat_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_BAT, foo_bat_skeleton_iface_init));
#undef foo_bat_skeleton_get_type

static void
foo_bat_skeleton_finalize (GObject *object)
{
  FooBatSkeleton *skeleton = FOO_BAT_SKELETON (object);
  g_value_array_free (skeleton->priv->properties);
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  if (skeleton->priv->context != NULL)
    g_main_context_unref (skeleton->priv->context);
  g_mutex_free (skeleton->priv->lock);
  G_OBJECT_CLASS (foo_bat_skeleton_parent_class)->finalize (object);
}

static void
foo_bat_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  FooBatSkeleton *skeleton = FOO_BAT_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 4);
  g_mutex_lock (skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties->values[prop_id - 1], value);
  g_mutex_unlock (skeleton->priv->lock);
}

static gboolean
_foo_bat_emit_changed (gpointer user_data)
{
  FooBatSkeleton *skeleton = FOO_BAT_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties->values[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      g_dbus_connection_emit_signal (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                     NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                     "org.freedesktop.DBus.Properties",
                                     "PropertiesChanged",
                                     g_variant_new ("(sa{sv}as)",
                                                    "org.project.Bat",
                                                    &builder, &invalidated_builder),
                                     NULL);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (skeleton->priv->lock);
  return FALSE;
}

static void
_foo_bat_schedule_emit_changed (FooBatSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
foo_bat_skeleton_notify (GObject      *object,
  GParamSpec *pspec)
{
  FooBatSkeleton *skeleton = FOO_BAT_SKELETON (object);
  g_mutex_lock (skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _foo_bat_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (skeleton->priv->lock);
}

static void
foo_bat_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  FooBatSkeleton *skeleton = FOO_BAT_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 4);
  g_mutex_lock (skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties->values[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _foo_bat_schedule_emit_changed (skeleton, _foo_bat_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties->values[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties->values[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
foo_bat_skeleton_init (FooBatSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_TYPE_BAT_SKELETON, FooBatSkeletonPrivate);
  skeleton->priv->lock = g_mutex_new ();
  skeleton->priv->context = g_main_context_get_thread_default ();
  if (skeleton->priv->context != NULL)
    g_main_context_ref (skeleton->priv->context);
  skeleton->priv->properties = g_value_array_new (4);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[0], G_TYPE_VARIANT);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[1], G_TYPE_VARIANT);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[2], G_TYPE_VARIANT);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[3], G_TYPE_VARIANT);
}

static void
foo_bat_skeleton_class_init (FooBatSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (FooBatSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_bat_skeleton_finalize;
  gobject_class->get_property = foo_bat_skeleton_get_property;
  gobject_class->set_property = foo_bat_skeleton_set_property;
  gobject_class->notify       = foo_bat_skeleton_notify;


  foo_bat_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_bat_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_bat_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_bat_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_bat_skeleton_dbus_interface_get_vtable;
}

/**
 * foo_bat_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link>.
 *
 * Returns: (transfer full) (type FooBatSkeleton): The skeleton object.
 */
FooBat *
foo_bat_skeleton_new (void)
{
  return FOO_BAT (g_object_new (FOO_TYPE_BAT_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.project.Authorize
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooAuthorize
 * @title: FooAuthorize
 * @short_description: Generated C code for the org.project.Authorize D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.project.Authorize ---- */

static const _ExtendedGDBusMethodInfo _foo_authorize_method_info_check_not_authorized =
{
  {
    -1,
    "CheckNotAuthorized",
    NULL,
    NULL,
    NULL
  },
  "handle-check-not-authorized",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_authorize_method_info_check_authorized =
{
  {
    -1,
    "CheckAuthorized",
    NULL,
    NULL,
    NULL
  },
  "handle-check-authorized",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_authorize_method_info_check_not_authorized_from_object =
{
  {
    -1,
    "CheckNotAuthorizedFromObject",
    NULL,
    NULL,
    NULL
  },
  "handle-check-not-authorized-from-object",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_authorize_method_info_pointers[] =
{
  &_foo_authorize_method_info_check_not_authorized,
  &_foo_authorize_method_info_check_authorized,
  &_foo_authorize_method_info_check_not_authorized_from_object,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_authorize_interface_info =
{
  {
    -1,
    "org.project.Authorize",
    (GDBusMethodInfo **) &_foo_authorize_method_info_pointers,
    NULL,
    NULL,
    NULL
  },
  "authorize",
};


/**
 * foo_authorize_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_authorize_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_authorize_interface_info;
}



/**
 * FooAuthorize:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link>.
 */

/**
 * FooAuthorizeIface:
 * @parent_iface: The parent interface.
 * @handle_check_authorized: Handler for the #FooAuthorize::handle-check-authorized signal.
 * @handle_check_not_authorized: Handler for the #FooAuthorize::handle-check-not-authorized signal.
 * @handle_check_not_authorized_from_object: Handler for the #FooAuthorize::handle-check-not-authorized-from-object signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link>.
 */

static void
foo_authorize_default_init (FooAuthorizeIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooAuthorize::handle-check-not-authorized:
   * @object: A #FooAuthorize.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Authorize.CheckNotAuthorized">CheckNotAuthorized()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_authorize_complete_check_not_authorized() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-check-not-authorized",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooAuthorizeIface, handle_check_not_authorized),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooAuthorize::handle-check-authorized:
   * @object: A #FooAuthorize.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Authorize.CheckAuthorized">CheckAuthorized()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_authorize_complete_check_authorized() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-check-authorized",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooAuthorizeIface, handle_check_authorized),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooAuthorize::handle-check-not-authorized-from-object:
   * @object: A #FooAuthorize.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-Authorize.CheckNotAuthorizedFromObject">CheckNotAuthorizedFromObject()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_authorize_complete_check_not_authorized_from_object() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-check-not-authorized-from-object",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooAuthorizeIface, handle_check_not_authorized_from_object),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

}

typedef FooAuthorizeIface FooAuthorizeInterface;
G_DEFINE_INTERFACE (FooAuthorize, foo_authorize, G_TYPE_OBJECT);

/**
 * foo_authorize_call_check_not_authorized:
 * @proxy: A #FooAuthorizeProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Authorize.CheckNotAuthorized">CheckNotAuthorized()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_authorize_call_check_not_authorized_finish() to get the result of the operation.
 *
 * See foo_authorize_call_check_not_authorized_sync() for the synchronous, blocking version of this method.
 */
void
foo_authorize_call_check_not_authorized (
    FooAuthorize *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "CheckNotAuthorized",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_authorize_call_check_not_authorized_finish:
 * @proxy: A #FooAuthorizeProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_authorize_call_check_not_authorized().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_authorize_call_check_not_authorized().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_authorize_call_check_not_authorized_finish (
    FooAuthorize *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_authorize_call_check_not_authorized_sync:
 * @proxy: A #FooAuthorizeProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Authorize.CheckNotAuthorized">CheckNotAuthorized()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_authorize_call_check_not_authorized() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_authorize_call_check_not_authorized_sync (
    FooAuthorize *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "CheckNotAuthorized",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_authorize_call_check_authorized:
 * @proxy: A #FooAuthorizeProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Authorize.CheckAuthorized">CheckAuthorized()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_authorize_call_check_authorized_finish() to get the result of the operation.
 *
 * See foo_authorize_call_check_authorized_sync() for the synchronous, blocking version of this method.
 */
void
foo_authorize_call_check_authorized (
    FooAuthorize *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "CheckAuthorized",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_authorize_call_check_authorized_finish:
 * @proxy: A #FooAuthorizeProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_authorize_call_check_authorized().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_authorize_call_check_authorized().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_authorize_call_check_authorized_finish (
    FooAuthorize *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_authorize_call_check_authorized_sync:
 * @proxy: A #FooAuthorizeProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Authorize.CheckAuthorized">CheckAuthorized()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_authorize_call_check_authorized() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_authorize_call_check_authorized_sync (
    FooAuthorize *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "CheckAuthorized",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_authorize_call_check_not_authorized_from_object:
 * @proxy: A #FooAuthorizeProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-Authorize.CheckNotAuthorizedFromObject">CheckNotAuthorizedFromObject()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_authorize_call_check_not_authorized_from_object_finish() to get the result of the operation.
 *
 * See foo_authorize_call_check_not_authorized_from_object_sync() for the synchronous, blocking version of this method.
 */
void
foo_authorize_call_check_not_authorized_from_object (
    FooAuthorize *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "CheckNotAuthorizedFromObject",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_authorize_call_check_not_authorized_from_object_finish:
 * @proxy: A #FooAuthorizeProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_authorize_call_check_not_authorized_from_object().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_authorize_call_check_not_authorized_from_object().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_authorize_call_check_not_authorized_from_object_finish (
    FooAuthorize *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_authorize_call_check_not_authorized_from_object_sync:
 * @proxy: A #FooAuthorizeProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-Authorize.CheckNotAuthorizedFromObject">CheckNotAuthorizedFromObject()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_authorize_call_check_not_authorized_from_object() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_authorize_call_check_not_authorized_from_object_sync (
    FooAuthorize *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "CheckNotAuthorizedFromObject",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_authorize_complete_check_not_authorized:
 * @object: A #FooAuthorize.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Authorize.CheckNotAuthorized">CheckNotAuthorized()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_authorize_complete_check_not_authorized (
    FooAuthorize *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_authorize_complete_check_authorized:
 * @object: A #FooAuthorize.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Authorize.CheckAuthorized">CheckAuthorized()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_authorize_complete_check_authorized (
    FooAuthorize *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_authorize_complete_check_not_authorized_from_object:
 * @object: A #FooAuthorize.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-Authorize.CheckNotAuthorizedFromObject">CheckNotAuthorizedFromObject()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_authorize_complete_check_not_authorized_from_object (
    FooAuthorize *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FooAuthorizeProxy:
 *
 * The #FooAuthorizeProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooAuthorizeProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooAuthorizeProxy.
 */

static void
foo_authorize_proxy_iface_init (FooAuthorizeIface *iface)
{
}

#define foo_authorize_proxy_get_type foo_authorize_proxy_get_type
G_DEFINE_TYPE_WITH_CODE (FooAuthorizeProxy, foo_authorize_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_AUTHORIZE, foo_authorize_proxy_iface_init));
#undef foo_authorize_proxy_get_type

static void
foo_authorize_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
}

static void
foo_authorize_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
}

static void
foo_authorize_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_authorize_interface_info, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_TYPE_AUTHORIZE);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_AUTHORIZE);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_authorize_proxy_g_properties_changed (GDBusProxy *proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_authorize_interface_info, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_authorize_interface_info, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_authorize_proxy_init (FooAuthorizeProxy *proxy)
{
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_authorize_interface_info ());
}

static void
foo_authorize_proxy_class_init (FooAuthorizeProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->get_property = foo_authorize_proxy_get_property;
  gobject_class->set_property = foo_authorize_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_authorize_proxy_g_signal;
  proxy_class->g_properties_changed = foo_authorize_proxy_g_properties_changed;

}

/**
 * foo_authorize_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_authorize_proxy_new_finish() to get the result of the operation.
 *
 * See foo_authorize_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_authorize_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_AUTHORIZE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Authorize", NULL);
}

/**
 * foo_authorize_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_authorize_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_authorize_proxy_new().
 *
 * Returns: (transfer full) (type FooAuthorizeProxy): The constructed proxy object or %NULL if @error is set.
 */
FooAuthorize *
foo_authorize_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_AUTHORIZE (ret);
  else
    return NULL;
}

/**
 * foo_authorize_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_authorize_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooAuthorizeProxy): The constructed proxy object or %NULL if @error is set.
 */
FooAuthorize *
foo_authorize_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_AUTHORIZE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.Authorize", NULL);
  if (ret != NULL)
    return FOO_AUTHORIZE (ret);
  else
    return NULL;
}


/**
 * foo_authorize_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_authorize_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_authorize_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_authorize_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_authorize_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_AUTHORIZE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Authorize", NULL);
}

/**
 * foo_authorize_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_authorize_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_authorize_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooAuthorizeProxy): The constructed proxy object or %NULL if @error is set.
 */
FooAuthorize *
foo_authorize_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_AUTHORIZE (ret);
  else
    return NULL;
}

/**
 * foo_authorize_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_authorize_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_authorize_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooAuthorizeProxy): The constructed proxy object or %NULL if @error is set.
 */
FooAuthorize *
foo_authorize_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_AUTHORIZE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.Authorize", NULL);
  if (ret != NULL)
    return FOO_AUTHORIZE (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooAuthorizeSkeleton:
 *
 * The #FooAuthorizeSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooAuthorizeSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooAuthorizeSkeleton.
 */

struct _FooAuthorizeSkeletonPrivate
{
  GValueArray *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex *lock;
};

static void
_foo_authorize_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooAuthorizeSkeleton *skeleton = FOO_AUTHORIZE_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = {0};
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_TYPE_AUTHORIZE);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
  {
    g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
    g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
  }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_AUTHORIZE);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_authorize_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooAuthorizeSkeleton *skeleton = FOO_AUTHORIZE_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_authorize_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_authorize_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooAuthorizeSkeleton *skeleton = FOO_AUTHORIZE_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_authorize_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_authorize_skeleton_vtable =
{
  _foo_authorize_skeleton_handle_method_call,
  _foo_authorize_skeleton_handle_get_property,
  _foo_authorize_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
foo_authorize_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return foo_authorize_interface_info ();
}

static GDBusInterfaceVTable *
foo_authorize_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_foo_authorize_skeleton_vtable;
}

static GVariant *
foo_authorize_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooAuthorizeSkeleton *skeleton = FOO_AUTHORIZE_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_authorize_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_authorize_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_authorize_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_authorize_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.Authorize", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
foo_authorize_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void
foo_authorize_skeleton_iface_init (FooAuthorizeIface *iface)
{
}

#define foo_authorize_skeleton_get_type foo_authorize_skeleton_get_type
G_DEFINE_TYPE_WITH_CODE (FooAuthorizeSkeleton, foo_authorize_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_AUTHORIZE, foo_authorize_skeleton_iface_init));
#undef foo_authorize_skeleton_get_type

static void
foo_authorize_skeleton_finalize (GObject *object)
{
  FooAuthorizeSkeleton *skeleton = FOO_AUTHORIZE_SKELETON (object);
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  if (skeleton->priv->context != NULL)
    g_main_context_unref (skeleton->priv->context);
  g_mutex_free (skeleton->priv->lock);
  G_OBJECT_CLASS (foo_authorize_skeleton_parent_class)->finalize (object);
}

static void
foo_authorize_skeleton_init (FooAuthorizeSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_TYPE_AUTHORIZE_SKELETON, FooAuthorizeSkeletonPrivate);
  skeleton->priv->lock = g_mutex_new ();
  skeleton->priv->context = g_main_context_get_thread_default ();
  if (skeleton->priv->context != NULL)
    g_main_context_ref (skeleton->priv->context);
}

static void
foo_authorize_skeleton_class_init (FooAuthorizeSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (FooAuthorizeSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_authorize_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_authorize_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_authorize_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_authorize_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_authorize_skeleton_dbus_interface_get_vtable;
}

/**
 * foo_authorize_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link>.
 *
 * Returns: (transfer full) (type FooAuthorizeSkeleton): The skeleton object.
 */
FooAuthorize *
foo_authorize_skeleton_new (void)
{
  return FOO_AUTHORIZE (g_object_new (FOO_TYPE_AUTHORIZE_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.project.MethodThreads
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooMethodThreads
 * @title: FooMethodThreads
 * @short_description: Generated C code for the org.project.MethodThreads D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.project.MethodThreads ---- */

static const _ExtendedGDBusArgInfo _foo_method_threads_method_info_get_self_OUT_ARG_self_pointer =
{
  {
    -1,
    "self_pointer",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_method_threads_method_info_get_self_OUT_ARG_pointers[] =
{
  &_foo_method_threads_method_info_get_self_OUT_ARG_self_pointer,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_method_threads_method_info_get_self =
{
  {
    -1,
    "GetSelf",
    NULL,
    (GDBusArgInfo **) &_foo_method_threads_method_info_get_self_OUT_ARG_pointers,
    NULL
  },
  "handle-get-self",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_method_threads_method_info_pointers[] =
{
  &_foo_method_threads_method_info_get_self,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_method_threads_interface_info =
{
  {
    -1,
    "org.project.MethodThreads",
    (GDBusMethodInfo **) &_foo_method_threads_method_info_pointers,
    NULL,
    NULL,
    NULL
  },
  "method-threads",
};


/**
 * foo_method_threads_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_method_threads_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_method_threads_interface_info;
}



/**
 * FooMethodThreads:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link>.
 */

/**
 * FooMethodThreadsIface:
 * @parent_iface: The parent interface.
 * @handle_get_self: Handler for the #FooMethodThreads::handle-get-self signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link>.
 */

static void
foo_method_threads_default_init (FooMethodThreadsIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooMethodThreads::handle-get-self:
   * @object: A #FooMethodThreads.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-MethodThreads.GetSelf">GetSelf()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_method_threads_complete_get_self() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-self",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooMethodThreadsIface, handle_get_self),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

}

typedef FooMethodThreadsIface FooMethodThreadsInterface;
G_DEFINE_INTERFACE (FooMethodThreads, foo_method_threads, G_TYPE_OBJECT);

/**
 * foo_method_threads_call_get_self:
 * @proxy: A #FooMethodThreadsProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-MethodThreads.GetSelf">GetSelf()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_method_threads_call_get_self_finish() to get the result of the operation.
 *
 * See foo_method_threads_call_get_self_sync() for the synchronous, blocking version of this method.
 */
void
foo_method_threads_call_get_self (
    FooMethodThreads *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "GetSelf",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_method_threads_call_get_self_finish:
 * @proxy: A #FooMethodThreadsProxy.
 * @out_self_pointer: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_method_threads_call_get_self().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_method_threads_call_get_self().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_method_threads_call_get_self_finish (
    FooMethodThreads *proxy,
    gchar **out_self_pointer,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_self_pointer);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_method_threads_call_get_self_sync:
 * @proxy: A #FooMethodThreadsProxy.
 * @out_self_pointer: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-MethodThreads.GetSelf">GetSelf()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_method_threads_call_get_self() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_method_threads_call_get_self_sync (
    FooMethodThreads *proxy,
    gchar **out_self_pointer,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "GetSelf",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_self_pointer);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_method_threads_complete_get_self:
 * @object: A #FooMethodThreads.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @self_pointer: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-MethodThreads.GetSelf">GetSelf()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_method_threads_complete_get_self (
    FooMethodThreads *object,
    GDBusMethodInvocation *invocation,
    const gchar *self_pointer)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(s)",
                   self_pointer));
}

/* ------------------------------------------------------------------------ */

/**
 * FooMethodThreadsProxy:
 *
 * The #FooMethodThreadsProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooMethodThreadsProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooMethodThreadsProxy.
 */

static void
foo_method_threads_proxy_iface_init (FooMethodThreadsIface *iface)
{
}

#define foo_method_threads_proxy_get_type foo_method_threads_proxy_get_type
G_DEFINE_TYPE_WITH_CODE (FooMethodThreadsProxy, foo_method_threads_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_METHOD_THREADS, foo_method_threads_proxy_iface_init));
#undef foo_method_threads_proxy_get_type

static void
foo_method_threads_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
}

static void
foo_method_threads_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
}

static void
foo_method_threads_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_method_threads_interface_info, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_TYPE_METHOD_THREADS);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_METHOD_THREADS);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_method_threads_proxy_g_properties_changed (GDBusProxy *proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_method_threads_interface_info, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_method_threads_interface_info, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_method_threads_proxy_init (FooMethodThreadsProxy *proxy)
{
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_method_threads_interface_info ());
}

static void
foo_method_threads_proxy_class_init (FooMethodThreadsProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->get_property = foo_method_threads_proxy_get_property;
  gobject_class->set_property = foo_method_threads_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_method_threads_proxy_g_signal;
  proxy_class->g_properties_changed = foo_method_threads_proxy_g_properties_changed;

}

/**
 * foo_method_threads_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_method_threads_proxy_new_finish() to get the result of the operation.
 *
 * See foo_method_threads_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_method_threads_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_METHOD_THREADS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.MethodThreads", NULL);
}

/**
 * foo_method_threads_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_method_threads_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_method_threads_proxy_new().
 *
 * Returns: (transfer full) (type FooMethodThreadsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooMethodThreads *
foo_method_threads_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_METHOD_THREADS (ret);
  else
    return NULL;
}

/**
 * foo_method_threads_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_method_threads_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooMethodThreadsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooMethodThreads *
foo_method_threads_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_METHOD_THREADS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.MethodThreads", NULL);
  if (ret != NULL)
    return FOO_METHOD_THREADS (ret);
  else
    return NULL;
}


/**
 * foo_method_threads_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_method_threads_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_method_threads_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_method_threads_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_method_threads_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_METHOD_THREADS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.MethodThreads", NULL);
}

/**
 * foo_method_threads_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_method_threads_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_method_threads_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooMethodThreadsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooMethodThreads *
foo_method_threads_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_METHOD_THREADS (ret);
  else
    return NULL;
}

/**
 * foo_method_threads_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_method_threads_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_method_threads_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooMethodThreadsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooMethodThreads *
foo_method_threads_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_METHOD_THREADS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.MethodThreads", NULL);
  if (ret != NULL)
    return FOO_METHOD_THREADS (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooMethodThreadsSkeleton:
 *
 * The #FooMethodThreadsSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooMethodThreadsSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooMethodThreadsSkeleton.
 */

struct _FooMethodThreadsSkeletonPrivate
{
  GValueArray *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex *lock;
};

static void
_foo_method_threads_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooMethodThreadsSkeleton *skeleton = FOO_METHOD_THREADS_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = {0};
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_TYPE_METHOD_THREADS);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
  {
    g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
    g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
  }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_METHOD_THREADS);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_method_threads_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooMethodThreadsSkeleton *skeleton = FOO_METHOD_THREADS_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_method_threads_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_method_threads_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooMethodThreadsSkeleton *skeleton = FOO_METHOD_THREADS_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_method_threads_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_method_threads_skeleton_vtable =
{
  _foo_method_threads_skeleton_handle_method_call,
  _foo_method_threads_skeleton_handle_get_property,
  _foo_method_threads_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
foo_method_threads_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return foo_method_threads_interface_info ();
}

static GDBusInterfaceVTable *
foo_method_threads_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_foo_method_threads_skeleton_vtable;
}

static GVariant *
foo_method_threads_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooMethodThreadsSkeleton *skeleton = FOO_METHOD_THREADS_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_method_threads_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_method_threads_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_method_threads_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_method_threads_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.MethodThreads", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
foo_method_threads_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void
foo_method_threads_skeleton_iface_init (FooMethodThreadsIface *iface)
{
}

#define foo_method_threads_skeleton_get_type foo_method_threads_skeleton_get_type
G_DEFINE_TYPE_WITH_CODE (FooMethodThreadsSkeleton, foo_method_threads_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_METHOD_THREADS, foo_method_threads_skeleton_iface_init));
#undef foo_method_threads_skeleton_get_type

static void
foo_method_threads_skeleton_finalize (GObject *object)
{
  FooMethodThreadsSkeleton *skeleton = FOO_METHOD_THREADS_SKELETON (object);
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  if (skeleton->priv->context != NULL)
    g_main_context_unref (skeleton->priv->context);
  g_mutex_free (skeleton->priv->lock);
  G_OBJECT_CLASS (foo_method_threads_skeleton_parent_class)->finalize (object);
}

static void
foo_method_threads_skeleton_init (FooMethodThreadsSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_TYPE_METHOD_THREADS_SKELETON, FooMethodThreadsSkeletonPrivate);
  skeleton->priv->lock = g_mutex_new ();
  skeleton->priv->context = g_main_context_get_thread_default ();
  if (skeleton->priv->context != NULL)
    g_main_context_ref (skeleton->priv->context);
}

static void
foo_method_threads_skeleton_class_init (FooMethodThreadsSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (FooMethodThreadsSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_method_threads_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_method_threads_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_method_threads_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_method_threads_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_method_threads_skeleton_dbus_interface_get_vtable;
}

/**
 * foo_method_threads_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link>.
 *
 * Returns: (transfer full) (type FooMethodThreadsSkeleton): The skeleton object.
 */
FooMethodThreads *
foo_method_threads_skeleton_new (void)
{
  return FOO_METHOD_THREADS (g_object_new (FOO_TYPE_METHOD_THREADS_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface org.project.InlineDocs
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooInlineDocs
 * @title: FooInlineDocs
 * @short_description: Generated C code for the org.project.InlineDocs D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-org-project-InlineDocs.top_of_page">org.project.InlineDocs</link> D-Bus interface in C.
 */

/* ---- Introspection data for org.project.InlineDocs ---- */

static const _ExtendedGDBusArgInfo _foo_inline_docs_method_info_foo_method_IN_ARG_greeting =
{
  {
    -1,
    "greeting",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_inline_docs_method_info_foo_method_IN_ARG_pointers[] =
{
  &_foo_inline_docs_method_info_foo_method_IN_ARG_greeting,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_inline_docs_method_info_foo_method_OUT_ARG_response =
{
  {
    -1,
    "response",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_inline_docs_method_info_foo_method_OUT_ARG_pointers[] =
{
  &_foo_inline_docs_method_info_foo_method_OUT_ARG_response,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_inline_docs_method_info_foo_method =
{
  {
    -1,
    "FooMethod",
    (GDBusArgInfo **) &_foo_inline_docs_method_info_foo_method_IN_ARG_pointers,
    (GDBusArgInfo **) &_foo_inline_docs_method_info_foo_method_OUT_ARG_pointers,
    NULL
  },
  "handle-foo-method",
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_inline_docs_method_info_method2_IN_ARG_greeting =
{
  {
    -1,
    "greeting",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_inline_docs_method_info_method2_IN_ARG_pointers[] =
{
  &_foo_inline_docs_method_info_method2_IN_ARG_greeting,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_inline_docs_method_info_method2_OUT_ARG_response =
{
  {
    -1,
    "response",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_inline_docs_method_info_method2_OUT_ARG_pointers[] =
{
  &_foo_inline_docs_method_info_method2_OUT_ARG_response,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_inline_docs_method_info_method2 =
{
  {
    -1,
    "Method2",
    (GDBusArgInfo **) &_foo_inline_docs_method_info_method2_IN_ARG_pointers,
    (GDBusArgInfo **) &_foo_inline_docs_method_info_method2_OUT_ARG_pointers,
    NULL
  },
  "handle-method2",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_inline_docs_method_info_pointers[] =
{
  &_foo_inline_docs_method_info_foo_method,
  &_foo_inline_docs_method_info_method2,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_inline_docs_signal_info_bar_signal_ARG_blah =
{
  {
    -1,
    "blah",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo _foo_inline_docs_signal_info_bar_signal_ARG_boo =
{
  {
    -1,
    "boo",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_inline_docs_signal_info_bar_signal_ARG_pointers[] =
{
  &_foo_inline_docs_signal_info_bar_signal_ARG_blah,
  &_foo_inline_docs_signal_info_bar_signal_ARG_boo,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_inline_docs_signal_info_bar_signal =
{
  {
    -1,
    "BarSignal",
    (GDBusArgInfo **) &_foo_inline_docs_signal_info_bar_signal_ARG_pointers,
    NULL
  },
  "bar-signal"
};

static const _ExtendedGDBusSignalInfo * const _foo_inline_docs_signal_info_pointers[] =
{
  &_foo_inline_docs_signal_info_bar_signal,
  NULL
};

static const _ExtendedGDBusPropertyInfo _foo_inline_docs_property_info_baz_property =
{
  {
    -1,
    "BazProperty",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "baz-property",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_inline_docs_property_info_property2 =
{
  {
    -1,
    "Property2",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "property2",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_inline_docs_property_info_property3 =
{
  {
    -1,
    "Property3",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "property3",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_inline_docs_property_info_property4 =
{
  {
    -1,
    "Property4",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "property4",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_inline_docs_property_info_property5 =
{
  {
    -1,
    "Property5",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "property5",
  FALSE
};

static const _ExtendedGDBusPropertyInfo _foo_inline_docs_property_info_fancy_property =
{
  {
    -1,
    "FancyProperty",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE,
    NULL
  },
  "fancy-property",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _foo_inline_docs_property_info_pointers[] =
{
  &_foo_inline_docs_property_info_baz_property,
  &_foo_inline_docs_property_info_property2,
  &_foo_inline_docs_property_info_property3,
  &_foo_inline_docs_property_info_property4,
  &_foo_inline_docs_property_info_property5,
  &_foo_inline_docs_property_info_fancy_property,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_inline_docs_interface_info =
{
  {
    -1,
    "org.project.InlineDocs",
    (GDBusMethodInfo **) &_foo_inline_docs_method_info_pointers,
    (GDBusSignalInfo **) &_foo_inline_docs_signal_info_pointers,
    (GDBusPropertyInfo **) &_foo_inline_docs_property_info_pointers,
    NULL
  },
  "inline-docs",
};


/**
 * foo_inline_docs_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-org-project-InlineDocs.top_of_page">org.project.InlineDocs</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_inline_docs_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_inline_docs_interface_info;
}

/**
 * foo_inline_docs_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooInlineDocs interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_inline_docs_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "baz-property");
  g_object_class_override_property (klass, property_id_begin++, "property2");
  g_object_class_override_property (klass, property_id_begin++, "property3");
  g_object_class_override_property (klass, property_id_begin++, "property4");
  g_object_class_override_property (klass, property_id_begin++, "property5");
  g_object_class_override_property (klass, property_id_begin++, "fancy-property");
  return property_id_begin - 1;
}



/**
 * FooInlineDocs:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-org-project-InlineDocs.top_of_page">org.project.InlineDocs</link>.
 */

/**
 * FooInlineDocsIface:
 * @parent_iface: The parent interface.
 * @handle_foo_method: Handler for the #FooInlineDocs::handle-foo-method signal.
 * @handle_method2: Handler for the #FooInlineDocs::handle-method2 signal.
 * @bar_signal: Handler for the #FooInlineDocs::bar-signal signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-org-project-InlineDocs.top_of_page">org.project.InlineDocs</link>.
 */

static void
foo_inline_docs_default_init (FooInlineDocsIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooInlineDocs::handle-foo-method:
   * @object: A #FooInlineDocs.
   * @invocation: A #GDBusMethodInvocation.
   * @greeting: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-InlineDocs.FooMethod">FooMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_inline_docs_complete_foo_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-foo-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooInlineDocsIface, handle_foo_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /**
   * FooInlineDocs::handle-method2:
   * @object: A #FooInlineDocs.
   * @invocation: A #GDBusMethodInvocation.
   * @greeting: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-org-project-InlineDocs.Method2">Method2()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_inline_docs_complete_method2() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-method2",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooInlineDocsIface, handle_method2),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    2,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooInlineDocs::bar-signal:
   * @object: A #FooInlineDocs.
   * @blah: Argument.
   * @boo: Argument.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-org-project-InlineDocs.BarSignal">"BarSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("bar-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooInlineDocsIface, bar_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    2, G_TYPE_STRING, G_TYPE_STRING);

  /* GObject properties for D-Bus properties: */
  /**
   * FooInlineDocs:baz-property:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-InlineDocs.BazProperty">"BazProperty"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("baz-property", "BazProperty", "BazProperty", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooInlineDocs:property2:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-InlineDocs.Property2">"Property2"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("property2", "Property2", "Property2", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooInlineDocs:property3:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-InlineDocs.Property3">"Property3"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("property3", "Property3", "Property3", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooInlineDocs:property4:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-InlineDocs.Property4">"Property4"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("property4", "Property4", "Property4", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooInlineDocs:property5:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-InlineDocs.Property5">"Property5"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("property5", "Property5", "Property5", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
  /**
   * FooInlineDocs:fancy-property:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-org-project-InlineDocs.FancyProperty">"FancyProperty"</link>.
   *
   * Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("fancy-property", "FancyProperty", "FancyProperty", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

typedef FooInlineDocsIface FooInlineDocsInterface;
G_DEFINE_INTERFACE (FooInlineDocs, foo_inline_docs, G_TYPE_OBJECT);

/**
 * foo_inline_docs_get_baz_property:
 * @object: A #FooInlineDocs.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-InlineDocs.BazProperty">"BazProperty"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
const gchar *
foo_inline_docs_get_baz_property (FooInlineDocs *object)
{
  const gchar *value;
  g_object_get (G_OBJECT (object), "baz-property", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-baz-property", (gpointer) value, (GDestroyNotify) g_free);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-baz-property", (gpointer) value, NULL);
  return value;
}

/**
 * foo_inline_docs_set_baz_property:
 * @object: A #FooInlineDocs.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-InlineDocs.BazProperty">"BazProperty"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_inline_docs_set_baz_property (FooInlineDocs *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "baz-property", value, NULL);
}

/**
 * foo_inline_docs_get_property2:
 * @object: A #FooInlineDocs.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-InlineDocs.Property2">"Property2"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
const gchar *
foo_inline_docs_get_property2 (FooInlineDocs *object)
{
  const gchar *value;
  g_object_get (G_OBJECT (object), "property2", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-property2", (gpointer) value, (GDestroyNotify) g_free);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-property2", (gpointer) value, NULL);
  return value;
}

/**
 * foo_inline_docs_set_property2:
 * @object: A #FooInlineDocs.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-InlineDocs.Property2">"Property2"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_inline_docs_set_property2 (FooInlineDocs *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "property2", value, NULL);
}

/**
 * foo_inline_docs_get_property3:
 * @object: A #FooInlineDocs.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-InlineDocs.Property3">"Property3"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
const gchar *
foo_inline_docs_get_property3 (FooInlineDocs *object)
{
  const gchar *value;
  g_object_get (G_OBJECT (object), "property3", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-property3", (gpointer) value, (GDestroyNotify) g_free);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-property3", (gpointer) value, NULL);
  return value;
}

/**
 * foo_inline_docs_set_property3:
 * @object: A #FooInlineDocs.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-InlineDocs.Property3">"Property3"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_inline_docs_set_property3 (FooInlineDocs *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "property3", value, NULL);
}

/**
 * foo_inline_docs_get_property4:
 * @object: A #FooInlineDocs.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-InlineDocs.Property4">"Property4"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
const gchar *
foo_inline_docs_get_property4 (FooInlineDocs *object)
{
  const gchar *value;
  g_object_get (G_OBJECT (object), "property4", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-property4", (gpointer) value, (GDestroyNotify) g_free);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-property4", (gpointer) value, NULL);
  return value;
}

/**
 * foo_inline_docs_set_property4:
 * @object: A #FooInlineDocs.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-InlineDocs.Property4">"Property4"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_inline_docs_set_property4 (FooInlineDocs *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "property4", value, NULL);
}

/**
 * foo_inline_docs_get_property5:
 * @object: A #FooInlineDocs.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-InlineDocs.Property5">"Property5"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
const gchar *
foo_inline_docs_get_property5 (FooInlineDocs *object)
{
  const gchar *value;
  g_object_get (G_OBJECT (object), "property5", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-property5", (gpointer) value, (GDestroyNotify) g_free);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-property5", (gpointer) value, NULL);
  return value;
}

/**
 * foo_inline_docs_set_property5:
 * @object: A #FooInlineDocs.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-InlineDocs.Property5">"Property5"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_inline_docs_set_property5 (FooInlineDocs *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "property5", value, NULL);
}

/**
 * foo_inline_docs_get_fancy_property:
 * @object: A #FooInlineDocs.
 *
 * Gets the value of the <link linkend="gdbus-property-org-project-InlineDocs.FancyProperty">"FancyProperty"</link> D-Bus property.
 *
 * Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
const gchar *
foo_inline_docs_get_fancy_property (FooInlineDocs *object)
{
  const gchar *value;
  g_object_get (G_OBJECT (object), "fancy-property", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-fancy-property", (gpointer) value, (GDestroyNotify) g_free);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-fancy-property", (gpointer) value, NULL);
  return value;
}

/**
 * foo_inline_docs_set_fancy_property:
 * @object: A #FooInlineDocs.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-org-project-InlineDocs.FancyProperty">"FancyProperty"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side.
 */
void
foo_inline_docs_set_fancy_property (FooInlineDocs *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "fancy-property", value, NULL);
}

/**
 * foo_inline_docs_emit_bar_signal:
 * @object: A #FooInlineDocs.
 * @blah: Argument to pass with the signal.
 * @boo: Argument to pass with the signal.
 *
 * Emits the <link linkend="gdbus-signal-org-project-InlineDocs.BarSignal">"BarSignal"</link> D-Bus signal.
 */
void
foo_inline_docs_emit_bar_signal (
    FooInlineDocs *object,
    const gchar *blah,
    const gchar *boo)
{
  g_signal_emit_by_name (object, "bar-signal", blah, boo);
}

/**
 * foo_inline_docs_call_foo_method:
 * @proxy: A #FooInlineDocsProxy.
 * @greeting: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-InlineDocs.FooMethod">FooMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_inline_docs_call_foo_method_finish() to get the result of the operation.
 *
 * See foo_inline_docs_call_foo_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_inline_docs_call_foo_method (
    FooInlineDocs *proxy,
    const gchar *greeting,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "FooMethod",
    g_variant_new ("(s)",
                   greeting),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_inline_docs_call_foo_method_finish:
 * @proxy: A #FooInlineDocsProxy.
 * @out_response: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_inline_docs_call_foo_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_inline_docs_call_foo_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_inline_docs_call_foo_method_finish (
    FooInlineDocs *proxy,
    gchar **out_response,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_response);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_inline_docs_call_foo_method_sync:
 * @proxy: A #FooInlineDocsProxy.
 * @greeting: Argument to pass with the method invocation.
 * @out_response: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-InlineDocs.FooMethod">FooMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_inline_docs_call_foo_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_inline_docs_call_foo_method_sync (
    FooInlineDocs *proxy,
    const gchar *greeting,
    gchar **out_response,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "FooMethod",
    g_variant_new ("(s)",
                   greeting),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_response);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_inline_docs_call_method2:
 * @proxy: A #FooInlineDocsProxy.
 * @greeting: Argument to pass with the method invocation.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-org-project-InlineDocs.Method2">Method2()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_inline_docs_call_method2_finish() to get the result of the operation.
 *
 * See foo_inline_docs_call_method2_sync() for the synchronous, blocking version of this method.
 */
void
foo_inline_docs_call_method2 (
    FooInlineDocs *proxy,
    const gchar *greeting,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Method2",
    g_variant_new ("(s)",
                   greeting),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_inline_docs_call_method2_finish:
 * @proxy: A #FooInlineDocsProxy.
 * @out_response: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_inline_docs_call_method2().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_inline_docs_call_method2().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_inline_docs_call_method2_finish (
    FooInlineDocs *proxy,
    gchar **out_response,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_response);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_inline_docs_call_method2_sync:
 * @proxy: A #FooInlineDocsProxy.
 * @greeting: Argument to pass with the method invocation.
 * @out_response: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-org-project-InlineDocs.Method2">Method2()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_inline_docs_call_method2() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_inline_docs_call_method2_sync (
    FooInlineDocs *proxy,
    const gchar *greeting,
    gchar **out_response,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Method2",
    g_variant_new ("(s)",
                   greeting),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_response);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_inline_docs_complete_foo_method:
 * @object: A #FooInlineDocs.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @response: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-InlineDocs.FooMethod">FooMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_inline_docs_complete_foo_method (
    FooInlineDocs *object,
    GDBusMethodInvocation *invocation,
    const gchar *response)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(s)",
                   response));
}

/**
 * foo_inline_docs_complete_method2:
 * @object: A #FooInlineDocs.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @response: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-org-project-InlineDocs.Method2">Method2()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_inline_docs_complete_method2 (
    FooInlineDocs *object,
    GDBusMethodInvocation *invocation,
    const gchar *response)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(s)",
                   response));
}

/* ------------------------------------------------------------------------ */

/**
 * FooInlineDocsProxy:
 *
 * The #FooInlineDocsProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooInlineDocsProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooInlineDocsProxy.
 */

static void
foo_inline_docs_proxy_iface_init (FooInlineDocsIface *iface)
{
}

#define foo_inline_docs_proxy_get_type foo_inline_docs_proxy_get_type
G_DEFINE_TYPE_WITH_CODE (FooInlineDocsProxy, foo_inline_docs_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_INLINE_DOCS, foo_inline_docs_proxy_iface_init));
#undef foo_inline_docs_proxy_get_type

static void
foo_inline_docs_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 6);
  info = _foo_inline_docs_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
foo_inline_docs_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  error = NULL;
  if (!g_dbus_proxy_call_finish (proxy, res, &error))
    {
      g_warning ("Error setting property `%s' on interface org.project.InlineDocs: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
}

static void
foo_inline_docs_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 6);
  info = _foo_inline_docs_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "org.project.InlineDocs", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) foo_inline_docs_proxy_set_property_cb, (gpointer) info);
  g_variant_unref (variant);
}

static void
foo_inline_docs_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_inline_docs_interface_info, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_TYPE_INLINE_DOCS);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_INLINE_DOCS);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_inline_docs_proxy_g_properties_changed (GDBusProxy *proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_inline_docs_interface_info, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_inline_docs_interface_info, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_inline_docs_proxy_init (FooInlineDocsProxy *proxy)
{
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_inline_docs_interface_info ());
}

static void
foo_inline_docs_proxy_class_init (FooInlineDocsProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->get_property = foo_inline_docs_proxy_get_property;
  gobject_class->set_property = foo_inline_docs_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_inline_docs_proxy_g_signal;
  proxy_class->g_properties_changed = foo_inline_docs_proxy_g_properties_changed;


  foo_inline_docs_override_properties (gobject_class, 1);
}

/**
 * foo_inline_docs_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-InlineDocs.top_of_page">org.project.InlineDocs</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_inline_docs_proxy_new_finish() to get the result of the operation.
 *
 * See foo_inline_docs_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_inline_docs_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_INLINE_DOCS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.InlineDocs", NULL);
}

/**
 * foo_inline_docs_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_inline_docs_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_inline_docs_proxy_new().
 *
 * Returns: (transfer full) (type FooInlineDocsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooInlineDocs *
foo_inline_docs_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_INLINE_DOCS (ret);
  else
    return NULL;
}

/**
 * foo_inline_docs_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-org-project-InlineDocs.top_of_page">org.project.InlineDocs</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_inline_docs_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooInlineDocsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooInlineDocs *
foo_inline_docs_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_INLINE_DOCS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "org.project.InlineDocs", NULL);
  if (ret != NULL)
    return FOO_INLINE_DOCS (ret);
  else
    return NULL;
}


/**
 * foo_inline_docs_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_inline_docs_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_inline_docs_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_inline_docs_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_inline_docs_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_INLINE_DOCS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.InlineDocs", NULL);
}

/**
 * foo_inline_docs_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_inline_docs_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_inline_docs_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooInlineDocsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooInlineDocs *
foo_inline_docs_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_INLINE_DOCS (ret);
  else
    return NULL;
}

/**
 * foo_inline_docs_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_inline_docs_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_inline_docs_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooInlineDocsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooInlineDocs *
foo_inline_docs_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_INLINE_DOCS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "org.project.InlineDocs", NULL);
  if (ret != NULL)
    return FOO_INLINE_DOCS (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooInlineDocsSkeleton:
 *
 * The #FooInlineDocsSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooInlineDocsSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooInlineDocsSkeleton.
 */

struct _FooInlineDocsSkeletonPrivate
{
  GValueArray *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex *lock;
};

static void
_foo_inline_docs_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooInlineDocsSkeleton *skeleton = FOO_INLINE_DOCS_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = {0};
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_TYPE_INLINE_DOCS);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
  {
    g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
    g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
  }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_INLINE_DOCS);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_inline_docs_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooInlineDocsSkeleton *skeleton = FOO_INLINE_DOCS_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_inline_docs_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_inline_docs_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooInlineDocsSkeleton *skeleton = FOO_INLINE_DOCS_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_inline_docs_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_inline_docs_skeleton_vtable =
{
  _foo_inline_docs_skeleton_handle_method_call,
  _foo_inline_docs_skeleton_handle_get_property,
  _foo_inline_docs_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
foo_inline_docs_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return foo_inline_docs_interface_info ();
}

static GDBusInterfaceVTable *
foo_inline_docs_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_foo_inline_docs_skeleton_vtable;
}

static GVariant *
foo_inline_docs_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooInlineDocsSkeleton *skeleton = FOO_INLINE_DOCS_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_inline_docs_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_inline_docs_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_inline_docs_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_inline_docs_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.InlineDocs", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _foo_inline_docs_emit_changed (gpointer user_data);

static void
foo_inline_docs_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  FooInlineDocsSkeleton *skeleton = FOO_INLINE_DOCS_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (skeleton->priv->lock);

  if (emit_changed)
    _foo_inline_docs_emit_changed (skeleton);
}

static void
_foo_inline_docs_on_signal_bar_signal (
    FooInlineDocs *object,
    const gchar *blah,
    const gchar *boo)
{
  FooInlineDocsSkeleton *skeleton = FOO_INLINE_DOCS_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "org.project.InlineDocs", "BarSignal",
    g_variant_new ("(ss)",
                   blah,
                   boo), NULL);
}

static void
foo_inline_docs_skeleton_iface_init (FooInlineDocsIface *iface)
{
  iface->bar_signal = _foo_inline_docs_on_signal_bar_signal;
}

#define foo_inline_docs_skeleton_get_type foo_inline_docs_skeleton_get_type
G_DEFINE_TYPE_WITH_CODE (FooInlineDocsSkeleton, foo_inline_docs_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_INLINE_DOCS, foo_inline_docs_skeleton_iface_init));
#undef foo_inline_docs_skeleton_get_type

static void
foo_inline_docs_skeleton_finalize (GObject *object)
{
  FooInlineDocsSkeleton *skeleton = FOO_INLINE_DOCS_SKELETON (object);
  g_value_array_free (skeleton->priv->properties);
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  if (skeleton->priv->context != NULL)
    g_main_context_unref (skeleton->priv->context);
  g_mutex_free (skeleton->priv->lock);
  G_OBJECT_CLASS (foo_inline_docs_skeleton_parent_class)->finalize (object);
}

static void
foo_inline_docs_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  FooInlineDocsSkeleton *skeleton = FOO_INLINE_DOCS_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 6);
  g_mutex_lock (skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties->values[prop_id - 1], value);
  g_mutex_unlock (skeleton->priv->lock);
}

static gboolean
_foo_inline_docs_emit_changed (gpointer user_data)
{
  FooInlineDocsSkeleton *skeleton = FOO_INLINE_DOCS_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties->values[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      g_dbus_connection_emit_signal (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                     NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                     "org.freedesktop.DBus.Properties",
                                     "PropertiesChanged",
                                     g_variant_new ("(sa{sv}as)",
                                                    "org.project.InlineDocs",
                                                    &builder, &invalidated_builder),
                                     NULL);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (skeleton->priv->lock);
  return FALSE;
}

static void
_foo_inline_docs_schedule_emit_changed (FooInlineDocsSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
foo_inline_docs_skeleton_notify (GObject      *object,
  GParamSpec *pspec)
{
  FooInlineDocsSkeleton *skeleton = FOO_INLINE_DOCS_SKELETON (object);
  g_mutex_lock (skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _foo_inline_docs_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (skeleton->priv->lock);
}

static void
foo_inline_docs_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  FooInlineDocsSkeleton *skeleton = FOO_INLINE_DOCS_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 6);
  g_mutex_lock (skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties->values[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _foo_inline_docs_schedule_emit_changed (skeleton, _foo_inline_docs_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties->values[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties->values[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
foo_inline_docs_skeleton_init (FooInlineDocsSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_TYPE_INLINE_DOCS_SKELETON, FooInlineDocsSkeletonPrivate);
  skeleton->priv->lock = g_mutex_new ();
  skeleton->priv->context = g_main_context_get_thread_default ();
  if (skeleton->priv->context != NULL)
    g_main_context_ref (skeleton->priv->context);
  skeleton->priv->properties = g_value_array_new (6);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[0], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[1], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[2], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[3], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[4], G_TYPE_STRING);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[5], G_TYPE_STRING);
}

static void
foo_inline_docs_skeleton_class_init (FooInlineDocsSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (FooInlineDocsSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_inline_docs_skeleton_finalize;
  gobject_class->get_property = foo_inline_docs_skeleton_get_property;
  gobject_class->set_property = foo_inline_docs_skeleton_set_property;
  gobject_class->notify       = foo_inline_docs_skeleton_notify;


  foo_inline_docs_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_inline_docs_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_inline_docs_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_inline_docs_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_inline_docs_skeleton_dbus_interface_get_vtable;
}

/**
 * foo_inline_docs_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-org-project-InlineDocs.top_of_page">org.project.InlineDocs</link>.
 *
 * Returns: (transfer full) (type FooInlineDocsSkeleton): The skeleton object.
 */
FooInlineDocs *
foo_inline_docs_skeleton_new (void)
{
  return FOO_INLINE_DOCS (g_object_new (FOO_TYPE_INLINE_DOCS_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface ChangingInterfaceV1
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooChangingInterfaceV1
 * @title: FooChangingInterfaceV1
 * @short_description: Generated C code for the ChangingInterfaceV1 D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-ChangingInterfaceV1.top_of_page">ChangingInterfaceV1</link> D-Bus interface in C.
 */

/* ---- Introspection data for ChangingInterfaceV1 ---- */

static const _ExtendedGDBusMethodInfo _foo_changing_interface_v1_method_info_foo_method =
{
  {
    -1,
    "FooMethod",
    NULL,
    NULL,
    NULL
  },
  "handle-foo-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_changing_interface_v1_method_info_bar_method =
{
  {
    -1,
    "BarMethod",
    NULL,
    NULL,
    NULL
  },
  "handle-bar-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_changing_interface_v1_method_info_baz_method =
{
  {
    -1,
    "BazMethod",
    NULL,
    NULL,
    NULL
  },
  "handle-baz-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_changing_interface_v1_method_info_pointers[] =
{
  &_foo_changing_interface_v1_method_info_foo_method,
  &_foo_changing_interface_v1_method_info_bar_method,
  &_foo_changing_interface_v1_method_info_baz_method,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_changing_interface_v1_signal_info_foo_signal =
{
  {
    -1,
    "FooSignal",
    NULL,
    NULL
  },
  "foo-signal"
};

static const _ExtendedGDBusSignalInfo _foo_changing_interface_v1_signal_info_bar_signal =
{
  {
    -1,
    "BarSignal",
    NULL,
    NULL
  },
  "bar-signal"
};

static const _ExtendedGDBusSignalInfo _foo_changing_interface_v1_signal_info_baz_signal =
{
  {
    -1,
    "BazSignal",
    NULL,
    NULL
  },
  "baz-signal"
};

static const _ExtendedGDBusSignalInfo * const _foo_changing_interface_v1_signal_info_pointers[] =
{
  &_foo_changing_interface_v1_signal_info_foo_signal,
  &_foo_changing_interface_v1_signal_info_bar_signal,
  &_foo_changing_interface_v1_signal_info_baz_signal,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_changing_interface_v1_interface_info =
{
  {
    -1,
    "ChangingInterfaceV1",
    (GDBusMethodInfo **) &_foo_changing_interface_v1_method_info_pointers,
    (GDBusSignalInfo **) &_foo_changing_interface_v1_signal_info_pointers,
    NULL,
    NULL
  },
  "changing-interface-v1",
};


/**
 * foo_changing_interface_v1_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-ChangingInterfaceV1.top_of_page">ChangingInterfaceV1</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_changing_interface_v1_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_changing_interface_v1_interface_info;
}



/**
 * FooChangingInterfaceV1:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV1.top_of_page">ChangingInterfaceV1</link>.
 */

/**
 * FooChangingInterfaceV1Iface:
 * @parent_iface: The parent interface.
 * @handle_bar_method: Handler for the #FooChangingInterfaceV1::handle-bar-method signal.
 * @handle_baz_method: Handler for the #FooChangingInterfaceV1::handle-baz-method signal.
 * @handle_foo_method: Handler for the #FooChangingInterfaceV1::handle-foo-method signal.
 * @bar_signal: Handler for the #FooChangingInterfaceV1::bar-signal signal.
 * @baz_signal: Handler for the #FooChangingInterfaceV1::baz-signal signal.
 * @foo_signal: Handler for the #FooChangingInterfaceV1::foo-signal signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV1.top_of_page">ChangingInterfaceV1</link>.
 */

static void
foo_changing_interface_v1_default_init (FooChangingInterfaceV1Iface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooChangingInterfaceV1::handle-foo-method:
   * @object: A #FooChangingInterfaceV1.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-ChangingInterfaceV1.FooMethod">FooMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_changing_interface_v1_complete_foo_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-foo-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooChangingInterfaceV1Iface, handle_foo_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooChangingInterfaceV1::handle-bar-method:
   * @object: A #FooChangingInterfaceV1.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-ChangingInterfaceV1.BarMethod">BarMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_changing_interface_v1_complete_bar_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-bar-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooChangingInterfaceV1Iface, handle_bar_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooChangingInterfaceV1::handle-baz-method:
   * @object: A #FooChangingInterfaceV1.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-ChangingInterfaceV1.BazMethod">BazMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_changing_interface_v1_complete_baz_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-baz-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooChangingInterfaceV1Iface, handle_baz_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooChangingInterfaceV1::foo-signal:
   * @object: A #FooChangingInterfaceV1.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-ChangingInterfaceV1.FooSignal">"FooSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("foo-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooChangingInterfaceV1Iface, foo_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /**
   * FooChangingInterfaceV1::bar-signal:
   * @object: A #FooChangingInterfaceV1.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-ChangingInterfaceV1.BarSignal">"BarSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("bar-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooChangingInterfaceV1Iface, bar_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /**
   * FooChangingInterfaceV1::baz-signal:
   * @object: A #FooChangingInterfaceV1.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-ChangingInterfaceV1.BazSignal">"BazSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("baz-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooChangingInterfaceV1Iface, baz_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

}

typedef FooChangingInterfaceV1Iface FooChangingInterfaceV1Interface;
G_DEFINE_INTERFACE (FooChangingInterfaceV1, foo_changing_interface_v1, G_TYPE_OBJECT);

/**
 * foo_changing_interface_v1_emit_foo_signal:
 * @object: A #FooChangingInterfaceV1.
 *
 * Emits the <link linkend="gdbus-signal-ChangingInterfaceV1.FooSignal">"FooSignal"</link> D-Bus signal.
 */
void
foo_changing_interface_v1_emit_foo_signal (
    FooChangingInterfaceV1 *object)
{
  g_signal_emit_by_name (object, "foo-signal");
}

/**
 * foo_changing_interface_v1_emit_bar_signal:
 * @object: A #FooChangingInterfaceV1.
 *
 * Emits the <link linkend="gdbus-signal-ChangingInterfaceV1.BarSignal">"BarSignal"</link> D-Bus signal.
 */
void
foo_changing_interface_v1_emit_bar_signal (
    FooChangingInterfaceV1 *object)
{
  g_signal_emit_by_name (object, "bar-signal");
}

/**
 * foo_changing_interface_v1_emit_baz_signal:
 * @object: A #FooChangingInterfaceV1.
 *
 * Emits the <link linkend="gdbus-signal-ChangingInterfaceV1.BazSignal">"BazSignal"</link> D-Bus signal.
 */
void
foo_changing_interface_v1_emit_baz_signal (
    FooChangingInterfaceV1 *object)
{
  g_signal_emit_by_name (object, "baz-signal");
}

/**
 * foo_changing_interface_v1_call_foo_method:
 * @proxy: A #FooChangingInterfaceV1Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV1.FooMethod">FooMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_changing_interface_v1_call_foo_method_finish() to get the result of the operation.
 *
 * See foo_changing_interface_v1_call_foo_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_changing_interface_v1_call_foo_method (
    FooChangingInterfaceV1 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "FooMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_changing_interface_v1_call_foo_method_finish:
 * @proxy: A #FooChangingInterfaceV1Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_changing_interface_v1_call_foo_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_changing_interface_v1_call_foo_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_changing_interface_v1_call_foo_method_finish (
    FooChangingInterfaceV1 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_changing_interface_v1_call_foo_method_sync:
 * @proxy: A #FooChangingInterfaceV1Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV1.FooMethod">FooMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_changing_interface_v1_call_foo_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_changing_interface_v1_call_foo_method_sync (
    FooChangingInterfaceV1 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "FooMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_changing_interface_v1_call_bar_method:
 * @proxy: A #FooChangingInterfaceV1Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV1.BarMethod">BarMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_changing_interface_v1_call_bar_method_finish() to get the result of the operation.
 *
 * See foo_changing_interface_v1_call_bar_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_changing_interface_v1_call_bar_method (
    FooChangingInterfaceV1 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "BarMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_changing_interface_v1_call_bar_method_finish:
 * @proxy: A #FooChangingInterfaceV1Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_changing_interface_v1_call_bar_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_changing_interface_v1_call_bar_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_changing_interface_v1_call_bar_method_finish (
    FooChangingInterfaceV1 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_changing_interface_v1_call_bar_method_sync:
 * @proxy: A #FooChangingInterfaceV1Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV1.BarMethod">BarMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_changing_interface_v1_call_bar_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_changing_interface_v1_call_bar_method_sync (
    FooChangingInterfaceV1 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "BarMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_changing_interface_v1_call_baz_method:
 * @proxy: A #FooChangingInterfaceV1Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV1.BazMethod">BazMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_changing_interface_v1_call_baz_method_finish() to get the result of the operation.
 *
 * See foo_changing_interface_v1_call_baz_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_changing_interface_v1_call_baz_method (
    FooChangingInterfaceV1 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "BazMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_changing_interface_v1_call_baz_method_finish:
 * @proxy: A #FooChangingInterfaceV1Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_changing_interface_v1_call_baz_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_changing_interface_v1_call_baz_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_changing_interface_v1_call_baz_method_finish (
    FooChangingInterfaceV1 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_changing_interface_v1_call_baz_method_sync:
 * @proxy: A #FooChangingInterfaceV1Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV1.BazMethod">BazMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_changing_interface_v1_call_baz_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_changing_interface_v1_call_baz_method_sync (
    FooChangingInterfaceV1 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "BazMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_changing_interface_v1_complete_foo_method:
 * @object: A #FooChangingInterfaceV1.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-ChangingInterfaceV1.FooMethod">FooMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_changing_interface_v1_complete_foo_method (
    FooChangingInterfaceV1 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_changing_interface_v1_complete_bar_method:
 * @object: A #FooChangingInterfaceV1.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-ChangingInterfaceV1.BarMethod">BarMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_changing_interface_v1_complete_bar_method (
    FooChangingInterfaceV1 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_changing_interface_v1_complete_baz_method:
 * @object: A #FooChangingInterfaceV1.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-ChangingInterfaceV1.BazMethod">BazMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_changing_interface_v1_complete_baz_method (
    FooChangingInterfaceV1 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FooChangingInterfaceV1Proxy:
 *
 * The #FooChangingInterfaceV1Proxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooChangingInterfaceV1ProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooChangingInterfaceV1Proxy.
 */

static void
foo_changing_interface_v1_proxy_iface_init (FooChangingInterfaceV1Iface *iface)
{
}

#define foo_changing_interface_v1_proxy_get_type foo_changing_interface_v1_proxy_get_type
G_DEFINE_TYPE_WITH_CODE (FooChangingInterfaceV1Proxy, foo_changing_interface_v1_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_CHANGING_INTERFACE_V1, foo_changing_interface_v1_proxy_iface_init));
#undef foo_changing_interface_v1_proxy_get_type

static void
foo_changing_interface_v1_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
}

static void
foo_changing_interface_v1_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
}

static void
foo_changing_interface_v1_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_changing_interface_v1_interface_info, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_TYPE_CHANGING_INTERFACE_V1);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_CHANGING_INTERFACE_V1);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_changing_interface_v1_proxy_g_properties_changed (GDBusProxy *proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_changing_interface_v1_interface_info, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_changing_interface_v1_interface_info, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_changing_interface_v1_proxy_init (FooChangingInterfaceV1Proxy *proxy)
{
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_changing_interface_v1_interface_info ());
}

static void
foo_changing_interface_v1_proxy_class_init (FooChangingInterfaceV1ProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->get_property = foo_changing_interface_v1_proxy_get_property;
  gobject_class->set_property = foo_changing_interface_v1_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_changing_interface_v1_proxy_g_signal;
  proxy_class->g_properties_changed = foo_changing_interface_v1_proxy_g_properties_changed;

}

/**
 * foo_changing_interface_v1_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV1.top_of_page">ChangingInterfaceV1</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_changing_interface_v1_proxy_new_finish() to get the result of the operation.
 *
 * See foo_changing_interface_v1_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_changing_interface_v1_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_CHANGING_INTERFACE_V1_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "ChangingInterfaceV1", NULL);
}

/**
 * foo_changing_interface_v1_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_changing_interface_v1_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_changing_interface_v1_proxy_new().
 *
 * Returns: (transfer full) (type FooChangingInterfaceV1Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooChangingInterfaceV1 *
foo_changing_interface_v1_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_CHANGING_INTERFACE_V1 (ret);
  else
    return NULL;
}

/**
 * foo_changing_interface_v1_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV1.top_of_page">ChangingInterfaceV1</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_changing_interface_v1_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooChangingInterfaceV1Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooChangingInterfaceV1 *
foo_changing_interface_v1_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_CHANGING_INTERFACE_V1_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "ChangingInterfaceV1", NULL);
  if (ret != NULL)
    return FOO_CHANGING_INTERFACE_V1 (ret);
  else
    return NULL;
}


/**
 * foo_changing_interface_v1_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_changing_interface_v1_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_changing_interface_v1_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_changing_interface_v1_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_changing_interface_v1_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_CHANGING_INTERFACE_V1_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "ChangingInterfaceV1", NULL);
}

/**
 * foo_changing_interface_v1_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_changing_interface_v1_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_changing_interface_v1_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooChangingInterfaceV1Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooChangingInterfaceV1 *
foo_changing_interface_v1_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_CHANGING_INTERFACE_V1 (ret);
  else
    return NULL;
}

/**
 * foo_changing_interface_v1_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_changing_interface_v1_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_changing_interface_v1_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooChangingInterfaceV1Proxy): The constructed proxy object or %NULL if @error is set.
 */
FooChangingInterfaceV1 *
foo_changing_interface_v1_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_CHANGING_INTERFACE_V1_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "ChangingInterfaceV1", NULL);
  if (ret != NULL)
    return FOO_CHANGING_INTERFACE_V1 (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooChangingInterfaceV1Skeleton:
 *
 * The #FooChangingInterfaceV1Skeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooChangingInterfaceV1SkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooChangingInterfaceV1Skeleton.
 */

struct _FooChangingInterfaceV1SkeletonPrivate
{
  GValueArray *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex *lock;
};

static void
_foo_changing_interface_v1_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooChangingInterfaceV1Skeleton *skeleton = FOO_CHANGING_INTERFACE_V1_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = {0};
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_TYPE_CHANGING_INTERFACE_V1);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
  {
    g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
    g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
  }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_CHANGING_INTERFACE_V1);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_changing_interface_v1_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooChangingInterfaceV1Skeleton *skeleton = FOO_CHANGING_INTERFACE_V1_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_changing_interface_v1_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_changing_interface_v1_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooChangingInterfaceV1Skeleton *skeleton = FOO_CHANGING_INTERFACE_V1_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_changing_interface_v1_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_changing_interface_v1_skeleton_vtable =
{
  _foo_changing_interface_v1_skeleton_handle_method_call,
  _foo_changing_interface_v1_skeleton_handle_get_property,
  _foo_changing_interface_v1_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
foo_changing_interface_v1_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return foo_changing_interface_v1_interface_info ();
}

static GDBusInterfaceVTable *
foo_changing_interface_v1_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_foo_changing_interface_v1_skeleton_vtable;
}

static GVariant *
foo_changing_interface_v1_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooChangingInterfaceV1Skeleton *skeleton = FOO_CHANGING_INTERFACE_V1_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_changing_interface_v1_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_changing_interface_v1_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_changing_interface_v1_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_changing_interface_v1_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV1", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
foo_changing_interface_v1_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void
_foo_changing_interface_v1_on_signal_foo_signal (
    FooChangingInterfaceV1 *object)
{
  FooChangingInterfaceV1Skeleton *skeleton = FOO_CHANGING_INTERFACE_V1_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV1", "FooSignal",
    g_variant_new ("()"), NULL);
}

static void
_foo_changing_interface_v1_on_signal_bar_signal (
    FooChangingInterfaceV1 *object)
{
  FooChangingInterfaceV1Skeleton *skeleton = FOO_CHANGING_INTERFACE_V1_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV1", "BarSignal",
    g_variant_new ("()"), NULL);
}

static void
_foo_changing_interface_v1_on_signal_baz_signal (
    FooChangingInterfaceV1 *object)
{
  FooChangingInterfaceV1Skeleton *skeleton = FOO_CHANGING_INTERFACE_V1_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV1", "BazSignal",
    g_variant_new ("()"), NULL);
}

static void
foo_changing_interface_v1_skeleton_iface_init (FooChangingInterfaceV1Iface *iface)
{
  iface->foo_signal = _foo_changing_interface_v1_on_signal_foo_signal;
  iface->bar_signal = _foo_changing_interface_v1_on_signal_bar_signal;
  iface->baz_signal = _foo_changing_interface_v1_on_signal_baz_signal;
}

#define foo_changing_interface_v1_skeleton_get_type foo_changing_interface_v1_skeleton_get_type
G_DEFINE_TYPE_WITH_CODE (FooChangingInterfaceV1Skeleton, foo_changing_interface_v1_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_CHANGING_INTERFACE_V1, foo_changing_interface_v1_skeleton_iface_init));
#undef foo_changing_interface_v1_skeleton_get_type

static void
foo_changing_interface_v1_skeleton_finalize (GObject *object)
{
  FooChangingInterfaceV1Skeleton *skeleton = FOO_CHANGING_INTERFACE_V1_SKELETON (object);
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  if (skeleton->priv->context != NULL)
    g_main_context_unref (skeleton->priv->context);
  g_mutex_free (skeleton->priv->lock);
  G_OBJECT_CLASS (foo_changing_interface_v1_skeleton_parent_class)->finalize (object);
}

static void
foo_changing_interface_v1_skeleton_init (FooChangingInterfaceV1Skeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_TYPE_CHANGING_INTERFACE_V1_SKELETON, FooChangingInterfaceV1SkeletonPrivate);
  skeleton->priv->lock = g_mutex_new ();
  skeleton->priv->context = g_main_context_get_thread_default ();
  if (skeleton->priv->context != NULL)
    g_main_context_ref (skeleton->priv->context);
}

static void
foo_changing_interface_v1_skeleton_class_init (FooChangingInterfaceV1SkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (FooChangingInterfaceV1SkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_changing_interface_v1_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_changing_interface_v1_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_changing_interface_v1_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_changing_interface_v1_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_changing_interface_v1_skeleton_dbus_interface_get_vtable;
}

/**
 * foo_changing_interface_v1_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV1.top_of_page">ChangingInterfaceV1</link>.
 *
 * Returns: (transfer full) (type FooChangingInterfaceV1Skeleton): The skeleton object.
 */
FooChangingInterfaceV1 *
foo_changing_interface_v1_skeleton_new (void)
{
  return FOO_CHANGING_INTERFACE_V1 (g_object_new (FOO_TYPE_CHANGING_INTERFACE_V1_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface ChangingInterfaceV2
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooChangingInterfaceV2
 * @title: FooChangingInterfaceV2
 * @short_description: Generated C code for the ChangingInterfaceV2 D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-ChangingInterfaceV2.top_of_page">ChangingInterfaceV2</link> D-Bus interface in C.
 */

/* ---- Introspection data for ChangingInterfaceV2 ---- */

static const _ExtendedGDBusMethodInfo _foo_changing_interface_v2_method_info_new_method_in2 =
{
  {
    -1,
    "NewMethodIn2",
    NULL,
    NULL,
    NULL
  },
  "handle-new-method-in2",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_changing_interface_v2_method_info_baz_method =
{
  {
    -1,
    "BazMethod",
    NULL,
    NULL,
    NULL
  },
  "handle-baz-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_changing_interface_v2_method_info_bar_method =
{
  {
    -1,
    "BarMethod",
    NULL,
    NULL,
    NULL
  },
  "handle-bar-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_changing_interface_v2_method_info_foo_method =
{
  {
    -1,
    "FooMethod",
    NULL,
    NULL,
    NULL
  },
  "handle-foo-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_changing_interface_v2_method_info_pointers[] =
{
  &_foo_changing_interface_v2_method_info_new_method_in2,
  &_foo_changing_interface_v2_method_info_baz_method,
  &_foo_changing_interface_v2_method_info_bar_method,
  &_foo_changing_interface_v2_method_info_foo_method,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_changing_interface_v2_signal_info_new_signal_in2 =
{
  {
    -1,
    "NewSignalIn2",
    NULL,
    NULL
  },
  "new-signal-in2"
};

static const _ExtendedGDBusSignalInfo _foo_changing_interface_v2_signal_info_baz_signal =
{
  {
    -1,
    "BazSignal",
    NULL,
    NULL
  },
  "baz-signal"
};

static const _ExtendedGDBusSignalInfo _foo_changing_interface_v2_signal_info_bar_signal =
{
  {
    -1,
    "BarSignal",
    NULL,
    NULL
  },
  "bar-signal"
};

static const _ExtendedGDBusSignalInfo _foo_changing_interface_v2_signal_info_foo_signal =
{
  {
    -1,
    "FooSignal",
    NULL,
    NULL
  },
  "foo-signal"
};

static const _ExtendedGDBusSignalInfo * const _foo_changing_interface_v2_signal_info_pointers[] =
{
  &_foo_changing_interface_v2_signal_info_new_signal_in2,
  &_foo_changing_interface_v2_signal_info_baz_signal,
  &_foo_changing_interface_v2_signal_info_bar_signal,
  &_foo_changing_interface_v2_signal_info_foo_signal,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_changing_interface_v2_interface_info =
{
  {
    -1,
    "ChangingInterfaceV2",
    (GDBusMethodInfo **) &_foo_changing_interface_v2_method_info_pointers,
    (GDBusSignalInfo **) &_foo_changing_interface_v2_signal_info_pointers,
    NULL,
    NULL
  },
  "changing-interface-v2",
};


/**
 * foo_changing_interface_v2_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-ChangingInterfaceV2.top_of_page">ChangingInterfaceV2</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 *
 * Since: 2.0
 */
GDBusInterfaceInfo *
foo_changing_interface_v2_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_changing_interface_v2_interface_info;
}



/**
 * FooChangingInterfaceV2:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV2.top_of_page">ChangingInterfaceV2</link>.
 *
 * Since: 2.0
 */

/**
 * FooChangingInterfaceV2Iface:
 * @parent_iface: The parent interface.
 * @handle_bar_method: Handler for the #FooChangingInterfaceV2::handle-bar-method signal.
 * @handle_baz_method: Handler for the #FooChangingInterfaceV2::handle-baz-method signal.
 * @handle_foo_method: Handler for the #FooChangingInterfaceV2::handle-foo-method signal.
 * @bar_signal: Handler for the #FooChangingInterfaceV2::bar-signal signal.
 * @baz_signal: Handler for the #FooChangingInterfaceV2::baz-signal signal.
 * @foo_signal: Handler for the #FooChangingInterfaceV2::foo-signal signal.
 * @handle_new_method_in2: Handler for the #FooChangingInterfaceV2::handle-new-method-in2 signal.
 * @new_signal_in2: Handler for the #FooChangingInterfaceV2::new-signal-in2 signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV2.top_of_page">ChangingInterfaceV2</link>.
 *
 * Since: 2.0
 */

static void
foo_changing_interface_v2_default_init (FooChangingInterfaceV2Iface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooChangingInterfaceV2::handle-new-method-in2:
   * @object: A #FooChangingInterfaceV2.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-ChangingInterfaceV2.NewMethodIn2">NewMethodIn2()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_changing_interface_v2_complete_new_method_in2() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   *
   * Since: 2.0
   */
  g_signal_new ("handle-new-method-in2",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooChangingInterfaceV2Iface, handle_new_method_in2),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooChangingInterfaceV2::handle-baz-method:
   * @object: A #FooChangingInterfaceV2.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-ChangingInterfaceV2.BazMethod">BazMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_changing_interface_v2_complete_baz_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-baz-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooChangingInterfaceV2Iface, handle_baz_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooChangingInterfaceV2::handle-bar-method:
   * @object: A #FooChangingInterfaceV2.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-ChangingInterfaceV2.BarMethod">BarMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_changing_interface_v2_complete_bar_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-bar-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooChangingInterfaceV2Iface, handle_bar_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooChangingInterfaceV2::handle-foo-method:
   * @object: A #FooChangingInterfaceV2.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-ChangingInterfaceV2.FooMethod">FooMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_changing_interface_v2_complete_foo_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-foo-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooChangingInterfaceV2Iface, handle_foo_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooChangingInterfaceV2::new-signal-in2:
   * @object: A #FooChangingInterfaceV2.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-ChangingInterfaceV2.NewSignalIn2">"NewSignalIn2"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   *
   * Since: 2.0
   */
  g_signal_new ("new-signal-in2",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooChangingInterfaceV2Iface, new_signal_in2),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /**
   * FooChangingInterfaceV2::baz-signal:
   * @object: A #FooChangingInterfaceV2.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-ChangingInterfaceV2.BazSignal">"BazSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("baz-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooChangingInterfaceV2Iface, baz_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /**
   * FooChangingInterfaceV2::bar-signal:
   * @object: A #FooChangingInterfaceV2.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-ChangingInterfaceV2.BarSignal">"BarSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("bar-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooChangingInterfaceV2Iface, bar_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /**
   * FooChangingInterfaceV2::foo-signal:
   * @object: A #FooChangingInterfaceV2.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-ChangingInterfaceV2.FooSignal">"FooSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("foo-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooChangingInterfaceV2Iface, foo_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

}

typedef FooChangingInterfaceV2Iface FooChangingInterfaceV2Interface;
G_DEFINE_INTERFACE (FooChangingInterfaceV2, foo_changing_interface_v2, G_TYPE_OBJECT);

/**
 * foo_changing_interface_v2_emit_new_signal_in2:
 * @object: A #FooChangingInterfaceV2.
 *
 * Emits the <link linkend="gdbus-signal-ChangingInterfaceV2.NewSignalIn2">"NewSignalIn2"</link> D-Bus signal.
 *
 * Since: 2.0
 */
void
foo_changing_interface_v2_emit_new_signal_in2 (
    FooChangingInterfaceV2 *object)
{
  g_signal_emit_by_name (object, "new-signal-in2");
}

/**
 * foo_changing_interface_v2_emit_baz_signal:
 * @object: A #FooChangingInterfaceV2.
 *
 * Emits the <link linkend="gdbus-signal-ChangingInterfaceV2.BazSignal">"BazSignal"</link> D-Bus signal.
 */
void
foo_changing_interface_v2_emit_baz_signal (
    FooChangingInterfaceV2 *object)
{
  g_signal_emit_by_name (object, "baz-signal");
}

/**
 * foo_changing_interface_v2_emit_bar_signal:
 * @object: A #FooChangingInterfaceV2.
 *
 * Emits the <link linkend="gdbus-signal-ChangingInterfaceV2.BarSignal">"BarSignal"</link> D-Bus signal.
 */
void
foo_changing_interface_v2_emit_bar_signal (
    FooChangingInterfaceV2 *object)
{
  g_signal_emit_by_name (object, "bar-signal");
}

/**
 * foo_changing_interface_v2_emit_foo_signal:
 * @object: A #FooChangingInterfaceV2.
 *
 * Emits the <link linkend="gdbus-signal-ChangingInterfaceV2.FooSignal">"FooSignal"</link> D-Bus signal.
 */
void
foo_changing_interface_v2_emit_foo_signal (
    FooChangingInterfaceV2 *object)
{
  g_signal_emit_by_name (object, "foo-signal");
}

/**
 * foo_changing_interface_v2_call_new_method_in2:
 * @proxy: A #FooChangingInterfaceV2Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV2.NewMethodIn2">NewMethodIn2()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_changing_interface_v2_call_new_method_in2_finish() to get the result of the operation.
 *
 * See foo_changing_interface_v2_call_new_method_in2_sync() for the synchronous, blocking version of this method.
 *
 * Since: 2.0
 */
void
foo_changing_interface_v2_call_new_method_in2 (
    FooChangingInterfaceV2 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "NewMethodIn2",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_changing_interface_v2_call_new_method_in2_finish:
 * @proxy: A #FooChangingInterfaceV2Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_changing_interface_v2_call_new_method_in2().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_changing_interface_v2_call_new_method_in2().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 *
 * Since: 2.0
 */
gboolean
foo_changing_interface_v2_call_new_method_in2_finish (
    FooChangingInterfaceV2 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_changing_interface_v2_call_new_method_in2_sync:
 * @proxy: A #FooChangingInterfaceV2Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV2.NewMethodIn2">NewMethodIn2()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_changing_interface_v2_call_new_method_in2() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 *
 * Since: 2.0
 */
gboolean
foo_changing_interface_v2_call_new_method_in2_sync (
    FooChangingInterfaceV2 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "NewMethodIn2",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_changing_interface_v2_call_baz_method:
 * @proxy: A #FooChangingInterfaceV2Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV2.BazMethod">BazMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_changing_interface_v2_call_baz_method_finish() to get the result of the operation.
 *
 * See foo_changing_interface_v2_call_baz_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_changing_interface_v2_call_baz_method (
    FooChangingInterfaceV2 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "BazMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_changing_interface_v2_call_baz_method_finish:
 * @proxy: A #FooChangingInterfaceV2Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_changing_interface_v2_call_baz_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_changing_interface_v2_call_baz_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_changing_interface_v2_call_baz_method_finish (
    FooChangingInterfaceV2 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_changing_interface_v2_call_baz_method_sync:
 * @proxy: A #FooChangingInterfaceV2Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV2.BazMethod">BazMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_changing_interface_v2_call_baz_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_changing_interface_v2_call_baz_method_sync (
    FooChangingInterfaceV2 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "BazMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_changing_interface_v2_call_bar_method:
 * @proxy: A #FooChangingInterfaceV2Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV2.BarMethod">BarMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_changing_interface_v2_call_bar_method_finish() to get the result of the operation.
 *
 * See foo_changing_interface_v2_call_bar_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_changing_interface_v2_call_bar_method (
    FooChangingInterfaceV2 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "BarMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_changing_interface_v2_call_bar_method_finish:
 * @proxy: A #FooChangingInterfaceV2Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_changing_interface_v2_call_bar_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_changing_interface_v2_call_bar_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_changing_interface_v2_call_bar_method_finish (
    FooChangingInterfaceV2 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_changing_interface_v2_call_bar_method_sync:
 * @proxy: A #FooChangingInterfaceV2Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV2.BarMethod">BarMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_changing_interface_v2_call_bar_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_changing_interface_v2_call_bar_method_sync (
    FooChangingInterfaceV2 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "BarMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_changing_interface_v2_call_foo_method:
 * @proxy: A #FooChangingInterfaceV2Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV2.FooMethod">FooMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_changing_interface_v2_call_foo_method_finish() to get the result of the operation.
 *
 * See foo_changing_interface_v2_call_foo_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_changing_interface_v2_call_foo_method (
    FooChangingInterfaceV2 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "FooMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_changing_interface_v2_call_foo_method_finish:
 * @proxy: A #FooChangingInterfaceV2Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_changing_interface_v2_call_foo_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_changing_interface_v2_call_foo_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_changing_interface_v2_call_foo_method_finish (
    FooChangingInterfaceV2 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_changing_interface_v2_call_foo_method_sync:
 * @proxy: A #FooChangingInterfaceV2Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV2.FooMethod">FooMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_changing_interface_v2_call_foo_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_changing_interface_v2_call_foo_method_sync (
    FooChangingInterfaceV2 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "FooMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_changing_interface_v2_complete_new_method_in2:
 * @object: A #FooChangingInterfaceV2.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-ChangingInterfaceV2.NewMethodIn2">NewMethodIn2()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 *
 * Since: 2.0
 */
void
foo_changing_interface_v2_complete_new_method_in2 (
    FooChangingInterfaceV2 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_changing_interface_v2_complete_baz_method:
 * @object: A #FooChangingInterfaceV2.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-ChangingInterfaceV2.BazMethod">BazMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_changing_interface_v2_complete_baz_method (
    FooChangingInterfaceV2 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_changing_interface_v2_complete_bar_method:
 * @object: A #FooChangingInterfaceV2.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-ChangingInterfaceV2.BarMethod">BarMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_changing_interface_v2_complete_bar_method (
    FooChangingInterfaceV2 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_changing_interface_v2_complete_foo_method:
 * @object: A #FooChangingInterfaceV2.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-ChangingInterfaceV2.FooMethod">FooMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_changing_interface_v2_complete_foo_method (
    FooChangingInterfaceV2 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FooChangingInterfaceV2Proxy:
 *
 * The #FooChangingInterfaceV2Proxy structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 2.0
 */

/**
 * FooChangingInterfaceV2ProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooChangingInterfaceV2Proxy.
 *
 * Since: 2.0
 */

static void
foo_changing_interface_v2_proxy_iface_init (FooChangingInterfaceV2Iface *iface)
{
}

#define foo_changing_interface_v2_proxy_get_type foo_changing_interface_v2_proxy_get_type
G_DEFINE_TYPE_WITH_CODE (FooChangingInterfaceV2Proxy, foo_changing_interface_v2_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_CHANGING_INTERFACE_V2, foo_changing_interface_v2_proxy_iface_init));
#undef foo_changing_interface_v2_proxy_get_type

static void
foo_changing_interface_v2_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
}

static void
foo_changing_interface_v2_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
}

static void
foo_changing_interface_v2_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_changing_interface_v2_interface_info, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_TYPE_CHANGING_INTERFACE_V2);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_CHANGING_INTERFACE_V2);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_changing_interface_v2_proxy_g_properties_changed (GDBusProxy *proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_changing_interface_v2_interface_info, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_changing_interface_v2_interface_info, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_changing_interface_v2_proxy_init (FooChangingInterfaceV2Proxy *proxy)
{
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_changing_interface_v2_interface_info ());
}

static void
foo_changing_interface_v2_proxy_class_init (FooChangingInterfaceV2ProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->get_property = foo_changing_interface_v2_proxy_get_property;
  gobject_class->set_property = foo_changing_interface_v2_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_changing_interface_v2_proxy_g_signal;
  proxy_class->g_properties_changed = foo_changing_interface_v2_proxy_g_properties_changed;

}

/**
 * foo_changing_interface_v2_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV2.top_of_page">ChangingInterfaceV2</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_changing_interface_v2_proxy_new_finish() to get the result of the operation.
 *
 * See foo_changing_interface_v2_proxy_new_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 2.0
 */
void
foo_changing_interface_v2_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_CHANGING_INTERFACE_V2_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "ChangingInterfaceV2", NULL);
}

/**
 * foo_changing_interface_v2_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_changing_interface_v2_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_changing_interface_v2_proxy_new().
 *
 * Returns: (transfer full) (type FooChangingInterfaceV2Proxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 2.0
 */
FooChangingInterfaceV2 *
foo_changing_interface_v2_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_CHANGING_INTERFACE_V2 (ret);
  else
    return NULL;
}

/**
 * foo_changing_interface_v2_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV2.top_of_page">ChangingInterfaceV2</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_changing_interface_v2_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooChangingInterfaceV2Proxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 2.0
 */
FooChangingInterfaceV2 *
foo_changing_interface_v2_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_CHANGING_INTERFACE_V2_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "ChangingInterfaceV2", NULL);
  if (ret != NULL)
    return FOO_CHANGING_INTERFACE_V2 (ret);
  else
    return NULL;
}


/**
 * foo_changing_interface_v2_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_changing_interface_v2_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_changing_interface_v2_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_changing_interface_v2_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 2.0
 */
void
foo_changing_interface_v2_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_CHANGING_INTERFACE_V2_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "ChangingInterfaceV2", NULL);
}

/**
 * foo_changing_interface_v2_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_changing_interface_v2_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_changing_interface_v2_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooChangingInterfaceV2Proxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 2.0
 */
FooChangingInterfaceV2 *
foo_changing_interface_v2_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_CHANGING_INTERFACE_V2 (ret);
  else
    return NULL;
}

/**
 * foo_changing_interface_v2_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_changing_interface_v2_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_changing_interface_v2_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooChangingInterfaceV2Proxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 2.0
 */
FooChangingInterfaceV2 *
foo_changing_interface_v2_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_CHANGING_INTERFACE_V2_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "ChangingInterfaceV2", NULL);
  if (ret != NULL)
    return FOO_CHANGING_INTERFACE_V2 (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooChangingInterfaceV2Skeleton:
 *
 * The #FooChangingInterfaceV2Skeleton structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 2.0
 */

/**
 * FooChangingInterfaceV2SkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooChangingInterfaceV2Skeleton.
 *
 * Since: 2.0
 */

struct _FooChangingInterfaceV2SkeletonPrivate
{
  GValueArray *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex *lock;
};

static void
_foo_changing_interface_v2_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooChangingInterfaceV2Skeleton *skeleton = FOO_CHANGING_INTERFACE_V2_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = {0};
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_TYPE_CHANGING_INTERFACE_V2);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
  {
    g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
    g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
  }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_CHANGING_INTERFACE_V2);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_changing_interface_v2_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooChangingInterfaceV2Skeleton *skeleton = FOO_CHANGING_INTERFACE_V2_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_changing_interface_v2_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_changing_interface_v2_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooChangingInterfaceV2Skeleton *skeleton = FOO_CHANGING_INTERFACE_V2_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_changing_interface_v2_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_changing_interface_v2_skeleton_vtable =
{
  _foo_changing_interface_v2_skeleton_handle_method_call,
  _foo_changing_interface_v2_skeleton_handle_get_property,
  _foo_changing_interface_v2_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
foo_changing_interface_v2_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return foo_changing_interface_v2_interface_info ();
}

static GDBusInterfaceVTable *
foo_changing_interface_v2_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_foo_changing_interface_v2_skeleton_vtable;
}

static GVariant *
foo_changing_interface_v2_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooChangingInterfaceV2Skeleton *skeleton = FOO_CHANGING_INTERFACE_V2_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_changing_interface_v2_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_changing_interface_v2_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_changing_interface_v2_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_changing_interface_v2_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV2", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
foo_changing_interface_v2_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void
_foo_changing_interface_v2_on_signal_new_signal_in2 (
    FooChangingInterfaceV2 *object)
{
  FooChangingInterfaceV2Skeleton *skeleton = FOO_CHANGING_INTERFACE_V2_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV2", "NewSignalIn2",
    g_variant_new ("()"), NULL);
}

static void
_foo_changing_interface_v2_on_signal_baz_signal (
    FooChangingInterfaceV2 *object)
{
  FooChangingInterfaceV2Skeleton *skeleton = FOO_CHANGING_INTERFACE_V2_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV2", "BazSignal",
    g_variant_new ("()"), NULL);
}

static void
_foo_changing_interface_v2_on_signal_bar_signal (
    FooChangingInterfaceV2 *object)
{
  FooChangingInterfaceV2Skeleton *skeleton = FOO_CHANGING_INTERFACE_V2_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV2", "BarSignal",
    g_variant_new ("()"), NULL);
}

static void
_foo_changing_interface_v2_on_signal_foo_signal (
    FooChangingInterfaceV2 *object)
{
  FooChangingInterfaceV2Skeleton *skeleton = FOO_CHANGING_INTERFACE_V2_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV2", "FooSignal",
    g_variant_new ("()"), NULL);
}

static void
foo_changing_interface_v2_skeleton_iface_init (FooChangingInterfaceV2Iface *iface)
{
  iface->new_signal_in2 = _foo_changing_interface_v2_on_signal_new_signal_in2;
  iface->baz_signal = _foo_changing_interface_v2_on_signal_baz_signal;
  iface->bar_signal = _foo_changing_interface_v2_on_signal_bar_signal;
  iface->foo_signal = _foo_changing_interface_v2_on_signal_foo_signal;
}

#define foo_changing_interface_v2_skeleton_get_type foo_changing_interface_v2_skeleton_get_type
G_DEFINE_TYPE_WITH_CODE (FooChangingInterfaceV2Skeleton, foo_changing_interface_v2_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_CHANGING_INTERFACE_V2, foo_changing_interface_v2_skeleton_iface_init));
#undef foo_changing_interface_v2_skeleton_get_type

static void
foo_changing_interface_v2_skeleton_finalize (GObject *object)
{
  FooChangingInterfaceV2Skeleton *skeleton = FOO_CHANGING_INTERFACE_V2_SKELETON (object);
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  if (skeleton->priv->context != NULL)
    g_main_context_unref (skeleton->priv->context);
  g_mutex_free (skeleton->priv->lock);
  G_OBJECT_CLASS (foo_changing_interface_v2_skeleton_parent_class)->finalize (object);
}

static void
foo_changing_interface_v2_skeleton_init (FooChangingInterfaceV2Skeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_TYPE_CHANGING_INTERFACE_V2_SKELETON, FooChangingInterfaceV2SkeletonPrivate);
  skeleton->priv->lock = g_mutex_new ();
  skeleton->priv->context = g_main_context_get_thread_default ();
  if (skeleton->priv->context != NULL)
    g_main_context_ref (skeleton->priv->context);
}

static void
foo_changing_interface_v2_skeleton_class_init (FooChangingInterfaceV2SkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (FooChangingInterfaceV2SkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_changing_interface_v2_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_changing_interface_v2_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_changing_interface_v2_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_changing_interface_v2_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_changing_interface_v2_skeleton_dbus_interface_get_vtable;
}

/**
 * foo_changing_interface_v2_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV2.top_of_page">ChangingInterfaceV2</link>.
 *
 * Returns: (transfer full) (type FooChangingInterfaceV2Skeleton): The skeleton object.
 *
 * Since: 2.0
 */
FooChangingInterfaceV2 *
foo_changing_interface_v2_skeleton_new (void)
{
  return FOO_CHANGING_INTERFACE_V2 (g_object_new (FOO_TYPE_CHANGING_INTERFACE_V2_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface ChangingInterfaceV10
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooChangingInterfaceV10
 * @title: FooChangingInterfaceV10
 * @short_description: Generated C code for the ChangingInterfaceV10 D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-ChangingInterfaceV10.top_of_page">ChangingInterfaceV10</link> D-Bus interface in C.
 */

/* ---- Introspection data for ChangingInterfaceV10 ---- */

static const _ExtendedGDBusMethodInfo _foo_changing_interface_v10_method_info_added_method_in10 =
{
  {
    -1,
    "AddedMethodIn10",
    NULL,
    NULL,
    NULL
  },
  "handle-added-method-in10",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_changing_interface_v10_method_info_new_method_in2 =
{
  {
    -1,
    "NewMethodIn2",
    NULL,
    NULL,
    NULL
  },
  "handle-new-method-in2",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_changing_interface_v10_method_info_baz_method =
{
  {
    -1,
    "BazMethod",
    NULL,
    NULL,
    NULL
  },
  "handle-baz-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_changing_interface_v10_method_info_bar_method =
{
  {
    -1,
    "BarMethod",
    NULL,
    NULL,
    NULL
  },
  "handle-bar-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo _foo_changing_interface_v10_method_info_foo_method =
{
  {
    -1,
    "FooMethod",
    NULL,
    NULL,
    NULL
  },
  "handle-foo-method",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_changing_interface_v10_method_info_pointers[] =
{
  &_foo_changing_interface_v10_method_info_added_method_in10,
  &_foo_changing_interface_v10_method_info_new_method_in2,
  &_foo_changing_interface_v10_method_info_baz_method,
  &_foo_changing_interface_v10_method_info_bar_method,
  &_foo_changing_interface_v10_method_info_foo_method,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_changing_interface_v10_signal_info_added_signal_in10 =
{
  {
    -1,
    "AddedSignalIn10",
    NULL,
    NULL
  },
  "added-signal-in10"
};

static const _ExtendedGDBusSignalInfo _foo_changing_interface_v10_signal_info_new_signal_in2 =
{
  {
    -1,
    "NewSignalIn2",
    NULL,
    NULL
  },
  "new-signal-in2"
};

static const _ExtendedGDBusSignalInfo _foo_changing_interface_v10_signal_info_baz_signal =
{
  {
    -1,
    "BazSignal",
    NULL,
    NULL
  },
  "baz-signal"
};

static const _ExtendedGDBusSignalInfo _foo_changing_interface_v10_signal_info_bar_signal =
{
  {
    -1,
    "BarSignal",
    NULL,
    NULL
  },
  "bar-signal"
};

static const _ExtendedGDBusSignalInfo _foo_changing_interface_v10_signal_info_foo_signal =
{
  {
    -1,
    "FooSignal",
    NULL,
    NULL
  },
  "foo-signal"
};

static const _ExtendedGDBusSignalInfo * const _foo_changing_interface_v10_signal_info_pointers[] =
{
  &_foo_changing_interface_v10_signal_info_added_signal_in10,
  &_foo_changing_interface_v10_signal_info_new_signal_in2,
  &_foo_changing_interface_v10_signal_info_baz_signal,
  &_foo_changing_interface_v10_signal_info_bar_signal,
  &_foo_changing_interface_v10_signal_info_foo_signal,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_changing_interface_v10_interface_info =
{
  {
    -1,
    "ChangingInterfaceV10",
    (GDBusMethodInfo **) &_foo_changing_interface_v10_method_info_pointers,
    (GDBusSignalInfo **) &_foo_changing_interface_v10_signal_info_pointers,
    NULL,
    NULL
  },
  "changing-interface-v10",
};


/**
 * foo_changing_interface_v10_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-ChangingInterfaceV10.top_of_page">ChangingInterfaceV10</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 *
 * Since: 10.0
 */
GDBusInterfaceInfo *
foo_changing_interface_v10_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_changing_interface_v10_interface_info;
}



/**
 * FooChangingInterfaceV10:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV10.top_of_page">ChangingInterfaceV10</link>.
 *
 * Since: 10.0
 */

/**
 * FooChangingInterfaceV10Iface:
 * @parent_iface: The parent interface.
 * @handle_bar_method: Handler for the #FooChangingInterfaceV10::handle-bar-method signal.
 * @handle_baz_method: Handler for the #FooChangingInterfaceV10::handle-baz-method signal.
 * @handle_foo_method: Handler for the #FooChangingInterfaceV10::handle-foo-method signal.
 * @bar_signal: Handler for the #FooChangingInterfaceV10::bar-signal signal.
 * @baz_signal: Handler for the #FooChangingInterfaceV10::baz-signal signal.
 * @foo_signal: Handler for the #FooChangingInterfaceV10::foo-signal signal.
 * @handle_new_method_in2: Handler for the #FooChangingInterfaceV10::handle-new-method-in2 signal.
 * @new_signal_in2: Handler for the #FooChangingInterfaceV10::new-signal-in2 signal.
 * @handle_added_method_in10: Handler for the #FooChangingInterfaceV10::handle-added-method-in10 signal.
 * @added_signal_in10: Handler for the #FooChangingInterfaceV10::added-signal-in10 signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV10.top_of_page">ChangingInterfaceV10</link>.
 *
 * Since: 10.0
 */

static void
foo_changing_interface_v10_default_init (FooChangingInterfaceV10Iface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooChangingInterfaceV10::handle-added-method-in10:
   * @object: A #FooChangingInterfaceV10.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-ChangingInterfaceV10.AddedMethodIn10">AddedMethodIn10()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_changing_interface_v10_complete_added_method_in10() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   *
   * Since: 10.0
   */
  g_signal_new ("handle-added-method-in10",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooChangingInterfaceV10Iface, handle_added_method_in10),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooChangingInterfaceV10::handle-new-method-in2:
   * @object: A #FooChangingInterfaceV10.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-ChangingInterfaceV10.NewMethodIn2">NewMethodIn2()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_changing_interface_v10_complete_new_method_in2() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   *
   * Since: 2.0
   */
  g_signal_new ("handle-new-method-in2",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooChangingInterfaceV10Iface, handle_new_method_in2),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooChangingInterfaceV10::handle-baz-method:
   * @object: A #FooChangingInterfaceV10.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-ChangingInterfaceV10.BazMethod">BazMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_changing_interface_v10_complete_baz_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-baz-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooChangingInterfaceV10Iface, handle_baz_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooChangingInterfaceV10::handle-bar-method:
   * @object: A #FooChangingInterfaceV10.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-ChangingInterfaceV10.BarMethod">BarMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_changing_interface_v10_complete_bar_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-bar-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooChangingInterfaceV10Iface, handle_bar_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /**
   * FooChangingInterfaceV10::handle-foo-method:
   * @object: A #FooChangingInterfaceV10.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-ChangingInterfaceV10.FooMethod">FooMethod()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_changing_interface_v10_complete_foo_method() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-foo-method",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooChangingInterfaceV10Iface, handle_foo_method),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooChangingInterfaceV10::added-signal-in10:
   * @object: A #FooChangingInterfaceV10.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-ChangingInterfaceV10.AddedSignalIn10">"AddedSignalIn10"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   *
   * Since: 10.0
   */
  g_signal_new ("added-signal-in10",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooChangingInterfaceV10Iface, added_signal_in10),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /**
   * FooChangingInterfaceV10::new-signal-in2:
   * @object: A #FooChangingInterfaceV10.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-ChangingInterfaceV10.NewSignalIn2">"NewSignalIn2"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   *
   * Since: 2.0
   */
  g_signal_new ("new-signal-in2",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooChangingInterfaceV10Iface, new_signal_in2),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /**
   * FooChangingInterfaceV10::baz-signal:
   * @object: A #FooChangingInterfaceV10.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-ChangingInterfaceV10.BazSignal">"BazSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("baz-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooChangingInterfaceV10Iface, baz_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /**
   * FooChangingInterfaceV10::bar-signal:
   * @object: A #FooChangingInterfaceV10.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-ChangingInterfaceV10.BarSignal">"BarSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("bar-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooChangingInterfaceV10Iface, bar_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /**
   * FooChangingInterfaceV10::foo-signal:
   * @object: A #FooChangingInterfaceV10.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-ChangingInterfaceV10.FooSignal">"FooSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("foo-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooChangingInterfaceV10Iface, foo_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

}

typedef FooChangingInterfaceV10Iface FooChangingInterfaceV10Interface;
G_DEFINE_INTERFACE (FooChangingInterfaceV10, foo_changing_interface_v10, G_TYPE_OBJECT);

/**
 * foo_changing_interface_v10_emit_added_signal_in10:
 * @object: A #FooChangingInterfaceV10.
 *
 * Emits the <link linkend="gdbus-signal-ChangingInterfaceV10.AddedSignalIn10">"AddedSignalIn10"</link> D-Bus signal.
 *
 * Since: 10.0
 */
void
foo_changing_interface_v10_emit_added_signal_in10 (
    FooChangingInterfaceV10 *object)
{
  g_signal_emit_by_name (object, "added-signal-in10");
}

/**
 * foo_changing_interface_v10_emit_new_signal_in2:
 * @object: A #FooChangingInterfaceV10.
 *
 * Emits the <link linkend="gdbus-signal-ChangingInterfaceV10.NewSignalIn2">"NewSignalIn2"</link> D-Bus signal.
 *
 * Since: 2.0
 */
void
foo_changing_interface_v10_emit_new_signal_in2 (
    FooChangingInterfaceV10 *object)
{
  g_signal_emit_by_name (object, "new-signal-in2");
}

/**
 * foo_changing_interface_v10_emit_baz_signal:
 * @object: A #FooChangingInterfaceV10.
 *
 * Emits the <link linkend="gdbus-signal-ChangingInterfaceV10.BazSignal">"BazSignal"</link> D-Bus signal.
 */
void
foo_changing_interface_v10_emit_baz_signal (
    FooChangingInterfaceV10 *object)
{
  g_signal_emit_by_name (object, "baz-signal");
}

/**
 * foo_changing_interface_v10_emit_bar_signal:
 * @object: A #FooChangingInterfaceV10.
 *
 * Emits the <link linkend="gdbus-signal-ChangingInterfaceV10.BarSignal">"BarSignal"</link> D-Bus signal.
 */
void
foo_changing_interface_v10_emit_bar_signal (
    FooChangingInterfaceV10 *object)
{
  g_signal_emit_by_name (object, "bar-signal");
}

/**
 * foo_changing_interface_v10_emit_foo_signal:
 * @object: A #FooChangingInterfaceV10.
 *
 * Emits the <link linkend="gdbus-signal-ChangingInterfaceV10.FooSignal">"FooSignal"</link> D-Bus signal.
 */
void
foo_changing_interface_v10_emit_foo_signal (
    FooChangingInterfaceV10 *object)
{
  g_signal_emit_by_name (object, "foo-signal");
}

/**
 * foo_changing_interface_v10_call_added_method_in10:
 * @proxy: A #FooChangingInterfaceV10Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV10.AddedMethodIn10">AddedMethodIn10()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_changing_interface_v10_call_added_method_in10_finish() to get the result of the operation.
 *
 * See foo_changing_interface_v10_call_added_method_in10_sync() for the synchronous, blocking version of this method.
 *
 * Since: 10.0
 */
void
foo_changing_interface_v10_call_added_method_in10 (
    FooChangingInterfaceV10 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "AddedMethodIn10",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_changing_interface_v10_call_added_method_in10_finish:
 * @proxy: A #FooChangingInterfaceV10Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_changing_interface_v10_call_added_method_in10().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_changing_interface_v10_call_added_method_in10().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 *
 * Since: 10.0
 */
gboolean
foo_changing_interface_v10_call_added_method_in10_finish (
    FooChangingInterfaceV10 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_changing_interface_v10_call_added_method_in10_sync:
 * @proxy: A #FooChangingInterfaceV10Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV10.AddedMethodIn10">AddedMethodIn10()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_changing_interface_v10_call_added_method_in10() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 *
 * Since: 10.0
 */
gboolean
foo_changing_interface_v10_call_added_method_in10_sync (
    FooChangingInterfaceV10 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "AddedMethodIn10",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_changing_interface_v10_call_new_method_in2:
 * @proxy: A #FooChangingInterfaceV10Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV10.NewMethodIn2">NewMethodIn2()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_changing_interface_v10_call_new_method_in2_finish() to get the result of the operation.
 *
 * See foo_changing_interface_v10_call_new_method_in2_sync() for the synchronous, blocking version of this method.
 *
 * Since: 2.0
 */
void
foo_changing_interface_v10_call_new_method_in2 (
    FooChangingInterfaceV10 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "NewMethodIn2",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_changing_interface_v10_call_new_method_in2_finish:
 * @proxy: A #FooChangingInterfaceV10Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_changing_interface_v10_call_new_method_in2().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_changing_interface_v10_call_new_method_in2().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 *
 * Since: 2.0
 */
gboolean
foo_changing_interface_v10_call_new_method_in2_finish (
    FooChangingInterfaceV10 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_changing_interface_v10_call_new_method_in2_sync:
 * @proxy: A #FooChangingInterfaceV10Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV10.NewMethodIn2">NewMethodIn2()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_changing_interface_v10_call_new_method_in2() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 *
 * Since: 2.0
 */
gboolean
foo_changing_interface_v10_call_new_method_in2_sync (
    FooChangingInterfaceV10 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "NewMethodIn2",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_changing_interface_v10_call_baz_method:
 * @proxy: A #FooChangingInterfaceV10Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV10.BazMethod">BazMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_changing_interface_v10_call_baz_method_finish() to get the result of the operation.
 *
 * See foo_changing_interface_v10_call_baz_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_changing_interface_v10_call_baz_method (
    FooChangingInterfaceV10 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "BazMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_changing_interface_v10_call_baz_method_finish:
 * @proxy: A #FooChangingInterfaceV10Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_changing_interface_v10_call_baz_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_changing_interface_v10_call_baz_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_changing_interface_v10_call_baz_method_finish (
    FooChangingInterfaceV10 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_changing_interface_v10_call_baz_method_sync:
 * @proxy: A #FooChangingInterfaceV10Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV10.BazMethod">BazMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_changing_interface_v10_call_baz_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_changing_interface_v10_call_baz_method_sync (
    FooChangingInterfaceV10 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "BazMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_changing_interface_v10_call_bar_method:
 * @proxy: A #FooChangingInterfaceV10Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV10.BarMethod">BarMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_changing_interface_v10_call_bar_method_finish() to get the result of the operation.
 *
 * See foo_changing_interface_v10_call_bar_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_changing_interface_v10_call_bar_method (
    FooChangingInterfaceV10 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "BarMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_changing_interface_v10_call_bar_method_finish:
 * @proxy: A #FooChangingInterfaceV10Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_changing_interface_v10_call_bar_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_changing_interface_v10_call_bar_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_changing_interface_v10_call_bar_method_finish (
    FooChangingInterfaceV10 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_changing_interface_v10_call_bar_method_sync:
 * @proxy: A #FooChangingInterfaceV10Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV10.BarMethod">BarMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_changing_interface_v10_call_bar_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_changing_interface_v10_call_bar_method_sync (
    FooChangingInterfaceV10 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "BarMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_changing_interface_v10_call_foo_method:
 * @proxy: A #FooChangingInterfaceV10Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV10.FooMethod">FooMethod()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_changing_interface_v10_call_foo_method_finish() to get the result of the operation.
 *
 * See foo_changing_interface_v10_call_foo_method_sync() for the synchronous, blocking version of this method.
 */
void
foo_changing_interface_v10_call_foo_method (
    FooChangingInterfaceV10 *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "FooMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_changing_interface_v10_call_foo_method_finish:
 * @proxy: A #FooChangingInterfaceV10Proxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_changing_interface_v10_call_foo_method().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_changing_interface_v10_call_foo_method().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_changing_interface_v10_call_foo_method_finish (
    FooChangingInterfaceV10 *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_changing_interface_v10_call_foo_method_sync:
 * @proxy: A #FooChangingInterfaceV10Proxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-ChangingInterfaceV10.FooMethod">FooMethod()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_changing_interface_v10_call_foo_method() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_changing_interface_v10_call_foo_method_sync (
    FooChangingInterfaceV10 *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "FooMethod",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_changing_interface_v10_complete_added_method_in10:
 * @object: A #FooChangingInterfaceV10.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-ChangingInterfaceV10.AddedMethodIn10">AddedMethodIn10()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 *
 * Since: 10.0
 */
void
foo_changing_interface_v10_complete_added_method_in10 (
    FooChangingInterfaceV10 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_changing_interface_v10_complete_new_method_in2:
 * @object: A #FooChangingInterfaceV10.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-ChangingInterfaceV10.NewMethodIn2">NewMethodIn2()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 *
 * Since: 2.0
 */
void
foo_changing_interface_v10_complete_new_method_in2 (
    FooChangingInterfaceV10 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_changing_interface_v10_complete_baz_method:
 * @object: A #FooChangingInterfaceV10.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-ChangingInterfaceV10.BazMethod">BazMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_changing_interface_v10_complete_baz_method (
    FooChangingInterfaceV10 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_changing_interface_v10_complete_bar_method:
 * @object: A #FooChangingInterfaceV10.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-ChangingInterfaceV10.BarMethod">BarMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_changing_interface_v10_complete_bar_method (
    FooChangingInterfaceV10 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/**
 * foo_changing_interface_v10_complete_foo_method:
 * @object: A #FooChangingInterfaceV10.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-ChangingInterfaceV10.FooMethod">FooMethod()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_changing_interface_v10_complete_foo_method (
    FooChangingInterfaceV10 *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FooChangingInterfaceV10Proxy:
 *
 * The #FooChangingInterfaceV10Proxy structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 10.0
 */

/**
 * FooChangingInterfaceV10ProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooChangingInterfaceV10Proxy.
 *
 * Since: 10.0
 */

static void
foo_changing_interface_v10_proxy_iface_init (FooChangingInterfaceV10Iface *iface)
{
}

#define foo_changing_interface_v10_proxy_get_type foo_changing_interface_v10_proxy_get_type
G_DEFINE_TYPE_WITH_CODE (FooChangingInterfaceV10Proxy, foo_changing_interface_v10_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_CHANGING_INTERFACE_V10, foo_changing_interface_v10_proxy_iface_init));
#undef foo_changing_interface_v10_proxy_get_type

static void
foo_changing_interface_v10_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
}

static void
foo_changing_interface_v10_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
}

static void
foo_changing_interface_v10_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_changing_interface_v10_interface_info, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_TYPE_CHANGING_INTERFACE_V10);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_CHANGING_INTERFACE_V10);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_changing_interface_v10_proxy_g_properties_changed (GDBusProxy *proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_changing_interface_v10_interface_info, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_changing_interface_v10_interface_info, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_changing_interface_v10_proxy_init (FooChangingInterfaceV10Proxy *proxy)
{
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_changing_interface_v10_interface_info ());
}

static void
foo_changing_interface_v10_proxy_class_init (FooChangingInterfaceV10ProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->get_property = foo_changing_interface_v10_proxy_get_property;
  gobject_class->set_property = foo_changing_interface_v10_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_changing_interface_v10_proxy_g_signal;
  proxy_class->g_properties_changed = foo_changing_interface_v10_proxy_g_properties_changed;

}

/**
 * foo_changing_interface_v10_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV10.top_of_page">ChangingInterfaceV10</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_changing_interface_v10_proxy_new_finish() to get the result of the operation.
 *
 * See foo_changing_interface_v10_proxy_new_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 10.0
 */
void
foo_changing_interface_v10_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_CHANGING_INTERFACE_V10_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "ChangingInterfaceV10", NULL);
}

/**
 * foo_changing_interface_v10_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_changing_interface_v10_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_changing_interface_v10_proxy_new().
 *
 * Returns: (transfer full) (type FooChangingInterfaceV10Proxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 10.0
 */
FooChangingInterfaceV10 *
foo_changing_interface_v10_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_CHANGING_INTERFACE_V10 (ret);
  else
    return NULL;
}

/**
 * foo_changing_interface_v10_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV10.top_of_page">ChangingInterfaceV10</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_changing_interface_v10_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooChangingInterfaceV10Proxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 10.0
 */
FooChangingInterfaceV10 *
foo_changing_interface_v10_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_CHANGING_INTERFACE_V10_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "ChangingInterfaceV10", NULL);
  if (ret != NULL)
    return FOO_CHANGING_INTERFACE_V10 (ret);
  else
    return NULL;
}


/**
 * foo_changing_interface_v10_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_changing_interface_v10_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_changing_interface_v10_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_changing_interface_v10_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 *
 * Since: 10.0
 */
void
foo_changing_interface_v10_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_CHANGING_INTERFACE_V10_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "ChangingInterfaceV10", NULL);
}

/**
 * foo_changing_interface_v10_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_changing_interface_v10_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_changing_interface_v10_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooChangingInterfaceV10Proxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 10.0
 */
FooChangingInterfaceV10 *
foo_changing_interface_v10_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_CHANGING_INTERFACE_V10 (ret);
  else
    return NULL;
}

/**
 * foo_changing_interface_v10_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_changing_interface_v10_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_changing_interface_v10_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooChangingInterfaceV10Proxy): The constructed proxy object or %NULL if @error is set.
 *
 * Since: 10.0
 */
FooChangingInterfaceV10 *
foo_changing_interface_v10_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_CHANGING_INTERFACE_V10_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "ChangingInterfaceV10", NULL);
  if (ret != NULL)
    return FOO_CHANGING_INTERFACE_V10 (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooChangingInterfaceV10Skeleton:
 *
 * The #FooChangingInterfaceV10Skeleton structure contains only private data and should only be accessed using the provided API.
 *
 * Since: 10.0
 */

/**
 * FooChangingInterfaceV10SkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooChangingInterfaceV10Skeleton.
 *
 * Since: 10.0
 */

struct _FooChangingInterfaceV10SkeletonPrivate
{
  GValueArray *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex *lock;
};

static void
_foo_changing_interface_v10_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooChangingInterfaceV10Skeleton *skeleton = FOO_CHANGING_INTERFACE_V10_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = {0};
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_TYPE_CHANGING_INTERFACE_V10);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
  {
    g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
    g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
  }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_CHANGING_INTERFACE_V10);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_changing_interface_v10_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooChangingInterfaceV10Skeleton *skeleton = FOO_CHANGING_INTERFACE_V10_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_changing_interface_v10_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_changing_interface_v10_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooChangingInterfaceV10Skeleton *skeleton = FOO_CHANGING_INTERFACE_V10_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_changing_interface_v10_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_changing_interface_v10_skeleton_vtable =
{
  _foo_changing_interface_v10_skeleton_handle_method_call,
  _foo_changing_interface_v10_skeleton_handle_get_property,
  _foo_changing_interface_v10_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
foo_changing_interface_v10_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return foo_changing_interface_v10_interface_info ();
}

static GDBusInterfaceVTable *
foo_changing_interface_v10_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_foo_changing_interface_v10_skeleton_vtable;
}

static GVariant *
foo_changing_interface_v10_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooChangingInterfaceV10Skeleton *skeleton = FOO_CHANGING_INTERFACE_V10_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_changing_interface_v10_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_changing_interface_v10_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_changing_interface_v10_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_changing_interface_v10_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV10", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
foo_changing_interface_v10_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void
_foo_changing_interface_v10_on_signal_added_signal_in10 (
    FooChangingInterfaceV10 *object)
{
  FooChangingInterfaceV10Skeleton *skeleton = FOO_CHANGING_INTERFACE_V10_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV10", "AddedSignalIn10",
    g_variant_new ("()"), NULL);
}

static void
_foo_changing_interface_v10_on_signal_new_signal_in2 (
    FooChangingInterfaceV10 *object)
{
  FooChangingInterfaceV10Skeleton *skeleton = FOO_CHANGING_INTERFACE_V10_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV10", "NewSignalIn2",
    g_variant_new ("()"), NULL);
}

static void
_foo_changing_interface_v10_on_signal_baz_signal (
    FooChangingInterfaceV10 *object)
{
  FooChangingInterfaceV10Skeleton *skeleton = FOO_CHANGING_INTERFACE_V10_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV10", "BazSignal",
    g_variant_new ("()"), NULL);
}

static void
_foo_changing_interface_v10_on_signal_bar_signal (
    FooChangingInterfaceV10 *object)
{
  FooChangingInterfaceV10Skeleton *skeleton = FOO_CHANGING_INTERFACE_V10_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV10", "BarSignal",
    g_variant_new ("()"), NULL);
}

static void
_foo_changing_interface_v10_on_signal_foo_signal (
    FooChangingInterfaceV10 *object)
{
  FooChangingInterfaceV10Skeleton *skeleton = FOO_CHANGING_INTERFACE_V10_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "ChangingInterfaceV10", "FooSignal",
    g_variant_new ("()"), NULL);
}

static void
foo_changing_interface_v10_skeleton_iface_init (FooChangingInterfaceV10Iface *iface)
{
  iface->added_signal_in10 = _foo_changing_interface_v10_on_signal_added_signal_in10;
  iface->new_signal_in2 = _foo_changing_interface_v10_on_signal_new_signal_in2;
  iface->baz_signal = _foo_changing_interface_v10_on_signal_baz_signal;
  iface->bar_signal = _foo_changing_interface_v10_on_signal_bar_signal;
  iface->foo_signal = _foo_changing_interface_v10_on_signal_foo_signal;
}

#define foo_changing_interface_v10_skeleton_get_type foo_changing_interface_v10_skeleton_get_type
G_DEFINE_TYPE_WITH_CODE (FooChangingInterfaceV10Skeleton, foo_changing_interface_v10_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_CHANGING_INTERFACE_V10, foo_changing_interface_v10_skeleton_iface_init));
#undef foo_changing_interface_v10_skeleton_get_type

static void
foo_changing_interface_v10_skeleton_finalize (GObject *object)
{
  FooChangingInterfaceV10Skeleton *skeleton = FOO_CHANGING_INTERFACE_V10_SKELETON (object);
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  if (skeleton->priv->context != NULL)
    g_main_context_unref (skeleton->priv->context);
  g_mutex_free (skeleton->priv->lock);
  G_OBJECT_CLASS (foo_changing_interface_v10_skeleton_parent_class)->finalize (object);
}

static void
foo_changing_interface_v10_skeleton_init (FooChangingInterfaceV10Skeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_TYPE_CHANGING_INTERFACE_V10_SKELETON, FooChangingInterfaceV10SkeletonPrivate);
  skeleton->priv->lock = g_mutex_new ();
  skeleton->priv->context = g_main_context_get_thread_default ();
  if (skeleton->priv->context != NULL)
    g_main_context_ref (skeleton->priv->context);
}

static void
foo_changing_interface_v10_skeleton_class_init (FooChangingInterfaceV10SkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (FooChangingInterfaceV10SkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_changing_interface_v10_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_changing_interface_v10_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_changing_interface_v10_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_changing_interface_v10_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_changing_interface_v10_skeleton_dbus_interface_get_vtable;
}

/**
 * foo_changing_interface_v10_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV10.top_of_page">ChangingInterfaceV10</link>.
 *
 * Returns: (transfer full) (type FooChangingInterfaceV10Skeleton): The skeleton object.
 *
 * Since: 10.0
 */
FooChangingInterfaceV10 *
foo_changing_interface_v10_skeleton_new (void)
{
  return FOO_CHANGING_INTERFACE_V10 (g_object_new (FOO_TYPE_CHANGING_INTERFACE_V10_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface TestUglyCaseInterface
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooTesTuglyCASEInterface
 * @title: FooTesTuglyCASEInterface
 * @short_description: Generated C code for the TestUglyCaseInterface D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-TestUglyCaseInterface.top_of_page">TestUglyCaseInterface</link> D-Bus interface in C.
 */

/* ---- Introspection data for TestUglyCaseInterface ---- */

static const _ExtendedGDBusMethodInfo _foo_test_ugly_case_interface_method_info_get_iscsi_servers =
{
  {
    -1,
    "GetiSCSIServers",
    NULL,
    NULL,
    NULL
  },
  "handle-get-iscsi-servers",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_test_ugly_case_interface_method_info_pointers[] =
{
  &_foo_test_ugly_case_interface_method_info_get_iscsi_servers,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_test_ugly_case_interface_signal_info_servers_updated_now =
{
  {
    -1,
    "serversUPDATEDNOW",
    NULL,
    NULL
  },
  "servers-updated-now"
};

static const _ExtendedGDBusSignalInfo * const _foo_test_ugly_case_interface_signal_info_pointers[] =
{
  &_foo_test_ugly_case_interface_signal_info_servers_updated_now,
  NULL
};

static const _ExtendedGDBusPropertyInfo _foo_test_ugly_case_interface_property_info_ugly_name =
{
  {
    -1,
    "UGLYNAME",
    "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "ugly-name",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _foo_test_ugly_case_interface_property_info_pointers[] =
{
  &_foo_test_ugly_case_interface_property_info_ugly_name,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_test_ugly_case_interface_interface_info =
{
  {
    -1,
    "TestUglyCaseInterface",
    (GDBusMethodInfo **) &_foo_test_ugly_case_interface_method_info_pointers,
    (GDBusSignalInfo **) &_foo_test_ugly_case_interface_signal_info_pointers,
    (GDBusPropertyInfo **) &_foo_test_ugly_case_interface_property_info_pointers,
    NULL
  },
  "test-ugly-case-interface",
};


/**
 * foo_test_ugly_case_interface_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-TestUglyCaseInterface.top_of_page">TestUglyCaseInterface</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_test_ugly_case_interface_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_test_ugly_case_interface_interface_info;
}

/**
 * foo_test_ugly_case_interface_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooTesTuglyCASEInterface interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_test_ugly_case_interface_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "ugly-name");
  return property_id_begin - 1;
}



/**
 * FooTesTuglyCASEInterface:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-TestUglyCaseInterface.top_of_page">TestUglyCaseInterface</link>.
 */

/**
 * FooTesTuglyCASEInterfaceIface:
 * @parent_iface: The parent interface.
 * @handle_get_iscsi_servers: Handler for the #FooTesTuglyCASEInterface::handle-get-iscsi-servers signal.
 * @servers_updated_now: Handler for the #FooTesTuglyCASEInterface::servers-updated-now signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-TestUglyCaseInterface.top_of_page">TestUglyCaseInterface</link>.
 */

static void
foo_test_ugly_case_interface_default_init (FooTesTuglyCASEInterfaceIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooTesTuglyCASEInterface::handle-get-iscsi-servers:
   * @object: A #FooTesTuglyCASEInterface.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-TestUglyCaseInterface.GetiSCSIServers">GetiSCSIServers()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_test_ugly_case_interface_complete_get_iscsi_servers() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-get-iscsi-servers",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooTesTuglyCASEInterfaceIface, handle_get_iscsi_servers),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooTesTuglyCASEInterface::servers-updated-now:
   * @object: A #FooTesTuglyCASEInterface.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-TestUglyCaseInterface.serversUPDATEDNOW">"serversUPDATEDNOW"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("servers-updated-now",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooTesTuglyCASEInterfaceIface, servers_updated_now),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /* GObject properties for D-Bus properties: */
  /**
   * FooTesTuglyCASEInterface:ugly-name:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-TestUglyCaseInterface.UGLYNAME">"UGLYNAME"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("ugly-name", "UGLYNAME", "UGLYNAME", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

typedef FooTesTuglyCASEInterfaceIface FooTesTuglyCASEInterfaceInterface;
G_DEFINE_INTERFACE (FooTesTuglyCASEInterface, foo_test_ugly_case_interface, G_TYPE_OBJECT);

/**
 * foo_test_ugly_case_interface_get_ugly_name:
 * @object: A #FooTesTuglyCASEInterface.
 *
 * Gets the value of the <link linkend="gdbus-property-TestUglyCaseInterface.UGLYNAME">"UGLYNAME"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
gint 
foo_test_ugly_case_interface_get_ugly_name (FooTesTuglyCASEInterface *object)
{
  gint value;
  g_object_get (G_OBJECT (object), "ugly-name", &value, NULL);
  return value;
}

/**
 * foo_test_ugly_case_interface_set_ugly_name:
 * @object: A #FooTesTuglyCASEInterface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-TestUglyCaseInterface.UGLYNAME">"UGLYNAME"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_test_ugly_case_interface_set_ugly_name (FooTesTuglyCASEInterface *object, gint value)
{
  g_object_set (G_OBJECT (object), "ugly-name", value, NULL);
}

/**
 * foo_test_ugly_case_interface_emit_servers_updated_now:
 * @object: A #FooTesTuglyCASEInterface.
 *
 * Emits the <link linkend="gdbus-signal-TestUglyCaseInterface.serversUPDATEDNOW">"serversUPDATEDNOW"</link> D-Bus signal.
 */
void
foo_test_ugly_case_interface_emit_servers_updated_now (
    FooTesTuglyCASEInterface *object)
{
  g_signal_emit_by_name (object, "servers-updated-now");
}

/**
 * foo_test_ugly_case_interface_call_get_iscsi_servers:
 * @proxy: A #FooTesTuglyCASEInterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-TestUglyCaseInterface.GetiSCSIServers">GetiSCSIServers()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_test_ugly_case_interface_call_get_iscsi_servers_finish() to get the result of the operation.
 *
 * See foo_test_ugly_case_interface_call_get_iscsi_servers_sync() for the synchronous, blocking version of this method.
 */
void
foo_test_ugly_case_interface_call_get_iscsi_servers (
    FooTesTuglyCASEInterface *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "GetiSCSIServers",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_test_ugly_case_interface_call_get_iscsi_servers_finish:
 * @proxy: A #FooTesTuglyCASEInterfaceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_test_ugly_case_interface_call_get_iscsi_servers().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_test_ugly_case_interface_call_get_iscsi_servers().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_test_ugly_case_interface_call_get_iscsi_servers_finish (
    FooTesTuglyCASEInterface *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_test_ugly_case_interface_call_get_iscsi_servers_sync:
 * @proxy: A #FooTesTuglyCASEInterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-TestUglyCaseInterface.GetiSCSIServers">GetiSCSIServers()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_test_ugly_case_interface_call_get_iscsi_servers() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_test_ugly_case_interface_call_get_iscsi_servers_sync (
    FooTesTuglyCASEInterface *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "GetiSCSIServers",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_test_ugly_case_interface_complete_get_iscsi_servers:
 * @object: A #FooTesTuglyCASEInterface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-TestUglyCaseInterface.GetiSCSIServers">GetiSCSIServers()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_test_ugly_case_interface_complete_get_iscsi_servers (
    FooTesTuglyCASEInterface *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FooTesTuglyCASEInterfaceProxy:
 *
 * The #FooTesTuglyCASEInterfaceProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooTesTuglyCASEInterfaceProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooTesTuglyCASEInterfaceProxy.
 */

static void
foo_test_ugly_case_interface_proxy_iface_init (FooTesTuglyCASEInterfaceIface *iface)
{
}

#define foo_test_ugly_case_interface_proxy_get_type foo_test_ugly_case_interface_proxy_get_type
G_DEFINE_TYPE_WITH_CODE (FooTesTuglyCASEInterfaceProxy, foo_test_ugly_case_interface_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_TEST_UGLY_CASE_INTERFACE, foo_test_ugly_case_interface_proxy_iface_init));
#undef foo_test_ugly_case_interface_proxy_get_type

static void
foo_test_ugly_case_interface_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  info = _foo_test_ugly_case_interface_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
foo_test_ugly_case_interface_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  error = NULL;
  if (!g_dbus_proxy_call_finish (proxy, res, &error))
    {
      g_warning ("Error setting property `%s' on interface TestUglyCaseInterface: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
}

static void
foo_test_ugly_case_interface_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  info = _foo_test_ugly_case_interface_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "TestUglyCaseInterface", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) foo_test_ugly_case_interface_proxy_set_property_cb, (gpointer) info);
  g_variant_unref (variant);
}

static void
foo_test_ugly_case_interface_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_test_ugly_case_interface_interface_info, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_TYPE_TEST_UGLY_CASE_INTERFACE);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_TEST_UGLY_CASE_INTERFACE);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_test_ugly_case_interface_proxy_g_properties_changed (GDBusProxy *proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_test_ugly_case_interface_interface_info, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_test_ugly_case_interface_interface_info, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_test_ugly_case_interface_proxy_init (FooTesTuglyCASEInterfaceProxy *proxy)
{
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_test_ugly_case_interface_interface_info ());
}

static void
foo_test_ugly_case_interface_proxy_class_init (FooTesTuglyCASEInterfaceProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->get_property = foo_test_ugly_case_interface_proxy_get_property;
  gobject_class->set_property = foo_test_ugly_case_interface_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_test_ugly_case_interface_proxy_g_signal;
  proxy_class->g_properties_changed = foo_test_ugly_case_interface_proxy_g_properties_changed;


  foo_test_ugly_case_interface_override_properties (gobject_class, 1);
}

/**
 * foo_test_ugly_case_interface_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-TestUglyCaseInterface.top_of_page">TestUglyCaseInterface</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_test_ugly_case_interface_proxy_new_finish() to get the result of the operation.
 *
 * See foo_test_ugly_case_interface_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_test_ugly_case_interface_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_TEST_UGLY_CASE_INTERFACE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "TestUglyCaseInterface", NULL);
}

/**
 * foo_test_ugly_case_interface_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_test_ugly_case_interface_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_test_ugly_case_interface_proxy_new().
 *
 * Returns: (transfer full) (type FooTesTuglyCASEInterfaceProxy): The constructed proxy object or %NULL if @error is set.
 */
FooTesTuglyCASEInterface *
foo_test_ugly_case_interface_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_TEST_UGLY_CASE_INTERFACE (ret);
  else
    return NULL;
}

/**
 * foo_test_ugly_case_interface_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-TestUglyCaseInterface.top_of_page">TestUglyCaseInterface</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_test_ugly_case_interface_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooTesTuglyCASEInterfaceProxy): The constructed proxy object or %NULL if @error is set.
 */
FooTesTuglyCASEInterface *
foo_test_ugly_case_interface_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_TEST_UGLY_CASE_INTERFACE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "TestUglyCaseInterface", NULL);
  if (ret != NULL)
    return FOO_TEST_UGLY_CASE_INTERFACE (ret);
  else
    return NULL;
}


/**
 * foo_test_ugly_case_interface_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_test_ugly_case_interface_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_test_ugly_case_interface_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_test_ugly_case_interface_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_test_ugly_case_interface_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_TEST_UGLY_CASE_INTERFACE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "TestUglyCaseInterface", NULL);
}

/**
 * foo_test_ugly_case_interface_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_test_ugly_case_interface_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_test_ugly_case_interface_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooTesTuglyCASEInterfaceProxy): The constructed proxy object or %NULL if @error is set.
 */
FooTesTuglyCASEInterface *
foo_test_ugly_case_interface_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_TEST_UGLY_CASE_INTERFACE (ret);
  else
    return NULL;
}

/**
 * foo_test_ugly_case_interface_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_test_ugly_case_interface_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_test_ugly_case_interface_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooTesTuglyCASEInterfaceProxy): The constructed proxy object or %NULL if @error is set.
 */
FooTesTuglyCASEInterface *
foo_test_ugly_case_interface_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_TEST_UGLY_CASE_INTERFACE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "TestUglyCaseInterface", NULL);
  if (ret != NULL)
    return FOO_TEST_UGLY_CASE_INTERFACE (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooTesTuglyCASEInterfaceSkeleton:
 *
 * The #FooTesTuglyCASEInterfaceSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooTesTuglyCASEInterfaceSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooTesTuglyCASEInterfaceSkeleton.
 */

struct _FooTesTuglyCASEInterfaceSkeletonPrivate
{
  GValueArray *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex *lock;
};

static void
_foo_test_ugly_case_interface_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooTesTuglyCASEInterfaceSkeleton *skeleton = FOO_TEST_UGLY_CASE_INTERFACE_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = {0};
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_TYPE_TEST_UGLY_CASE_INTERFACE);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
  {
    g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
    g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
  }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_TEST_UGLY_CASE_INTERFACE);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_test_ugly_case_interface_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooTesTuglyCASEInterfaceSkeleton *skeleton = FOO_TEST_UGLY_CASE_INTERFACE_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_test_ugly_case_interface_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_test_ugly_case_interface_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooTesTuglyCASEInterfaceSkeleton *skeleton = FOO_TEST_UGLY_CASE_INTERFACE_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_test_ugly_case_interface_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_test_ugly_case_interface_skeleton_vtable =
{
  _foo_test_ugly_case_interface_skeleton_handle_method_call,
  _foo_test_ugly_case_interface_skeleton_handle_get_property,
  _foo_test_ugly_case_interface_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
foo_test_ugly_case_interface_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return foo_test_ugly_case_interface_interface_info ();
}

static GDBusInterfaceVTable *
foo_test_ugly_case_interface_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_foo_test_ugly_case_interface_skeleton_vtable;
}

static GVariant *
foo_test_ugly_case_interface_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooTesTuglyCASEInterfaceSkeleton *skeleton = FOO_TEST_UGLY_CASE_INTERFACE_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_test_ugly_case_interface_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_test_ugly_case_interface_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_test_ugly_case_interface_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_test_ugly_case_interface_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "TestUglyCaseInterface", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _foo_test_ugly_case_interface_emit_changed (gpointer user_data);

static void
foo_test_ugly_case_interface_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  FooTesTuglyCASEInterfaceSkeleton *skeleton = FOO_TEST_UGLY_CASE_INTERFACE_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (skeleton->priv->lock);

  if (emit_changed)
    _foo_test_ugly_case_interface_emit_changed (skeleton);
}

static void
_foo_test_ugly_case_interface_on_signal_servers_updated_now (
    FooTesTuglyCASEInterface *object)
{
  FooTesTuglyCASEInterfaceSkeleton *skeleton = FOO_TEST_UGLY_CASE_INTERFACE_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "TestUglyCaseInterface", "serversUPDATEDNOW",
    g_variant_new ("()"), NULL);
}

static void
foo_test_ugly_case_interface_skeleton_iface_init (FooTesTuglyCASEInterfaceIface *iface)
{
  iface->servers_updated_now = _foo_test_ugly_case_interface_on_signal_servers_updated_now;
}

#define foo_test_ugly_case_interface_skeleton_get_type foo_test_ugly_case_interface_skeleton_get_type
G_DEFINE_TYPE_WITH_CODE (FooTesTuglyCASEInterfaceSkeleton, foo_test_ugly_case_interface_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_TEST_UGLY_CASE_INTERFACE, foo_test_ugly_case_interface_skeleton_iface_init));
#undef foo_test_ugly_case_interface_skeleton_get_type

static void
foo_test_ugly_case_interface_skeleton_finalize (GObject *object)
{
  FooTesTuglyCASEInterfaceSkeleton *skeleton = FOO_TEST_UGLY_CASE_INTERFACE_SKELETON (object);
  g_value_array_free (skeleton->priv->properties);
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  if (skeleton->priv->context != NULL)
    g_main_context_unref (skeleton->priv->context);
  g_mutex_free (skeleton->priv->lock);
  G_OBJECT_CLASS (foo_test_ugly_case_interface_skeleton_parent_class)->finalize (object);
}

static void
foo_test_ugly_case_interface_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  FooTesTuglyCASEInterfaceSkeleton *skeleton = FOO_TEST_UGLY_CASE_INTERFACE_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  g_mutex_lock (skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties->values[prop_id - 1], value);
  g_mutex_unlock (skeleton->priv->lock);
}

static gboolean
_foo_test_ugly_case_interface_emit_changed (gpointer user_data)
{
  FooTesTuglyCASEInterfaceSkeleton *skeleton = FOO_TEST_UGLY_CASE_INTERFACE_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties->values[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      g_dbus_connection_emit_signal (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                     NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                     "org.freedesktop.DBus.Properties",
                                     "PropertiesChanged",
                                     g_variant_new ("(sa{sv}as)",
                                                    "TestUglyCaseInterface",
                                                    &builder, &invalidated_builder),
                                     NULL);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (skeleton->priv->lock);
  return FALSE;
}

static void
_foo_test_ugly_case_interface_schedule_emit_changed (FooTesTuglyCASEInterfaceSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
foo_test_ugly_case_interface_skeleton_notify (GObject      *object,
  GParamSpec *pspec)
{
  FooTesTuglyCASEInterfaceSkeleton *skeleton = FOO_TEST_UGLY_CASE_INTERFACE_SKELETON (object);
  g_mutex_lock (skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _foo_test_ugly_case_interface_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (skeleton->priv->lock);
}

static void
foo_test_ugly_case_interface_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  FooTesTuglyCASEInterfaceSkeleton *skeleton = FOO_TEST_UGLY_CASE_INTERFACE_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  g_mutex_lock (skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties->values[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _foo_test_ugly_case_interface_schedule_emit_changed (skeleton, _foo_test_ugly_case_interface_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties->values[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties->values[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
foo_test_ugly_case_interface_skeleton_init (FooTesTuglyCASEInterfaceSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_TYPE_TEST_UGLY_CASE_INTERFACE_SKELETON, FooTesTuglyCASEInterfaceSkeletonPrivate);
  skeleton->priv->lock = g_mutex_new ();
  skeleton->priv->context = g_main_context_get_thread_default ();
  if (skeleton->priv->context != NULL)
    g_main_context_ref (skeleton->priv->context);
  skeleton->priv->properties = g_value_array_new (1);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[0], G_TYPE_INT);
}

static void
foo_test_ugly_case_interface_skeleton_class_init (FooTesTuglyCASEInterfaceSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (FooTesTuglyCASEInterfaceSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_test_ugly_case_interface_skeleton_finalize;
  gobject_class->get_property = foo_test_ugly_case_interface_skeleton_get_property;
  gobject_class->set_property = foo_test_ugly_case_interface_skeleton_set_property;
  gobject_class->notify       = foo_test_ugly_case_interface_skeleton_notify;


  foo_test_ugly_case_interface_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_test_ugly_case_interface_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_test_ugly_case_interface_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_test_ugly_case_interface_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_test_ugly_case_interface_skeleton_dbus_interface_get_vtable;
}

/**
 * foo_test_ugly_case_interface_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-TestUglyCaseInterface.top_of_page">TestUglyCaseInterface</link>.
 *
 * Returns: (transfer full) (type FooTesTuglyCASEInterfaceSkeleton): The skeleton object.
 */
FooTesTuglyCASEInterface *
foo_test_ugly_case_interface_skeleton_new (void)
{
  return FOO_TEST_UGLY_CASE_INTERFACE (g_object_new (FOO_TYPE_TEST_UGLY_CASE_INTERFACE_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface OldieInterface
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooOldieInterface
 * @title: FooOldieInterface
 * @short_description: Generated C code for the OldieInterface D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-OldieInterface.top_of_page">OldieInterface</link> D-Bus interface in C.
 */

/* ---- Introspection data for OldieInterface ---- */

static const GDBusAnnotationInfo _foo_oldie_interface_method_foo_annotation_info_0 =
{
  -1,
  "org.freedesktop.DBus.Deprecated",
  "true",
  NULL
};

static const GDBusAnnotationInfo * const _foo_oldie_interface_method_foo_annotation_info_pointers[] =
{
  &_foo_oldie_interface_method_foo_annotation_info_0,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_oldie_interface_method_info_foo =
{
  {
    -1,
    "Foo",
    NULL,
    NULL,
    (GDBusAnnotationInfo **) &_foo_oldie_interface_method_foo_annotation_info_pointers
  },
  "handle-foo",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_oldie_interface_method_info_pointers[] =
{
  &_foo_oldie_interface_method_info_foo,
  NULL
};

static const GDBusAnnotationInfo _foo_oldie_interface_signal_bar_annotation_info_0 =
{
  -1,
  "org.freedesktop.DBus.Deprecated",
  "true",
  NULL
};

static const GDBusAnnotationInfo * const _foo_oldie_interface_signal_bar_annotation_info_pointers[] =
{
  &_foo_oldie_interface_signal_bar_annotation_info_0,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_oldie_interface_signal_info_bar =
{
  {
    -1,
    "Bar",
    NULL,
    (GDBusAnnotationInfo **) &_foo_oldie_interface_signal_bar_annotation_info_pointers
  },
  "bar"
};

static const _ExtendedGDBusSignalInfo * const _foo_oldie_interface_signal_info_pointers[] =
{
  &_foo_oldie_interface_signal_info_bar,
  NULL
};

static const GDBusAnnotationInfo _foo_oldie_interface_property_bat_annotation_info_0 =
{
  -1,
  "org.freedesktop.DBus.Deprecated",
  "true",
  NULL
};

static const GDBusAnnotationInfo * const _foo_oldie_interface_property_bat_annotation_info_pointers[] =
{
  &_foo_oldie_interface_property_bat_annotation_info_0,
  NULL
};

static const _ExtendedGDBusPropertyInfo _foo_oldie_interface_property_info_bat =
{
  {
    -1,
    "Bat",
    "i",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    (GDBusAnnotationInfo **) &_foo_oldie_interface_property_bat_annotation_info_pointers
  },
  "bat",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _foo_oldie_interface_property_info_pointers[] =
{
  &_foo_oldie_interface_property_info_bat,
  NULL
};

static const GDBusAnnotationInfo _foo_oldie_interface_annotation_info_0 =
{
  -1,
  "org.freedesktop.DBus.Deprecated",
  "true",
  NULL
};

static const GDBusAnnotationInfo * const _foo_oldie_interface_annotation_info_pointers[] =
{
  &_foo_oldie_interface_annotation_info_0,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_oldie_interface_interface_info =
{
  {
    -1,
    "OldieInterface",
    (GDBusMethodInfo **) &_foo_oldie_interface_method_info_pointers,
    (GDBusSignalInfo **) &_foo_oldie_interface_signal_info_pointers,
    (GDBusPropertyInfo **) &_foo_oldie_interface_property_info_pointers,
    (GDBusAnnotationInfo **) &_foo_oldie_interface_annotation_info_pointers
  },
  "oldie-interface",
};


/**
 * foo_oldie_interface_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-OldieInterface.top_of_page">OldieInterface</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
GDBusInterfaceInfo *
foo_oldie_interface_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_oldie_interface_interface_info;
}

/**
 * foo_oldie_interface_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooOldieInterface interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
guint
foo_oldie_interface_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "bat");
  return property_id_begin - 1;
}



/**
 * FooOldieInterface:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-OldieInterface.top_of_page">OldieInterface</link>.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

/**
 * FooOldieInterfaceIface:
 * @parent_iface: The parent interface.
 * @handle_foo: Handler for the #FooOldieInterface::handle-foo signal.
 * @bar: Handler for the #FooOldieInterface::bar signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-OldieInterface.top_of_page">OldieInterface</link>.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

static void
foo_oldie_interface_default_init (FooOldieInterfaceIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooOldieInterface::handle-foo:
   * @object: A #FooOldieInterface.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-OldieInterface.Foo">Foo()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_oldie_interface_complete_foo() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   *
   * Deprecated: The D-Bus method has been deprecated.
   */
  g_signal_new ("handle-foo",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooOldieInterfaceIface, handle_foo),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooOldieInterface::bar:
   * @object: A #FooOldieInterface.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-OldieInterface.Bar">"Bar"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   *
   * Deprecated: The D-Bus signal has been deprecated.
   */
  g_signal_new ("bar",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooOldieInterfaceIface, bar),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /* GObject properties for D-Bus properties: */
  /**
   * FooOldieInterface:bat:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-OldieInterface.Bat">"Bat"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   *
   * Deprecated: The D-Bus property has been deprecated.
   */
  g_object_interface_install_property (iface,
    g_param_spec_int ("bat", "Bat", "Bat", G_MININT32, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

typedef FooOldieInterfaceIface FooOldieInterfaceInterface;
G_DEFINE_INTERFACE (FooOldieInterface, foo_oldie_interface, G_TYPE_OBJECT);

/**
 * foo_oldie_interface_get_bat:
 * @object: A #FooOldieInterface.
 *
 * Gets the value of the <link linkend="gdbus-property-OldieInterface.Bat">"Bat"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 *
 * Deprecated: The D-Bus property has been deprecated.
 */
gint 
foo_oldie_interface_get_bat (FooOldieInterface *object)
{
  gint value;
  g_object_get (G_OBJECT (object), "bat", &value, NULL);
  return value;
}

/**
 * foo_oldie_interface_set_bat:
 * @object: A #FooOldieInterface.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-OldieInterface.Bat">"Bat"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Deprecated: The D-Bus property has been deprecated.
 */
void
foo_oldie_interface_set_bat (FooOldieInterface *object, gint value)
{
  g_object_set (G_OBJECT (object), "bat", value, NULL);
}

/**
 * foo_oldie_interface_emit_bar:
 * @object: A #FooOldieInterface.
 *
 * Emits the <link linkend="gdbus-signal-OldieInterface.Bar">"Bar"</link> D-Bus signal.
 *
 * Deprecated: The D-Bus signal has been deprecated.
 */
void
foo_oldie_interface_emit_bar (
    FooOldieInterface *object)
{
  g_signal_emit_by_name (object, "bar");
}

/**
 * foo_oldie_interface_call_foo:
 * @proxy: A #FooOldieInterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-OldieInterface.Foo">Foo()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_oldie_interface_call_foo_finish() to get the result of the operation.
 *
 * See foo_oldie_interface_call_foo_sync() for the synchronous, blocking version of this method.
 *
 * Deprecated: The D-Bus method has been deprecated.
 */
void
foo_oldie_interface_call_foo (
    FooOldieInterface *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "Foo",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_oldie_interface_call_foo_finish:
 * @proxy: A #FooOldieInterfaceProxy.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_oldie_interface_call_foo().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_oldie_interface_call_foo().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 *
 * Deprecated: The D-Bus method has been deprecated.
 */
gboolean
foo_oldie_interface_call_foo_finish (
    FooOldieInterface *proxy,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_oldie_interface_call_foo_sync:
 * @proxy: A #FooOldieInterfaceProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-OldieInterface.Foo">Foo()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_oldie_interface_call_foo() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 *
 * Deprecated: The D-Bus method has been deprecated.
 */
gboolean
foo_oldie_interface_call_foo_sync (
    FooOldieInterface *proxy,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "Foo",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "()");
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_oldie_interface_complete_foo:
 * @object: A #FooOldieInterface.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-OldieInterface.Foo">Foo()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 *
 * Deprecated: The D-Bus method has been deprecated.
 */
void
foo_oldie_interface_complete_foo (
    FooOldieInterface *object,
    GDBusMethodInvocation *invocation)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("()"));
}

/* ------------------------------------------------------------------------ */

/**
 * FooOldieInterfaceProxy:
 *
 * The #FooOldieInterfaceProxy structure contains only private data and should only be accessed using the provided API.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

/**
 * FooOldieInterfaceProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooOldieInterfaceProxy.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

static void
foo_oldie_interface_proxy_iface_init (FooOldieInterfaceIface *iface)
{
}

#define foo_oldie_interface_proxy_get_type foo_oldie_interface_proxy_get_type
G_DEFINE_TYPE_WITH_CODE (FooOldieInterfaceProxy, foo_oldie_interface_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_OLDIE_INTERFACE, foo_oldie_interface_proxy_iface_init));
#undef foo_oldie_interface_proxy_get_type

static void
foo_oldie_interface_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  info = _foo_oldie_interface_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
foo_oldie_interface_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  error = NULL;
  if (!g_dbus_proxy_call_finish (proxy, res, &error))
    {
      g_warning ("Error setting property `%s' on interface OldieInterface: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
}

static void
foo_oldie_interface_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  info = _foo_oldie_interface_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "OldieInterface", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) foo_oldie_interface_proxy_set_property_cb, (gpointer) info);
  g_variant_unref (variant);
}

static void
foo_oldie_interface_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_oldie_interface_interface_info, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_TYPE_OLDIE_INTERFACE);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_OLDIE_INTERFACE);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_oldie_interface_proxy_g_properties_changed (GDBusProxy *proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_oldie_interface_interface_info, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_oldie_interface_interface_info, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_oldie_interface_proxy_init (FooOldieInterfaceProxy *proxy)
{
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_oldie_interface_interface_info ());
}

static void
foo_oldie_interface_proxy_class_init (FooOldieInterfaceProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->get_property = foo_oldie_interface_proxy_get_property;
  gobject_class->set_property = foo_oldie_interface_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_oldie_interface_proxy_g_signal;
  proxy_class->g_properties_changed = foo_oldie_interface_proxy_g_properties_changed;


  foo_oldie_interface_override_properties (gobject_class, 1);
}

/**
 * foo_oldie_interface_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-OldieInterface.top_of_page">OldieInterface</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_oldie_interface_proxy_new_finish() to get the result of the operation.
 *
 * See foo_oldie_interface_proxy_new_sync() for the synchronous, blocking version of this constructor.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
void
foo_oldie_interface_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_OLDIE_INTERFACE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "OldieInterface", NULL);
}

/**
 * foo_oldie_interface_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_oldie_interface_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_oldie_interface_proxy_new().
 *
 * Returns: (transfer full) (type FooOldieInterfaceProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
FooOldieInterface *
foo_oldie_interface_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_OLDIE_INTERFACE (ret);
  else
    return NULL;
}

/**
 * foo_oldie_interface_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-OldieInterface.top_of_page">OldieInterface</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_oldie_interface_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooOldieInterfaceProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
FooOldieInterface *
foo_oldie_interface_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_OLDIE_INTERFACE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "OldieInterface", NULL);
  if (ret != NULL)
    return FOO_OLDIE_INTERFACE (ret);
  else
    return NULL;
}


/**
 * foo_oldie_interface_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_oldie_interface_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_oldie_interface_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_oldie_interface_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
void
foo_oldie_interface_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_OLDIE_INTERFACE_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "OldieInterface", NULL);
}

/**
 * foo_oldie_interface_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_oldie_interface_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_oldie_interface_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooOldieInterfaceProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
FooOldieInterface *
foo_oldie_interface_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_OLDIE_INTERFACE (ret);
  else
    return NULL;
}

/**
 * foo_oldie_interface_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_oldie_interface_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_oldie_interface_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooOldieInterfaceProxy): The constructed proxy object or %NULL if @error is set.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
FooOldieInterface *
foo_oldie_interface_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_OLDIE_INTERFACE_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "OldieInterface", NULL);
  if (ret != NULL)
    return FOO_OLDIE_INTERFACE (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooOldieInterfaceSkeleton:
 *
 * The #FooOldieInterfaceSkeleton structure contains only private data and should only be accessed using the provided API.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

/**
 * FooOldieInterfaceSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooOldieInterfaceSkeleton.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */

struct _FooOldieInterfaceSkeletonPrivate
{
  GValueArray *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex *lock;
};

static void
_foo_oldie_interface_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooOldieInterfaceSkeleton *skeleton = FOO_OLDIE_INTERFACE_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = {0};
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_TYPE_OLDIE_INTERFACE);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
  {
    g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
    g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
  }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_OLDIE_INTERFACE);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_oldie_interface_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooOldieInterfaceSkeleton *skeleton = FOO_OLDIE_INTERFACE_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_oldie_interface_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_oldie_interface_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooOldieInterfaceSkeleton *skeleton = FOO_OLDIE_INTERFACE_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_oldie_interface_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_oldie_interface_skeleton_vtable =
{
  _foo_oldie_interface_skeleton_handle_method_call,
  _foo_oldie_interface_skeleton_handle_get_property,
  _foo_oldie_interface_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
foo_oldie_interface_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return foo_oldie_interface_interface_info ();
}

static GDBusInterfaceVTable *
foo_oldie_interface_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_foo_oldie_interface_skeleton_vtable;
}

static GVariant *
foo_oldie_interface_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooOldieInterfaceSkeleton *skeleton = FOO_OLDIE_INTERFACE_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_oldie_interface_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_oldie_interface_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_oldie_interface_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_oldie_interface_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "OldieInterface", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _foo_oldie_interface_emit_changed (gpointer user_data);

static void
foo_oldie_interface_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  FooOldieInterfaceSkeleton *skeleton = FOO_OLDIE_INTERFACE_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (skeleton->priv->lock);

  if (emit_changed)
    _foo_oldie_interface_emit_changed (skeleton);
}

static void
_foo_oldie_interface_on_signal_bar (
    FooOldieInterface *object)
{
  FooOldieInterfaceSkeleton *skeleton = FOO_OLDIE_INTERFACE_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "OldieInterface", "Bar",
    g_variant_new ("()"), NULL);
}

static void
foo_oldie_interface_skeleton_iface_init (FooOldieInterfaceIface *iface)
{
  iface->bar = _foo_oldie_interface_on_signal_bar;
}

#define foo_oldie_interface_skeleton_get_type foo_oldie_interface_skeleton_get_type
G_DEFINE_TYPE_WITH_CODE (FooOldieInterfaceSkeleton, foo_oldie_interface_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_OLDIE_INTERFACE, foo_oldie_interface_skeleton_iface_init));
#undef foo_oldie_interface_skeleton_get_type

static void
foo_oldie_interface_skeleton_finalize (GObject *object)
{
  FooOldieInterfaceSkeleton *skeleton = FOO_OLDIE_INTERFACE_SKELETON (object);
  g_value_array_free (skeleton->priv->properties);
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  if (skeleton->priv->context != NULL)
    g_main_context_unref (skeleton->priv->context);
  g_mutex_free (skeleton->priv->lock);
  G_OBJECT_CLASS (foo_oldie_interface_skeleton_parent_class)->finalize (object);
}

static void
foo_oldie_interface_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  FooOldieInterfaceSkeleton *skeleton = FOO_OLDIE_INTERFACE_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  g_mutex_lock (skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties->values[prop_id - 1], value);
  g_mutex_unlock (skeleton->priv->lock);
}

static gboolean
_foo_oldie_interface_emit_changed (gpointer user_data)
{
  FooOldieInterfaceSkeleton *skeleton = FOO_OLDIE_INTERFACE_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties->values[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      g_dbus_connection_emit_signal (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                     NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                     "org.freedesktop.DBus.Properties",
                                     "PropertiesChanged",
                                     g_variant_new ("(sa{sv}as)",
                                                    "OldieInterface",
                                                    &builder, &invalidated_builder),
                                     NULL);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (skeleton->priv->lock);
  return FALSE;
}

static void
_foo_oldie_interface_schedule_emit_changed (FooOldieInterfaceSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
foo_oldie_interface_skeleton_notify (GObject      *object,
  GParamSpec *pspec)
{
  FooOldieInterfaceSkeleton *skeleton = FOO_OLDIE_INTERFACE_SKELETON (object);
  g_mutex_lock (skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _foo_oldie_interface_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (skeleton->priv->lock);
}

static void
foo_oldie_interface_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  FooOldieInterfaceSkeleton *skeleton = FOO_OLDIE_INTERFACE_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  g_mutex_lock (skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties->values[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _foo_oldie_interface_schedule_emit_changed (skeleton, _foo_oldie_interface_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties->values[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties->values[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
foo_oldie_interface_skeleton_init (FooOldieInterfaceSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_TYPE_OLDIE_INTERFACE_SKELETON, FooOldieInterfaceSkeletonPrivate);
  skeleton->priv->lock = g_mutex_new ();
  skeleton->priv->context = g_main_context_get_thread_default ();
  if (skeleton->priv->context != NULL)
    g_main_context_ref (skeleton->priv->context);
  skeleton->priv->properties = g_value_array_new (1);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[0], G_TYPE_INT);
}

static void
foo_oldie_interface_skeleton_class_init (FooOldieInterfaceSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (FooOldieInterfaceSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_oldie_interface_skeleton_finalize;
  gobject_class->get_property = foo_oldie_interface_skeleton_get_property;
  gobject_class->set_property = foo_oldie_interface_skeleton_set_property;
  gobject_class->notify       = foo_oldie_interface_skeleton_notify;


  foo_oldie_interface_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_oldie_interface_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_oldie_interface_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_oldie_interface_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_oldie_interface_skeleton_dbus_interface_get_vtable;
}

/**
 * foo_oldie_interface_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-OldieInterface.top_of_page">OldieInterface</link>.
 *
 * Returns: (transfer full) (type FooOldieInterfaceSkeleton): The skeleton object.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
FooOldieInterface *
foo_oldie_interface_skeleton_new (void)
{
  return FOO_OLDIE_INTERFACE (g_object_new (FOO_TYPE_OLDIE_INTERFACE_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface UnknownXmlTags
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooUnknownXmlTags
 * @title: FooUnknownXmlTags
 * @short_description: Generated C code for the UnknownXmlTags D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-UnknownXmlTags.top_of_page">UnknownXmlTags</link> D-Bus interface in C.
 */

/* ---- Introspection data for UnknownXmlTags ---- */

static const _ExtendedGDBusArgInfo _foo_unknown_xml_tags_method_info_can_set_timezone_OUT_ARG_value =
{
  {
    -1,
    "value",
    "i",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_unknown_xml_tags_method_info_can_set_timezone_OUT_ARG_pointers[] =
{
  &_foo_unknown_xml_tags_method_info_can_set_timezone_OUT_ARG_value,
  NULL
};

static const GDBusAnnotationInfo _foo_unknown_xml_tags_method_can_set_timezone_annotation_info_0 =
{
  -1,
  "org.freedesktop.DBus.GLib.Async",
  "",
  NULL
};

static const GDBusAnnotationInfo * const _foo_unknown_xml_tags_method_can_set_timezone_annotation_info_pointers[] =
{
  &_foo_unknown_xml_tags_method_can_set_timezone_annotation_info_0,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_unknown_xml_tags_method_info_can_set_timezone =
{
  {
    -1,
    "CanSetTimezone",
    NULL,
    (GDBusArgInfo **) &_foo_unknown_xml_tags_method_info_can_set_timezone_OUT_ARG_pointers,
    (GDBusAnnotationInfo **) &_foo_unknown_xml_tags_method_can_set_timezone_annotation_info_pointers
  },
  "handle-can-set-timezone",
  FALSE
};

static const _ExtendedGDBusMethodInfo * const _foo_unknown_xml_tags_method_info_pointers[] =
{
  &_foo_unknown_xml_tags_method_info_can_set_timezone,
  NULL
};

static const _ExtendedGDBusSignalInfo _foo_unknown_xml_tags_signal_info_some_signal =
{
  {
    -1,
    "SomeSignal",
    NULL,
    NULL
  },
  "some-signal"
};

static const _ExtendedGDBusSignalInfo * const _foo_unknown_xml_tags_signal_info_pointers[] =
{
  &_foo_unknown_xml_tags_signal_info_some_signal,
  NULL
};

static const _ExtendedGDBusPropertyInfo _foo_unknown_xml_tags_property_info_some_property =
{
  {
    -1,
    "SomeProperty",
    "s",
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE,
    NULL
  },
  "some-property",
  FALSE
};

static const _ExtendedGDBusPropertyInfo * const _foo_unknown_xml_tags_property_info_pointers[] =
{
  &_foo_unknown_xml_tags_property_info_some_property,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_unknown_xml_tags_interface_info =
{
  {
    -1,
    "UnknownXmlTags",
    (GDBusMethodInfo **) &_foo_unknown_xml_tags_method_info_pointers,
    (GDBusSignalInfo **) &_foo_unknown_xml_tags_signal_info_pointers,
    (GDBusPropertyInfo **) &_foo_unknown_xml_tags_property_info_pointers,
    NULL
  },
  "unknown-xml-tags",
};


/**
 * foo_unknown_xml_tags_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-UnknownXmlTags.top_of_page">UnknownXmlTags</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_unknown_xml_tags_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_unknown_xml_tags_interface_info;
}

/**
 * foo_unknown_xml_tags_override_properties:
 * @klass: The class structure for a #GObject<!-- -->-derived class.
 * @property_id_begin: The property id to assign to the first overridden property.
 *
 * Overrides all #GObject properties in the #FooUnknownXmlTags interface for a concrete class.
 * The properties are overridden in the order they are defined.
 *
 * Returns: The last property id.
 */
guint
foo_unknown_xml_tags_override_properties (GObjectClass *klass, guint property_id_begin)
{
  g_object_class_override_property (klass, property_id_begin++, "some-property");
  return property_id_begin - 1;
}



/**
 * FooUnknownXmlTags:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-UnknownXmlTags.top_of_page">UnknownXmlTags</link>.
 */

/**
 * FooUnknownXmlTagsIface:
 * @parent_iface: The parent interface.
 * @handle_can_set_timezone: Handler for the #FooUnknownXmlTags::handle-can-set-timezone signal.
 * @some_signal: Handler for the #FooUnknownXmlTags::some-signal signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-UnknownXmlTags.top_of_page">UnknownXmlTags</link>.
 */

static void
foo_unknown_xml_tags_default_init (FooUnknownXmlTagsIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooUnknownXmlTags::handle-can-set-timezone:
   * @object: A #FooUnknownXmlTags.
   * @invocation: A #GDBusMethodInvocation.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-UnknownXmlTags.CanSetTimezone">CanSetTimezone()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_unknown_xml_tags_complete_can_set_timezone() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-can-set-timezone",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooUnknownXmlTagsIface, handle_can_set_timezone),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    1,
    G_TYPE_DBUS_METHOD_INVOCATION);

  /* GObject signals for received D-Bus signals: */
  /**
   * FooUnknownXmlTags::some-signal:
   * @object: A #FooUnknownXmlTags.
   *
   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-UnknownXmlTags.SomeSignal">"SomeSignal"</link> is received.
   *
   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
   */
  g_signal_new ("some-signal",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooUnknownXmlTagsIface, some_signal),
    NULL,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_NONE,
    0);

  /* GObject properties for D-Bus properties: */
  /**
   * FooUnknownXmlTags:some-property:
   *
   * Represents the D-Bus property <link linkend="gdbus-property-UnknownXmlTags.SomeProperty">"SomeProperty"</link>.
   *
   * Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side.
   */
  g_object_interface_install_property (iface,
    g_param_spec_string ("some-property", "SomeProperty", "SomeProperty", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
}

typedef FooUnknownXmlTagsIface FooUnknownXmlTagsInterface;
G_DEFINE_INTERFACE (FooUnknownXmlTags, foo_unknown_xml_tags, G_TYPE_OBJECT);

/**
 * foo_unknown_xml_tags_get_some_property:
 * @object: A #FooUnknownXmlTags.
 *
 * Gets the value of the <link linkend="gdbus-property-UnknownXmlTags.SomeProperty">"SomeProperty"</link> D-Bus property.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 *
 * Returns: (transfer none): The property value.
 */
const gchar *
foo_unknown_xml_tags_get_some_property (FooUnknownXmlTags *object)
{
  const gchar *value;
  g_object_get (G_OBJECT (object), "some-property", &value, NULL);
  if (value != NULL)
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-some-property", (gpointer) value, (GDestroyNotify) g_free);
  else
    g_object_set_data_full (G_OBJECT (object), "-x-memoizing-some-property", (gpointer) value, NULL);
  return value;
}

/**
 * foo_unknown_xml_tags_set_some_property:
 * @object: A #FooUnknownXmlTags.
 * @value: The value to set.
 *
 * Sets the <link linkend="gdbus-property-UnknownXmlTags.SomeProperty">"SomeProperty"</link> D-Bus property to @value.
 *
 * Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side.
 */
void
foo_unknown_xml_tags_set_some_property (FooUnknownXmlTags *object, const gchar *value)
{
  g_object_set (G_OBJECT (object), "some-property", value, NULL);
}

/**
 * foo_unknown_xml_tags_emit_some_signal:
 * @object: A #FooUnknownXmlTags.
 *
 * Emits the <link linkend="gdbus-signal-UnknownXmlTags.SomeSignal">"SomeSignal"</link> D-Bus signal.
 */
void
foo_unknown_xml_tags_emit_some_signal (
    FooUnknownXmlTags *object)
{
  g_signal_emit_by_name (object, "some-signal");
}

/**
 * foo_unknown_xml_tags_call_can_set_timezone:
 * @proxy: A #FooUnknownXmlTagsProxy.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-UnknownXmlTags.CanSetTimezone">CanSetTimezone()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_unknown_xml_tags_call_can_set_timezone_finish() to get the result of the operation.
 *
 * See foo_unknown_xml_tags_call_can_set_timezone_sync() for the synchronous, blocking version of this method.
 */
void
foo_unknown_xml_tags_call_can_set_timezone (
    FooUnknownXmlTags *proxy,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
    "CanSetTimezone",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_unknown_xml_tags_call_can_set_timezone_finish:
 * @proxy: A #FooUnknownXmlTagsProxy.
 * @out_value: (out): Return location for return parameter or %NULL to ignore.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_unknown_xml_tags_call_can_set_timezone().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_unknown_xml_tags_call_can_set_timezone().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_unknown_xml_tags_call_can_set_timezone_finish (
    FooUnknownXmlTags *proxy,
    gint *out_value,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(i)",
                 out_value);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_unknown_xml_tags_call_can_set_timezone_sync:
 * @proxy: A #FooUnknownXmlTagsProxy.
 * @out_value: (out): Return location for return parameter or %NULL to ignore.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-UnknownXmlTags.CanSetTimezone">CanSetTimezone()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_unknown_xml_tags_call_can_set_timezone() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_unknown_xml_tags_call_can_set_timezone_sync (
    FooUnknownXmlTags *proxy,
    gint *out_value,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
    "CanSetTimezone",
    g_variant_new ("()"),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(i)",
                 out_value);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_unknown_xml_tags_complete_can_set_timezone:
 * @object: A #FooUnknownXmlTags.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @value: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-UnknownXmlTags.CanSetTimezone">CanSetTimezone()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_unknown_xml_tags_complete_can_set_timezone (
    FooUnknownXmlTags *object,
    GDBusMethodInvocation *invocation,
    gint value)
{
  g_dbus_method_invocation_return_value (invocation,
    g_variant_new ("(i)",
                   value));
}

/* ------------------------------------------------------------------------ */

/**
 * FooUnknownXmlTagsProxy:
 *
 * The #FooUnknownXmlTagsProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooUnknownXmlTagsProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooUnknownXmlTagsProxy.
 */

static void
foo_unknown_xml_tags_proxy_iface_init (FooUnknownXmlTagsIface *iface)
{
}

#define foo_unknown_xml_tags_proxy_get_type foo_unknown_xml_tags_proxy_get_type
G_DEFINE_TYPE_WITH_CODE (FooUnknownXmlTagsProxy, foo_unknown_xml_tags_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_UNKNOWN_XML_TAGS, foo_unknown_xml_tags_proxy_iface_init));
#undef foo_unknown_xml_tags_proxy_get_type

static void
foo_unknown_xml_tags_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  info = _foo_unknown_xml_tags_property_info_pointers[prop_id - 1];
  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);
  if (info->use_gvariant)
    {
      g_value_set_variant (value, variant);
    }
  else
    {
      if (variant != NULL)
        g_dbus_gvariant_to_gvalue (variant, value);
    }
  if (variant != NULL)
    g_variant_unref (variant);
}

static void
foo_unknown_xml_tags_proxy_set_property_cb (GDBusProxy *proxy,
  GAsyncResult *res,
  gpointer      user_data)
{
  const _ExtendedGDBusPropertyInfo *info = user_data;
  GError *error;
  error = NULL;
  if (!g_dbus_proxy_call_finish (proxy, res, &error))
    {
      g_warning ("Error setting property `%s' on interface UnknownXmlTags: %s (%s, %d)",
                 info->parent_struct.name, 
                 error->message, g_quark_to_string (error->domain), error->code);
      g_error_free (error);
    }
}

static void
foo_unknown_xml_tags_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  const _ExtendedGDBusPropertyInfo *info;
  GVariant *variant;
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  info = _foo_unknown_xml_tags_property_info_pointers[prop_id - 1];
  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));
  g_dbus_proxy_call (G_DBUS_PROXY (object),
    "org.freedesktop.DBus.Properties.Set",
    g_variant_new ("(ssv)", "UnknownXmlTags", info->parent_struct.name, variant),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    NULL, (GAsyncReadyCallback) foo_unknown_xml_tags_proxy_set_property_cb, (gpointer) info);
  g_variant_unref (variant);
}

static void
foo_unknown_xml_tags_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_unknown_xml_tags_interface_info, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_TYPE_UNKNOWN_XML_TAGS);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_UNKNOWN_XML_TAGS);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_unknown_xml_tags_proxy_g_properties_changed (GDBusProxy *proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_unknown_xml_tags_interface_info, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_unknown_xml_tags_interface_info, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_unknown_xml_tags_proxy_init (FooUnknownXmlTagsProxy *proxy)
{
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_unknown_xml_tags_interface_info ());
}

static void
foo_unknown_xml_tags_proxy_class_init (FooUnknownXmlTagsProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->get_property = foo_unknown_xml_tags_proxy_get_property;
  gobject_class->set_property = foo_unknown_xml_tags_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_unknown_xml_tags_proxy_g_signal;
  proxy_class->g_properties_changed = foo_unknown_xml_tags_proxy_g_properties_changed;


  foo_unknown_xml_tags_override_properties (gobject_class, 1);
}

/**
 * foo_unknown_xml_tags_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-UnknownXmlTags.top_of_page">UnknownXmlTags</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_unknown_xml_tags_proxy_new_finish() to get the result of the operation.
 *
 * See foo_unknown_xml_tags_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_unknown_xml_tags_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_UNKNOWN_XML_TAGS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "UnknownXmlTags", NULL);
}

/**
 * foo_unknown_xml_tags_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_unknown_xml_tags_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_unknown_xml_tags_proxy_new().
 *
 * Returns: (transfer full) (type FooUnknownXmlTagsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooUnknownXmlTags *
foo_unknown_xml_tags_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_UNKNOWN_XML_TAGS (ret);
  else
    return NULL;
}

/**
 * foo_unknown_xml_tags_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-UnknownXmlTags.top_of_page">UnknownXmlTags</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_unknown_xml_tags_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooUnknownXmlTagsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooUnknownXmlTags *
foo_unknown_xml_tags_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_UNKNOWN_XML_TAGS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "UnknownXmlTags", NULL);
  if (ret != NULL)
    return FOO_UNKNOWN_XML_TAGS (ret);
  else
    return NULL;
}


/**
 * foo_unknown_xml_tags_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_unknown_xml_tags_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_unknown_xml_tags_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_unknown_xml_tags_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_unknown_xml_tags_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_UNKNOWN_XML_TAGS_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "UnknownXmlTags", NULL);
}

/**
 * foo_unknown_xml_tags_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_unknown_xml_tags_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_unknown_xml_tags_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooUnknownXmlTagsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooUnknownXmlTags *
foo_unknown_xml_tags_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_UNKNOWN_XML_TAGS (ret);
  else
    return NULL;
}

/**
 * foo_unknown_xml_tags_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_unknown_xml_tags_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_unknown_xml_tags_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooUnknownXmlTagsProxy): The constructed proxy object or %NULL if @error is set.
 */
FooUnknownXmlTags *
foo_unknown_xml_tags_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_UNKNOWN_XML_TAGS_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "UnknownXmlTags", NULL);
  if (ret != NULL)
    return FOO_UNKNOWN_XML_TAGS (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooUnknownXmlTagsSkeleton:
 *
 * The #FooUnknownXmlTagsSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooUnknownXmlTagsSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooUnknownXmlTagsSkeleton.
 */

struct _FooUnknownXmlTagsSkeletonPrivate
{
  GValueArray *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex *lock;
};

static void
_foo_unknown_xml_tags_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooUnknownXmlTagsSkeleton *skeleton = FOO_UNKNOWN_XML_TAGS_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = {0};
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_TYPE_UNKNOWN_XML_TAGS);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
  {
    g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
    g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
  }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_UNKNOWN_XML_TAGS);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_unknown_xml_tags_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooUnknownXmlTagsSkeleton *skeleton = FOO_UNKNOWN_XML_TAGS_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_unknown_xml_tags_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_unknown_xml_tags_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooUnknownXmlTagsSkeleton *skeleton = FOO_UNKNOWN_XML_TAGS_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_unknown_xml_tags_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_unknown_xml_tags_skeleton_vtable =
{
  _foo_unknown_xml_tags_skeleton_handle_method_call,
  _foo_unknown_xml_tags_skeleton_handle_get_property,
  _foo_unknown_xml_tags_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
foo_unknown_xml_tags_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return foo_unknown_xml_tags_interface_info ();
}

static GDBusInterfaceVTable *
foo_unknown_xml_tags_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_foo_unknown_xml_tags_skeleton_vtable;
}

static GVariant *
foo_unknown_xml_tags_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooUnknownXmlTagsSkeleton *skeleton = FOO_UNKNOWN_XML_TAGS_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_unknown_xml_tags_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_unknown_xml_tags_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_unknown_xml_tags_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_unknown_xml_tags_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "UnknownXmlTags", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static gboolean _foo_unknown_xml_tags_emit_changed (gpointer user_data);

static void
foo_unknown_xml_tags_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
  FooUnknownXmlTagsSkeleton *skeleton = FOO_UNKNOWN_XML_TAGS_SKELETON (_skeleton);
  gboolean emit_changed = FALSE;

  g_mutex_lock (skeleton->priv->lock);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    {
      g_source_destroy (skeleton->priv->changed_properties_idle_source);
      skeleton->priv->changed_properties_idle_source = NULL;
      emit_changed = TRUE;
    }
  g_mutex_unlock (skeleton->priv->lock);

  if (emit_changed)
    _foo_unknown_xml_tags_emit_changed (skeleton);
}

static void
_foo_unknown_xml_tags_on_signal_some_signal (
    FooUnknownXmlTags *object)
{
  FooUnknownXmlTagsSkeleton *skeleton = FOO_UNKNOWN_XML_TAGS_SKELETON (object);
  GDBusConnection *connection = g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton));
  if (connection == NULL)
    return;
  g_dbus_connection_emit_signal (connection,
    NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "UnknownXmlTags", "SomeSignal",
    g_variant_new ("()"), NULL);
}

static void
foo_unknown_xml_tags_skeleton_iface_init (FooUnknownXmlTagsIface *iface)
{
  iface->some_signal = _foo_unknown_xml_tags_on_signal_some_signal;
}

#define foo_unknown_xml_tags_skeleton_get_type foo_unknown_xml_tags_skeleton_get_type
G_DEFINE_TYPE_WITH_CODE (FooUnknownXmlTagsSkeleton, foo_unknown_xml_tags_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_UNKNOWN_XML_TAGS, foo_unknown_xml_tags_skeleton_iface_init));
#undef foo_unknown_xml_tags_skeleton_get_type

static void
foo_unknown_xml_tags_skeleton_finalize (GObject *object)
{
  FooUnknownXmlTagsSkeleton *skeleton = FOO_UNKNOWN_XML_TAGS_SKELETON (object);
  g_value_array_free (skeleton->priv->properties);
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  if (skeleton->priv->context != NULL)
    g_main_context_unref (skeleton->priv->context);
  g_mutex_free (skeleton->priv->lock);
  G_OBJECT_CLASS (foo_unknown_xml_tags_skeleton_parent_class)->finalize (object);
}

static void
foo_unknown_xml_tags_skeleton_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  FooUnknownXmlTagsSkeleton *skeleton = FOO_UNKNOWN_XML_TAGS_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  g_mutex_lock (skeleton->priv->lock);
  g_value_copy (&skeleton->priv->properties->values[prop_id - 1], value);
  g_mutex_unlock (skeleton->priv->lock);
}

static gboolean
_foo_unknown_xml_tags_emit_changed (gpointer user_data)
{
  FooUnknownXmlTagsSkeleton *skeleton = FOO_UNKNOWN_XML_TAGS_SKELETON (user_data);
  GList *l;
  GVariantBuilder builder;
  GVariantBuilder invalidated_builder;
  guint num_changes;

  g_mutex_lock (skeleton->priv->lock);
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));
  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)
    {
      ChangedProperty *cp = l->data;
      GVariant *variant;
      const GValue *cur_value;

      cur_value = &skeleton->priv->properties->values[cp->prop_id - 1];
      if (!_g_value_equal (cur_value, &cp->orig_value))
        {
          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));
          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);
          g_variant_unref (variant);
          num_changes++;
        }
    }
  if (num_changes > 0)
    {
      g_dbus_connection_emit_signal (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                     NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),
                                     "org.freedesktop.DBus.Properties",
                                     "PropertiesChanged",
                                     g_variant_new ("(sa{sv}as)",
                                                    "UnknownXmlTags",
                                                    &builder, &invalidated_builder),
                                     NULL);
    }
  else
    {
      g_variant_builder_clear (&builder);
      g_variant_builder_clear (&invalidated_builder);
    }
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  skeleton->priv->changed_properties = NULL;
  skeleton->priv->changed_properties_idle_source = NULL;
  g_mutex_unlock (skeleton->priv->lock);
  return FALSE;
}

static void
_foo_unknown_xml_tags_schedule_emit_changed (FooUnknownXmlTagsSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)
{
  ChangedProperty *cp;
  GList *l;
  cp = NULL;
  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)
    {
      ChangedProperty *i_cp = l->data;
      if (i_cp->info == info)
        {
          cp = i_cp;
          break;
        }
    }
  if (cp == NULL)
    {
      cp = g_new0 (ChangedProperty, 1);
      cp->prop_id = prop_id;
      cp->info = info;
      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);
      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));
      g_value_copy (orig_value, &cp->orig_value);
    }
}

static void
foo_unknown_xml_tags_skeleton_notify (GObject      *object,
  GParamSpec *pspec)
{
  FooUnknownXmlTagsSkeleton *skeleton = FOO_UNKNOWN_XML_TAGS_SKELETON (object);
  g_mutex_lock (skeleton->priv->lock);
  if (skeleton->priv->changed_properties != NULL &&
      skeleton->priv->changed_properties_idle_source == NULL)
    {
      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();
      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);
      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _foo_unknown_xml_tags_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);
      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);
      g_source_unref (skeleton->priv->changed_properties_idle_source);
    }
  g_mutex_unlock (skeleton->priv->lock);
}

static void
foo_unknown_xml_tags_skeleton_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  FooUnknownXmlTagsSkeleton *skeleton = FOO_UNKNOWN_XML_TAGS_SKELETON (object);
  g_assert (prop_id != 0 && prop_id - 1 < 1);
  g_mutex_lock (skeleton->priv->lock);
  g_object_freeze_notify (object);
  if (!_g_value_equal (value, &skeleton->priv->properties->values[prop_id - 1]))
    {
      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL)
        _foo_unknown_xml_tags_schedule_emit_changed (skeleton, _foo_unknown_xml_tags_property_info_pointers[prop_id - 1], prop_id, &skeleton->priv->properties->values[prop_id - 1]);
      g_value_copy (value, &skeleton->priv->properties->values[prop_id - 1]);
      g_object_notify_by_pspec (object, pspec);
    }
  g_mutex_unlock (skeleton->priv->lock);
  g_object_thaw_notify (object);
}

static void
foo_unknown_xml_tags_skeleton_init (FooUnknownXmlTagsSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_TYPE_UNKNOWN_XML_TAGS_SKELETON, FooUnknownXmlTagsSkeletonPrivate);
  skeleton->priv->lock = g_mutex_new ();
  skeleton->priv->context = g_main_context_get_thread_default ();
  if (skeleton->priv->context != NULL)
    g_main_context_ref (skeleton->priv->context);
  skeleton->priv->properties = g_value_array_new (1);
  g_value_array_append (skeleton->priv->properties, NULL);
  g_value_init (&skeleton->priv->properties->values[0], G_TYPE_STRING);
}

static void
foo_unknown_xml_tags_skeleton_class_init (FooUnknownXmlTagsSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (FooUnknownXmlTagsSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_unknown_xml_tags_skeleton_finalize;
  gobject_class->get_property = foo_unknown_xml_tags_skeleton_get_property;
  gobject_class->set_property = foo_unknown_xml_tags_skeleton_set_property;
  gobject_class->notify       = foo_unknown_xml_tags_skeleton_notify;


  foo_unknown_xml_tags_override_properties (gobject_class, 1);

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_unknown_xml_tags_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_unknown_xml_tags_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_unknown_xml_tags_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_unknown_xml_tags_skeleton_dbus_interface_get_vtable;
}

/**
 * foo_unknown_xml_tags_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-UnknownXmlTags.top_of_page">UnknownXmlTags</link>.
 *
 * Returns: (transfer full) (type FooUnknownXmlTagsSkeleton): The skeleton object.
 */
FooUnknownXmlTags *
foo_unknown_xml_tags_skeleton_new (void)
{
  return FOO_UNKNOWN_XML_TAGS (g_object_new (FOO_TYPE_UNKNOWN_XML_TAGS_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for interface FDPassing
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooFDPassing
 * @title: FooFDPassing
 * @short_description: Generated C code for the FDPassing D-Bus interface
 *
 * This section contains code for working with the <link linkend="gdbus-interface-FDPassing.top_of_page">FDPassing</link> D-Bus interface in C.
 */

/* ---- Introspection data for FDPassing ---- */

static const _ExtendedGDBusArgInfo _foo_fdpassing_method_info_hello_fd_IN_ARG_greeting =
{
  {
    -1,
    "greeting",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_fdpassing_method_info_hello_fd_IN_ARG_pointers[] =
{
  &_foo_fdpassing_method_info_hello_fd_IN_ARG_greeting,
  NULL
};

static const _ExtendedGDBusArgInfo _foo_fdpassing_method_info_hello_fd_OUT_ARG_response =
{
  {
    -1,
    "response",
    "s",
    NULL
  },
  FALSE
};

static const _ExtendedGDBusArgInfo * const _foo_fdpassing_method_info_hello_fd_OUT_ARG_pointers[] =
{
  &_foo_fdpassing_method_info_hello_fd_OUT_ARG_response,
  NULL
};

static const _ExtendedGDBusMethodInfo _foo_fdpassing_method_info_hello_fd =
{
  {
    -1,
    "HelloFD",
    (GDBusArgInfo **) &_foo_fdpassing_method_info_hello_fd_IN_ARG_pointers,
    (GDBusArgInfo **) &_foo_fdpassing_method_info_hello_fd_OUT_ARG_pointers,
    NULL
  },
  "handle-hello-fd",
  TRUE
};

static const _ExtendedGDBusMethodInfo * const _foo_fdpassing_method_info_pointers[] =
{
  &_foo_fdpassing_method_info_hello_fd,
  NULL
};

static const _ExtendedGDBusInterfaceInfo _foo_fdpassing_interface_info =
{
  {
    -1,
    "FDPassing",
    (GDBusMethodInfo **) &_foo_fdpassing_method_info_pointers,
    NULL,
    NULL,
    NULL
  },
  "fdpassing",
};


/**
 * foo_fdpassing_interface_info:
 *
 * Gets a machine-readable description of the <link linkend="gdbus-interface-FDPassing.top_of_page">FDPassing</link> D-Bus interface.
 *
 * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
 */
GDBusInterfaceInfo *
foo_fdpassing_interface_info (void)
{
  return (GDBusInterfaceInfo *) &_foo_fdpassing_interface_info;
}



/**
 * FooFDPassing:
 *
 * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-FDPassing.top_of_page">FDPassing</link>.
 */

/**
 * FooFDPassingIface:
 * @parent_iface: The parent interface.
 * @handle_hello_fd: Handler for the #FooFDPassing::handle-hello-fd signal.
 *
 * Virtual table for the D-Bus interface <link linkend="gdbus-interface-FDPassing.top_of_page">FDPassing</link>.
 */

static void
foo_fdpassing_default_init (FooFDPassingIface *iface)
{
  /* GObject signals for incoming D-Bus method calls: */
  /**
   * FooFDPassing::handle-hello-fd:
   * @object: A #FooFDPassing.
   * @invocation: A #GDBusMethodInvocation.
   * @fd_list: (allow-none): A #GUnixFDList or %NULL.
   * @greeting: Argument passed by remote caller.
   *
   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-FDPassing.HelloFD">HelloFD()</link> D-Bus method.
   *
   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call foo_fdpassing_complete_hello_fd() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
   *
   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
   */
  g_signal_new ("handle-hello-fd",
    G_TYPE_FROM_INTERFACE (iface),
    G_SIGNAL_RUN_LAST,
    G_STRUCT_OFFSET (FooFDPassingIface, handle_hello_fd),
    g_signal_accumulator_true_handled,
    NULL,
    g_cclosure_marshal_generic,
    G_TYPE_BOOLEAN,
    3,
    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_UNIX_FD_LIST, G_TYPE_STRING);

}

typedef FooFDPassingIface FooFDPassingInterface;
G_DEFINE_INTERFACE (FooFDPassing, foo_fdpassing, G_TYPE_OBJECT);

/**
 * foo_fdpassing_call_hello_fd:
 * @proxy: A #FooFDPassingProxy.
 * @greeting: Argument to pass with the method invocation.
 * @fd_list: (allow-none): A #GUnixFDList or %NULL.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously invokes the <link linkend="gdbus-method-FDPassing.HelloFD">HelloFD()</link> D-Bus method on @proxy.
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_fdpassing_call_hello_fd_finish() to get the result of the operation.
 *
 * See foo_fdpassing_call_hello_fd_sync() for the synchronous, blocking version of this method.
 */
void
foo_fdpassing_call_hello_fd (
    FooFDPassing *proxy,
    const gchar *greeting,
    GUnixFDList *fd_list,
    GCancellable *cancellable,
    GAsyncReadyCallback callback,
    gpointer user_data)
{
  g_dbus_proxy_call_with_unix_fd_list (G_DBUS_PROXY (proxy),
    "HelloFD",
    g_variant_new ("(s)",
                   greeting),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    fd_list,
    cancellable,
    callback,
    user_data);
}

/**
 * foo_fdpassing_call_hello_fd_finish:
 * @proxy: A #FooFDPassingProxy.
 * @out_response: (out): Return location for return parameter or %NULL to ignore.
 * @out_fd_list: (out): Return location for a #GUnixFDList or %NULL.
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_fdpassing_call_hello_fd().
 * @error: Return location for error or %NULL.
 *
 * Finishes an operation started with foo_fdpassing_call_hello_fd().
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_fdpassing_call_hello_fd_finish (
    FooFDPassing *proxy,
    gchar **out_response,
    GUnixFDList **out_fd_list,
    GAsyncResult *res,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_with_unix_fd_list_finish (G_DBUS_PROXY (proxy), out_fd_list, res, error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_response);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_fdpassing_call_hello_fd_sync:
 * @proxy: A #FooFDPassingProxy.
 * @greeting: Argument to pass with the method invocation.
 * @fd_list: (allow-none): A #GUnixFDList or %NULL.
 * @out_response: (out): Return location for return parameter or %NULL to ignore.
 * @out_fd_list: (out): Return location for a #GUnixFDList or %NULL.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL.
 *
 * Synchronously invokes the <link linkend="gdbus-method-FDPassing.HelloFD">HelloFD()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
 *
 * See foo_fdpassing_call_hello_fd() for the asynchronous version of this method.
 *
 * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
 */
gboolean
foo_fdpassing_call_hello_fd_sync (
    FooFDPassing *proxy,
    const gchar *greeting,
    GUnixFDList  *fd_list,
    gchar **out_response,
    GUnixFDList **out_fd_list,
    GCancellable *cancellable,
    GError **error)
{
  GVariant *_ret;
  _ret = g_dbus_proxy_call_with_unix_fd_list_sync (G_DBUS_PROXY (proxy),
    "HelloFD",
    g_variant_new ("(s)",
                   greeting),
    G_DBUS_CALL_FLAGS_NONE,
    -1,
    fd_list,
    out_fd_list,
    cancellable,
    error);
  if (_ret == NULL)
    goto _out;
  g_variant_get (_ret,
                 "(s)",
                 out_response);
  g_variant_unref (_ret);
_out:
  return _ret != NULL;
}

/**
 * foo_fdpassing_complete_hello_fd:
 * @object: A #FooFDPassing.
 * @invocation: (transfer full): A #GDBusMethodInvocation.
 * @fd_list: (allow-none): A #GUnixFDList or %NULL.
 * @response: Parameter to return.
 *
 * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-FDPassing.HelloFD">HelloFD()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
 *
 * This method will free @invocation, you cannot use it afterwards.
 */
void
foo_fdpassing_complete_hello_fd (
    FooFDPassing *object,
    GDBusMethodInvocation *invocation,
    GUnixFDList *fd_list,
    const gchar *response)
{
  g_dbus_method_invocation_return_value_with_unix_fd_list (invocation,
    g_variant_new ("(s)",
                   response),
    fd_list);
}

/* ------------------------------------------------------------------------ */

/**
 * FooFDPassingProxy:
 *
 * The #FooFDPassingProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooFDPassingProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooFDPassingProxy.
 */

static void
foo_fdpassing_proxy_iface_init (FooFDPassingIface *iface)
{
}

#define foo_fdpassing_proxy_get_type foo_fdpassing_proxy_get_type
G_DEFINE_TYPE_WITH_CODE (FooFDPassingProxy, foo_fdpassing_proxy, G_TYPE_DBUS_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_FDPASSING, foo_fdpassing_proxy_iface_init));
#undef foo_fdpassing_proxy_get_type

static void
foo_fdpassing_proxy_get_property (GObject      *object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
}

static void
foo_fdpassing_proxy_set_property (GObject      *object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
}

static void
foo_fdpassing_proxy_g_signal (GDBusProxy *proxy,
  const gchar *sender_name,
  const gchar *signal_name,
  GVariant *parameters)
{
  _ExtendedGDBusSignalInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint n;
  guint signal_id;
  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_foo_fdpassing_interface_info, signal_name);
  if (info == NULL)
    return;
  num_params = g_variant_n_children (parameters);
  paramv = g_new0 (GValue, num_params + 1);
  g_value_init (&paramv[0], FOO_TYPE_FDPASSING);
  g_value_set_object (&paramv[0], proxy);
  g_variant_iter_init (&iter, parameters);
  n = 1;
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_FDPASSING);
  g_signal_emitv (paramv, signal_id, 0, NULL);
  for (n = 0; n < num_params + 1; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static void
foo_fdpassing_proxy_g_properties_changed (GDBusProxy *proxy,
  GVariant *changed_properties,
  const gchar *const *invalidated_properties)
{
  guint n;
  const gchar *key;
  GVariantIter *iter;
  _ExtendedGDBusPropertyInfo *info;
  g_variant_get (changed_properties, "a{sv}", &iter);
  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_fdpassing_interface_info, key);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
  g_variant_iter_free (iter);
  for (n = 0; invalidated_properties[n] != NULL; n++)
    {
      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_fdpassing_interface_info, invalidated_properties[n]);
      if (info != NULL)
        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
    }
}

static void
foo_fdpassing_proxy_init (FooFDPassingProxy *proxy)
{
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), foo_fdpassing_interface_info ());
}

static void
foo_fdpassing_proxy_class_init (FooFDPassingProxyClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->get_property = foo_fdpassing_proxy_get_property;
  gobject_class->set_property = foo_fdpassing_proxy_set_property;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class->g_signal = foo_fdpassing_proxy_g_signal;
  proxy_class->g_properties_changed = foo_fdpassing_proxy_g_properties_changed;

}

/**
 * foo_fdpassing_proxy_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-FDPassing.top_of_page">FDPassing</link>. See g_dbus_proxy_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_fdpassing_proxy_new_finish() to get the result of the operation.
 *
 * See foo_fdpassing_proxy_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_fdpassing_proxy_new (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_FDPASSING_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "FDPassing", NULL);
}

/**
 * foo_fdpassing_proxy_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_fdpassing_proxy_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_fdpassing_proxy_new().
 *
 * Returns: (transfer full) (type FooFDPassingProxy): The constructed proxy object or %NULL if @error is set.
 */
FooFDPassing *
foo_fdpassing_proxy_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_FDPASSING (ret);
  else
    return NULL;
}

/**
 * foo_fdpassing_proxy_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-FDPassing.top_of_page">FDPassing</link>. See g_dbus_proxy_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_fdpassing_proxy_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooFDPassingProxy): The constructed proxy object or %NULL if @error is set.
 */
FooFDPassing *
foo_fdpassing_proxy_new_sync (
    GDBusConnection     *connection,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_FDPASSING_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "FDPassing", NULL);
  if (ret != NULL)
    return FOO_FDPASSING (ret);
  else
    return NULL;
}


/**
 * foo_fdpassing_proxy_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_fdpassing_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_fdpassing_proxy_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_fdpassing_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_fdpassing_proxy_new_for_bus (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GAsyncReadyCallback  callback,
    gpointer             user_data)
{
  g_async_initable_new_async (FOO_TYPE_FDPASSING_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "FDPassing", NULL);
}

/**
 * foo_fdpassing_proxy_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_fdpassing_proxy_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_fdpassing_proxy_new_for_bus().
 *
 * Returns: (transfer full) (type FooFDPassingProxy): The constructed proxy object or %NULL if @error is set.
 */
FooFDPassing *
foo_fdpassing_proxy_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return FOO_FDPASSING (ret);
  else
    return NULL;
}

/**
 * foo_fdpassing_proxy_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusProxyFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_fdpassing_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_fdpassing_proxy_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooFDPassingProxy): The constructed proxy object or %NULL if @error is set.
 */
FooFDPassing *
foo_fdpassing_proxy_new_for_bus_sync (
    GBusType             bus_type,
    GDBusProxyFlags      flags,
    const gchar         *name,
    const gchar         *object_path,
    GCancellable        *cancellable,
    GError             **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_FDPASSING_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "FDPassing", NULL);
  if (ret != NULL)
    return FOO_FDPASSING (ret);
  else
    return NULL;
}


/* ------------------------------------------------------------------------ */

/**
 * FooFDPassingSkeleton:
 *
 * The #FooFDPassingSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooFDPassingSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooFDPassingSkeleton.
 */

struct _FooFDPassingSkeletonPrivate
{
  GValueArray *properties;
  GList *changed_properties;
  GSource *changed_properties_idle_source;
  GMainContext *context;
  GMutex *lock;
};

static void
_foo_fdpassing_skeleton_handle_method_call (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *method_name,
  GVariant *parameters,
  GDBusMethodInvocation *invocation,
  gpointer user_data)
{
  FooFDPassingSkeleton *skeleton = FOO_FDPASSING_SKELETON (user_data);
  _ExtendedGDBusMethodInfo *info;
  GVariantIter iter;
  GVariant *child;
  GValue *paramv;
  guint num_params;
  guint num_extra;
  guint n;
  guint signal_id;
  GValue return_value = {0};
  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
  g_assert (info != NULL);
  num_params = g_variant_n_children (parameters);
  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
  n = 0;
  g_value_init (&paramv[n], FOO_TYPE_FDPASSING);
  g_value_set_object (&paramv[n++], skeleton);
  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
  g_value_set_object (&paramv[n++], invocation);
  if (info->pass_fdlist)
  {
    g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
    g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
  }
  g_variant_iter_init (&iter, parameters);
  while ((child = g_variant_iter_next_value (&iter)) != NULL)
    {
      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
      if (arg_info->use_gvariant)
        {
          g_value_init (&paramv[n], G_TYPE_VARIANT);
          g_value_set_variant (&paramv[n], child);
          n++;
        }
      else
        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
      g_variant_unref (child);
    }
  signal_id = g_signal_lookup (info->signal_name, FOO_TYPE_FDPASSING);
  g_value_init (&return_value, G_TYPE_BOOLEAN);
  g_signal_emitv (paramv, signal_id, 0, &return_value);
  if (!g_value_get_boolean (&return_value))
    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
  g_value_unset (&return_value);
  for (n = 0; n < num_params + num_extra; n++)
    g_value_unset (&paramv[n]);
  g_free (paramv);
}

static GVariant *
_foo_fdpassing_skeleton_handle_get_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GError **error,
  gpointer user_data)
{
  FooFDPassingSkeleton *skeleton = FOO_FDPASSING_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  GVariant *ret;
  ret = NULL;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_fdpassing_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      g_value_init (&value, pspec->value_type);
      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
      g_value_unset (&value);
    }
  return ret;
}

static gboolean
_foo_fdpassing_skeleton_handle_set_property (
  GDBusConnection *connection,
  const gchar *sender,
  const gchar *object_path,
  const gchar *interface_name,
  const gchar *property_name,
  GVariant *variant,
  GError **error,
  gpointer user_data)
{
  FooFDPassingSkeleton *skeleton = FOO_FDPASSING_SKELETON (user_data);
  GValue value = {0};
  GParamSpec *pspec;
  _ExtendedGDBusPropertyInfo *info;
  gboolean ret;
  ret = FALSE;
  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_foo_fdpassing_interface_info, property_name);
  g_assert (info != NULL);
  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
  if (pspec == NULL)
    {
      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
    }
  else
    {
      if (info->use_gvariant)
        g_value_set_variant (&value, variant);
      else
        g_dbus_gvariant_to_gvalue (variant, &value);
      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
      g_value_unset (&value);
      ret = TRUE;
    }
  return ret;
}

static const GDBusInterfaceVTable _foo_fdpassing_skeleton_vtable =
{
  _foo_fdpassing_skeleton_handle_method_call,
  _foo_fdpassing_skeleton_handle_get_property,
  _foo_fdpassing_skeleton_handle_set_property
};

static GDBusInterfaceInfo *
foo_fdpassing_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton)
{
  return foo_fdpassing_interface_info ();
}

static GDBusInterfaceVTable *
foo_fdpassing_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton)
{
  return (GDBusInterfaceVTable *) &_foo_fdpassing_skeleton_vtable;
}

static GVariant *
foo_fdpassing_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
{
  FooFDPassingSkeleton *skeleton = FOO_FDPASSING_SKELETON (_skeleton);

  GVariantBuilder builder;
  guint n;
  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
  if (_foo_fdpassing_interface_info.parent_struct.properties == NULL)
    goto out;
  for (n = 0; _foo_fdpassing_interface_info.parent_struct.properties[n] != NULL; n++)
    {
      GDBusPropertyInfo *info = _foo_fdpassing_interface_info.parent_struct.properties[n];
      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
        {
          GVariant *value;
          value = _foo_fdpassing_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "FDPassing", info->name, NULL, skeleton);
          if (value != NULL)
            {
              g_variant_take_ref (value);
              g_variant_builder_add (&builder, "{sv}", info->name, value);
              g_variant_unref (value);
            }
        }
    }
out:
  return g_variant_builder_end (&builder);
}

static void
foo_fdpassing_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
{
}

static void
foo_fdpassing_skeleton_iface_init (FooFDPassingIface *iface)
{
}

#define foo_fdpassing_skeleton_get_type foo_fdpassing_skeleton_get_type
G_DEFINE_TYPE_WITH_CODE (FooFDPassingSkeleton, foo_fdpassing_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_FDPASSING, foo_fdpassing_skeleton_iface_init));
#undef foo_fdpassing_skeleton_get_type

static void
foo_fdpassing_skeleton_finalize (GObject *object)
{
  FooFDPassingSkeleton *skeleton = FOO_FDPASSING_SKELETON (object);
  g_list_foreach (skeleton->priv->changed_properties, (GFunc) _changed_property_free, NULL);
  g_list_free (skeleton->priv->changed_properties);
  if (skeleton->priv->changed_properties_idle_source != NULL)
    g_source_destroy (skeleton->priv->changed_properties_idle_source);
  if (skeleton->priv->context != NULL)
    g_main_context_unref (skeleton->priv->context);
  g_mutex_free (skeleton->priv->lock);
  G_OBJECT_CLASS (foo_fdpassing_skeleton_parent_class)->finalize (object);
}

static void
foo_fdpassing_skeleton_init (FooFDPassingSkeleton *skeleton)
{
  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, FOO_TYPE_FDPASSING_SKELETON, FooFDPassingSkeletonPrivate);
  skeleton->priv->lock = g_mutex_new ();
  skeleton->priv->context = g_main_context_get_thread_default ();
  if (skeleton->priv->context != NULL)
    g_main_context_ref (skeleton->priv->context);
}

static void
foo_fdpassing_skeleton_class_init (FooFDPassingSkeletonClass *klass)
{
  GObjectClass *gobject_class;
  GDBusInterfaceSkeletonClass *skeleton_class;

  g_type_class_add_private (klass, sizeof (FooFDPassingSkeletonPrivate));

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class->finalize = foo_fdpassing_skeleton_finalize;

  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
  skeleton_class->get_info = foo_fdpassing_skeleton_dbus_interface_get_info;
  skeleton_class->get_properties = foo_fdpassing_skeleton_dbus_interface_get_properties;
  skeleton_class->flush = foo_fdpassing_skeleton_dbus_interface_flush;
  skeleton_class->get_vtable = foo_fdpassing_skeleton_dbus_interface_get_vtable;
}

/**
 * foo_fdpassing_skeleton_new:
 *
 * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-FDPassing.top_of_page">FDPassing</link>.
 *
 * Returns: (transfer full) (type FooFDPassingSkeleton): The skeleton object.
 */
FooFDPassing *
foo_fdpassing_skeleton_new (void)
{
  return FOO_FDPASSING (g_object_new (FOO_TYPE_FDPASSING_SKELETON, NULL));
}

/* ------------------------------------------------------------------------
 * Code for Object, ObjectProxy and ObjectSkeleton
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooObject
 * @title: FooObject
 * @short_description: Specialized GDBusObject types
 *
 * This section contains the #FooObject, #FooObjectProxy, and #FooObjectSkeleton types which make it easier to work with objects implementing generated types for D-Bus interfaces.
 */

/**
 * FooObject:
 *
 * The #FooObject type is a specialized container of interfaces.
 */

/**
 * FooObjectIface:
 * @parent_iface: The parent interface.
 *
 * Virtual table for the #FooObject interface.
 */

static void
foo_object_default_init (FooObjectIface *iface)
{
  /**
   * FooObject:bar:
   *
   * The #FooBar instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("bar", "bar", "bar", FOO_TYPE_BAR, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooObject:bar-frobnicator:
   *
   * The #FooBarFrobnicator instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("bar-frobnicator", "bar-frobnicator", "bar-frobnicator", FOO_TYPE_BAR_FROBNICATOR, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooObject:baz:
   *
   * The #FooBaz instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("baz", "baz", "baz", FOO_TYPE_BAZ, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooObject:com-acme-coyote:
   *
   * The #FooComAcmeCoyote instance corresponding to the D-Bus interface <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("com-acme-coyote", "com-acme-coyote", "com-acme-coyote", FOO_TYPE_COM_ACME_COYOTE, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooObject:rocket123:
   *
   * The #FooRocket123 instance corresponding to the D-Bus interface <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("rocket123", "rocket123", "rocket123", FOO_TYPE_ROCKET123, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooObject:bat:
   *
   * The #FooBat instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("bat", "bat", "bat", FOO_TYPE_BAT, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooObject:authorize:
   *
   * The #FooAuthorize instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("authorize", "authorize", "authorize", FOO_TYPE_AUTHORIZE, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooObject:method-threads:
   *
   * The #FooMethodThreads instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("method-threads", "method-threads", "method-threads", FOO_TYPE_METHOD_THREADS, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooObject:inline-docs:
   *
   * The #FooInlineDocs instance corresponding to the D-Bus interface <link linkend="gdbus-interface-org-project-InlineDocs.top_of_page">org.project.InlineDocs</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("inline-docs", "inline-docs", "inline-docs", FOO_TYPE_INLINE_DOCS, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooObject:changing-interface-v1:
   *
   * The #FooChangingInterfaceV1 instance corresponding to the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV1.top_of_page">ChangingInterfaceV1</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("changing-interface-v1", "changing-interface-v1", "changing-interface-v1", FOO_TYPE_CHANGING_INTERFACE_V1, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooObject:changing-interface-v2:
   *
   * The #FooChangingInterfaceV2 instance corresponding to the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV2.top_of_page">ChangingInterfaceV2</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   *
   * Since: 2.0
   */
  g_object_interface_install_property (iface, g_param_spec_object ("changing-interface-v2", "changing-interface-v2", "changing-interface-v2", FOO_TYPE_CHANGING_INTERFACE_V2, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooObject:changing-interface-v10:
   *
   * The #FooChangingInterfaceV10 instance corresponding to the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV10.top_of_page">ChangingInterfaceV10</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   *
   * Since: 10.0
   */
  g_object_interface_install_property (iface, g_param_spec_object ("changing-interface-v10", "changing-interface-v10", "changing-interface-v10", FOO_TYPE_CHANGING_INTERFACE_V10, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooObject:test-ugly-case-interface:
   *
   * The #FooTesTuglyCASEInterface instance corresponding to the D-Bus interface <link linkend="gdbus-interface-TestUglyCaseInterface.top_of_page">TestUglyCaseInterface</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("test-ugly-case-interface", "test-ugly-case-interface", "test-ugly-case-interface", FOO_TYPE_TEST_UGLY_CASE_INTERFACE, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooObject:oldie-interface:
   *
   * The #FooOldieInterface instance corresponding to the D-Bus interface <link linkend="gdbus-interface-OldieInterface.top_of_page">OldieInterface</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   *
   * Deprecated: The D-Bus interface has been deprecated.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("oldie-interface", "oldie-interface", "oldie-interface", FOO_TYPE_OLDIE_INTERFACE, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooObject:unknown-xml-tags:
   *
   * The #FooUnknownXmlTags instance corresponding to the D-Bus interface <link linkend="gdbus-interface-UnknownXmlTags.top_of_page">UnknownXmlTags</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("unknown-xml-tags", "unknown-xml-tags", "unknown-xml-tags", FOO_TYPE_UNKNOWN_XML_TAGS, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

  /**
   * FooObject:fdpassing:
   *
   * The #FooFDPassing instance corresponding to the D-Bus interface <link linkend="gdbus-interface-FDPassing.top_of_page">FDPassing</link>, if any.
   *
   * Connect to the #GObject::notify signal to get informed of property changes.
   */
  g_object_interface_install_property (iface, g_param_spec_object ("fdpassing", "fdpassing", "fdpassing", FOO_TYPE_FDPASSING, G_PARAM_READWRITE|G_PARAM_STATIC_STRINGS));

}

typedef FooObjectIface FooObjectInterface;
G_DEFINE_INTERFACE_WITH_CODE (FooObject, foo_object, G_TYPE_OBJECT, g_type_interface_add_prerequisite (g_define_type_id, G_TYPE_DBUS_OBJECT));

/**
 * foo_object_get_bar:
 * @object: A #FooObject.
 *
 * Gets the #FooBar instance for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooBar that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooBar *foo_object_get_bar (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Bar");
  if (ret == NULL)
    return NULL;
  return FOO_BAR (ret);
}

/**
 * foo_object_get_bar_frobnicator:
 * @object: A #FooObject.
 *
 * Gets the #FooBarFrobnicator instance for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooBarFrobnicator that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooBarFrobnicator *foo_object_get_bar_frobnicator (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Bar.Frobnicator");
  if (ret == NULL)
    return NULL;
  return FOO_BAR_FROBNICATOR (ret);
}

/**
 * foo_object_get_baz:
 * @object: A #FooObject.
 *
 * Gets the #FooBaz instance for the D-Bus interface <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooBaz that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooBaz *foo_object_get_baz (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Baz");
  if (ret == NULL)
    return NULL;
  return FOO_BAZ (ret);
}

/**
 * foo_object_get_com_acme_coyote:
 * @object: A #FooObject.
 *
 * Gets the #FooComAcmeCoyote instance for the D-Bus interface <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooComAcmeCoyote that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooComAcmeCoyote *foo_object_get_com_acme_coyote (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "com.acme.Coyote");
  if (ret == NULL)
    return NULL;
  return FOO_COM_ACME_COYOTE (ret);
}

/**
 * foo_object_get_rocket123:
 * @object: A #FooObject.
 *
 * Gets the #FooRocket123 instance for the D-Bus interface <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooRocket123 that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooRocket123 *foo_object_get_rocket123 (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "com.acme.Rocket");
  if (ret == NULL)
    return NULL;
  return FOO_ROCKET123 (ret);
}

/**
 * foo_object_get_bat:
 * @object: A #FooObject.
 *
 * Gets the #FooBat instance for the D-Bus interface <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooBat that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooBat *foo_object_get_bat (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Bat");
  if (ret == NULL)
    return NULL;
  return FOO_BAT (ret);
}

/**
 * foo_object_get_authorize:
 * @object: A #FooObject.
 *
 * Gets the #FooAuthorize instance for the D-Bus interface <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooAuthorize that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooAuthorize *foo_object_get_authorize (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Authorize");
  if (ret == NULL)
    return NULL;
  return FOO_AUTHORIZE (ret);
}

/**
 * foo_object_get_method_threads:
 * @object: A #FooObject.
 *
 * Gets the #FooMethodThreads instance for the D-Bus interface <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooMethodThreads that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooMethodThreads *foo_object_get_method_threads (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.MethodThreads");
  if (ret == NULL)
    return NULL;
  return FOO_METHOD_THREADS (ret);
}

/**
 * foo_object_get_inline_docs:
 * @object: A #FooObject.
 *
 * Gets the #FooInlineDocs instance for the D-Bus interface <link linkend="gdbus-interface-org-project-InlineDocs.top_of_page">org.project.InlineDocs</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooInlineDocs that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooInlineDocs *foo_object_get_inline_docs (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.InlineDocs");
  if (ret == NULL)
    return NULL;
  return FOO_INLINE_DOCS (ret);
}

/**
 * foo_object_get_changing_interface_v1:
 * @object: A #FooObject.
 *
 * Gets the #FooChangingInterfaceV1 instance for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV1.top_of_page">ChangingInterfaceV1</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooChangingInterfaceV1 that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooChangingInterfaceV1 *foo_object_get_changing_interface_v1 (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "ChangingInterfaceV1");
  if (ret == NULL)
    return NULL;
  return FOO_CHANGING_INTERFACE_V1 (ret);
}

/**
 * foo_object_get_changing_interface_v2:
 * @object: A #FooObject.
 *
 * Gets the #FooChangingInterfaceV2 instance for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV2.top_of_page">ChangingInterfaceV2</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooChangingInterfaceV2 that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 *
 * Since: 2.0
 */
FooChangingInterfaceV2 *foo_object_get_changing_interface_v2 (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "ChangingInterfaceV2");
  if (ret == NULL)
    return NULL;
  return FOO_CHANGING_INTERFACE_V2 (ret);
}

/**
 * foo_object_get_changing_interface_v10:
 * @object: A #FooObject.
 *
 * Gets the #FooChangingInterfaceV10 instance for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV10.top_of_page">ChangingInterfaceV10</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooChangingInterfaceV10 that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 *
 * Since: 10.0
 */
FooChangingInterfaceV10 *foo_object_get_changing_interface_v10 (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "ChangingInterfaceV10");
  if (ret == NULL)
    return NULL;
  return FOO_CHANGING_INTERFACE_V10 (ret);
}

/**
 * foo_object_get_test_ugly_case_interface:
 * @object: A #FooObject.
 *
 * Gets the #FooTesTuglyCASEInterface instance for the D-Bus interface <link linkend="gdbus-interface-TestUglyCaseInterface.top_of_page">TestUglyCaseInterface</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooTesTuglyCASEInterface that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooTesTuglyCASEInterface *foo_object_get_test_ugly_case_interface (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "TestUglyCaseInterface");
  if (ret == NULL)
    return NULL;
  return FOO_TEST_UGLY_CASE_INTERFACE (ret);
}

/**
 * foo_object_get_oldie_interface:
 * @object: A #FooObject.
 *
 * Gets the #FooOldieInterface instance for the D-Bus interface <link linkend="gdbus-interface-OldieInterface.top_of_page">OldieInterface</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooOldieInterface that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
FooOldieInterface *foo_object_get_oldie_interface (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "OldieInterface");
  if (ret == NULL)
    return NULL;
  return FOO_OLDIE_INTERFACE (ret);
}

/**
 * foo_object_get_unknown_xml_tags:
 * @object: A #FooObject.
 *
 * Gets the #FooUnknownXmlTags instance for the D-Bus interface <link linkend="gdbus-interface-UnknownXmlTags.top_of_page">UnknownXmlTags</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooUnknownXmlTags that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooUnknownXmlTags *foo_object_get_unknown_xml_tags (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "UnknownXmlTags");
  if (ret == NULL)
    return NULL;
  return FOO_UNKNOWN_XML_TAGS (ret);
}

/**
 * foo_object_get_fdpassing:
 * @object: A #FooObject.
 *
 * Gets the #FooFDPassing instance for the D-Bus interface <link linkend="gdbus-interface-FDPassing.top_of_page">FDPassing</link> on @object, if any.
 *
 * Returns: (transfer full): A #FooFDPassing that must be freed with g_object_unref() or %NULL if @object does not implement the interface.
 */
FooFDPassing *foo_object_get_fdpassing (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "FDPassing");
  if (ret == NULL)
    return NULL;
  return FOO_FDPASSING (ret);
}


/**
 * foo_object_peek_bar: (skip)
 * @object: A #FooObject.
 *
 * Like foo_object_get_bar() but doesn' increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooBar or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooBar *foo_object_peek_bar (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Bar");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_BAR (ret);
}

/**
 * foo_object_peek_bar_frobnicator: (skip)
 * @object: A #FooObject.
 *
 * Like foo_object_get_bar_frobnicator() but doesn' increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooBarFrobnicator or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooBarFrobnicator *foo_object_peek_bar_frobnicator (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Bar.Frobnicator");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_BAR_FROBNICATOR (ret);
}

/**
 * foo_object_peek_baz: (skip)
 * @object: A #FooObject.
 *
 * Like foo_object_get_baz() but doesn' increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooBaz or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooBaz *foo_object_peek_baz (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Baz");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_BAZ (ret);
}

/**
 * foo_object_peek_com_acme_coyote: (skip)
 * @object: A #FooObject.
 *
 * Like foo_object_get_com_acme_coyote() but doesn' increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooComAcmeCoyote or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooComAcmeCoyote *foo_object_peek_com_acme_coyote (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "com.acme.Coyote");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_COM_ACME_COYOTE (ret);
}

/**
 * foo_object_peek_rocket123: (skip)
 * @object: A #FooObject.
 *
 * Like foo_object_get_rocket123() but doesn' increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooRocket123 or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooRocket123 *foo_object_peek_rocket123 (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "com.acme.Rocket");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_ROCKET123 (ret);
}

/**
 * foo_object_peek_bat: (skip)
 * @object: A #FooObject.
 *
 * Like foo_object_get_bat() but doesn' increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooBat or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooBat *foo_object_peek_bat (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Bat");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_BAT (ret);
}

/**
 * foo_object_peek_authorize: (skip)
 * @object: A #FooObject.
 *
 * Like foo_object_get_authorize() but doesn' increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooAuthorize or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooAuthorize *foo_object_peek_authorize (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Authorize");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_AUTHORIZE (ret);
}

/**
 * foo_object_peek_method_threads: (skip)
 * @object: A #FooObject.
 *
 * Like foo_object_get_method_threads() but doesn' increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooMethodThreads or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooMethodThreads *foo_object_peek_method_threads (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.MethodThreads");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_METHOD_THREADS (ret);
}

/**
 * foo_object_peek_inline_docs: (skip)
 * @object: A #FooObject.
 *
 * Like foo_object_get_inline_docs() but doesn' increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooInlineDocs or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooInlineDocs *foo_object_peek_inline_docs (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.InlineDocs");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_INLINE_DOCS (ret);
}

/**
 * foo_object_peek_changing_interface_v1: (skip)
 * @object: A #FooObject.
 *
 * Like foo_object_get_changing_interface_v1() but doesn' increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooChangingInterfaceV1 or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooChangingInterfaceV1 *foo_object_peek_changing_interface_v1 (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "ChangingInterfaceV1");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_CHANGING_INTERFACE_V1 (ret);
}

/**
 * foo_object_peek_changing_interface_v2: (skip)
 * @object: A #FooObject.
 *
 * Like foo_object_get_changing_interface_v2() but doesn' increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooChangingInterfaceV2 or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 *
 * Since: 2.0
 */
FooChangingInterfaceV2 *foo_object_peek_changing_interface_v2 (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "ChangingInterfaceV2");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_CHANGING_INTERFACE_V2 (ret);
}

/**
 * foo_object_peek_changing_interface_v10: (skip)
 * @object: A #FooObject.
 *
 * Like foo_object_get_changing_interface_v10() but doesn' increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooChangingInterfaceV10 or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 *
 * Since: 10.0
 */
FooChangingInterfaceV10 *foo_object_peek_changing_interface_v10 (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "ChangingInterfaceV10");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_CHANGING_INTERFACE_V10 (ret);
}

/**
 * foo_object_peek_test_ugly_case_interface: (skip)
 * @object: A #FooObject.
 *
 * Like foo_object_get_test_ugly_case_interface() but doesn' increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooTesTuglyCASEInterface or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooTesTuglyCASEInterface *foo_object_peek_test_ugly_case_interface (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "TestUglyCaseInterface");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_TEST_UGLY_CASE_INTERFACE (ret);
}

/**
 * foo_object_peek_oldie_interface: (skip)
 * @object: A #FooObject.
 *
 * Like foo_object_get_oldie_interface() but doesn' increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooOldieInterface or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
FooOldieInterface *foo_object_peek_oldie_interface (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "OldieInterface");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_OLDIE_INTERFACE (ret);
}

/**
 * foo_object_peek_unknown_xml_tags: (skip)
 * @object: A #FooObject.
 *
 * Like foo_object_get_unknown_xml_tags() but doesn' increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooUnknownXmlTags or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooUnknownXmlTags *foo_object_peek_unknown_xml_tags (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "UnknownXmlTags");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_UNKNOWN_XML_TAGS (ret);
}

/**
 * foo_object_peek_fdpassing: (skip)
 * @object: A #FooObject.
 *
 * Like foo_object_get_fdpassing() but doesn' increase the reference count on the returned object.
 *
 * <warning>It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.</warning>
 *
 * Returns: (transfer none): A #FooFDPassing or %NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.
 */
FooFDPassing *foo_object_peek_fdpassing (FooObject *object)
{
  GDBusInterface *ret;
  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "FDPassing");
  if (ret == NULL)
    return NULL;
  g_object_unref (ret);
  return FOO_FDPASSING (ret);
}


static void
foo_object_notify (GDBusObject *object, GDBusInterface *interface)
{
  g_object_notify (G_OBJECT (object), ((_ExtendedGDBusInterfaceInfo *) g_dbus_interface_get_info (interface))->hyphen_name);
}

/**
 * FooObjectProxy:
 *
 * The #FooObjectProxy structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooObjectProxyClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooObjectProxy.
 */

static void
foo_object_proxy__foo_object_iface_init (FooObjectIface *iface)
{
}

static void
foo_object_proxy__g_dbus_object_iface_init (GDBusObjectIface *iface)
{
  iface->interface_added = foo_object_notify;
  iface->interface_removed = foo_object_notify;
}


G_DEFINE_TYPE_WITH_CODE (FooObjectProxy, foo_object_proxy, G_TYPE_DBUS_OBJECT_PROXY,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_OBJECT, foo_object_proxy__foo_object_iface_init)
                         G_IMPLEMENT_INTERFACE (G_TYPE_DBUS_OBJECT, foo_object_proxy__g_dbus_object_iface_init));

static void
foo_object_proxy_init (FooObjectProxy *object)
{
}

static void
foo_object_proxy_set_property (GObject      *_object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  G_OBJECT_WARN_INVALID_PROPERTY_ID (_object, prop_id, pspec);
}

static void
foo_object_proxy_get_property (GObject      *_object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  FooObjectProxy *object = FOO_OBJECT_PROXY (_object);
  GDBusInterface *interface;

  switch (prop_id)
    {
    case 1:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Bar");
      g_value_take_object (value, interface);
      break;

    case 2:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Bar.Frobnicator");
      g_value_take_object (value, interface);
      break;

    case 3:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Baz");
      g_value_take_object (value, interface);
      break;

    case 4:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "com.acme.Coyote");
      g_value_take_object (value, interface);
      break;

    case 5:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "com.acme.Rocket");
      g_value_take_object (value, interface);
      break;

    case 6:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Bat");
      g_value_take_object (value, interface);
      break;

    case 7:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Authorize");
      g_value_take_object (value, interface);
      break;

    case 8:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.MethodThreads");
      g_value_take_object (value, interface);
      break;

    case 9:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.InlineDocs");
      g_value_take_object (value, interface);
      break;

    case 10:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "ChangingInterfaceV1");
      g_value_take_object (value, interface);
      break;

    case 11:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "ChangingInterfaceV2");
      g_value_take_object (value, interface);
      break;

    case 12:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "ChangingInterfaceV10");
      g_value_take_object (value, interface);
      break;

    case 13:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "TestUglyCaseInterface");
      g_value_take_object (value, interface);
      break;

    case 14:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "OldieInterface");
      g_value_take_object (value, interface);
      break;

    case 15:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "UnknownXmlTags");
      g_value_take_object (value, interface);
      break;

    case 16:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "FDPassing");
      g_value_take_object (value, interface);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (_object, prop_id, pspec);
      break;
  }
}

static void
foo_object_proxy_class_init (FooObjectProxyClass *klass)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);

  gobject_class->set_property = foo_object_proxy_set_property;
  gobject_class->get_property = foo_object_proxy_get_property;

  g_object_class_override_property (gobject_class, 1, "bar");
  g_object_class_override_property (gobject_class, 2, "bar-frobnicator");
  g_object_class_override_property (gobject_class, 3, "baz");
  g_object_class_override_property (gobject_class, 4, "com-acme-coyote");
  g_object_class_override_property (gobject_class, 5, "rocket123");
  g_object_class_override_property (gobject_class, 6, "bat");
  g_object_class_override_property (gobject_class, 7, "authorize");
  g_object_class_override_property (gobject_class, 8, "method-threads");
  g_object_class_override_property (gobject_class, 9, "inline-docs");
  g_object_class_override_property (gobject_class, 10, "changing-interface-v1");
  g_object_class_override_property (gobject_class, 11, "changing-interface-v2");
  g_object_class_override_property (gobject_class, 12, "changing-interface-v10");
  g_object_class_override_property (gobject_class, 13, "test-ugly-case-interface");
  g_object_class_override_property (gobject_class, 14, "oldie-interface");
  g_object_class_override_property (gobject_class, 15, "unknown-xml-tags");
  g_object_class_override_property (gobject_class, 16, "fdpassing");
}

/**
 * foo_object_proxy_new:
 * @connection: A #GDBusConnection.
 * @object_path: An object path.
 *
 * Creates a new proxy object.
 *
 * Returns: (transfer full): The proxy object.
 */
FooObjectProxy *
foo_object_proxy_new (GDBusConnection *connection,
  const gchar *object_path)
{
  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), NULL);
  g_return_val_if_fail (g_variant_is_object_path (object_path), NULL);
  return FOO_OBJECT_PROXY (g_object_new (FOO_TYPE_OBJECT_PROXY, "connection", connection, "object-path", object_path, NULL));
}

/**
 * FooObjectSkeleton:
 *
 * The #FooObjectSkeleton structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooObjectSkeletonClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooObjectSkeleton.
 */

static void
foo_object_skeleton__foo_object_iface_init (FooObjectIface *iface)
{
}


static void
foo_object_skeleton__g_dbus_object_iface_init (GDBusObjectIface *iface)
{
  iface->interface_added = foo_object_notify;
  iface->interface_removed = foo_object_notify;
}

G_DEFINE_TYPE_WITH_CODE (FooObjectSkeleton, foo_object_skeleton, G_TYPE_DBUS_OBJECT_SKELETON,
                         G_IMPLEMENT_INTERFACE (FOO_TYPE_OBJECT, foo_object_skeleton__foo_object_iface_init)
                         G_IMPLEMENT_INTERFACE (G_TYPE_DBUS_OBJECT, foo_object_skeleton__g_dbus_object_iface_init));

static void
foo_object_skeleton_init (FooObjectSkeleton *object)
{
}

static void
foo_object_skeleton_set_property (GObject      *_object,
  guint         prop_id,
  const GValue *value,
  GParamSpec   *pspec)
{
  FooObjectSkeleton *object = FOO_OBJECT_SKELETON (_object);
  GDBusInterfaceSkeleton *interface;

  switch (prop_id)
    {
    case 1:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IS_BAR (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.project.Bar");
        }
      break;

    case 2:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IS_BAR_FROBNICATOR (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.project.Bar.Frobnicator");
        }
      break;

    case 3:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IS_BAZ (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.project.Baz");
        }
      break;

    case 4:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IS_COM_ACME_COYOTE (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "com.acme.Coyote");
        }
      break;

    case 5:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IS_ROCKET123 (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "com.acme.Rocket");
        }
      break;

    case 6:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IS_BAT (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.project.Bat");
        }
      break;

    case 7:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IS_AUTHORIZE (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.project.Authorize");
        }
      break;

    case 8:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IS_METHOD_THREADS (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.project.MethodThreads");
        }
      break;

    case 9:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IS_INLINE_DOCS (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "org.project.InlineDocs");
        }
      break;

    case 10:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IS_CHANGING_INTERFACE_V1 (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "ChangingInterfaceV1");
        }
      break;

    case 11:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IS_CHANGING_INTERFACE_V2 (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "ChangingInterfaceV2");
        }
      break;

    case 12:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IS_CHANGING_INTERFACE_V10 (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "ChangingInterfaceV10");
        }
      break;

    case 13:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IS_TEST_UGLY_CASE_INTERFACE (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "TestUglyCaseInterface");
        }
      break;

    case 14:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IS_OLDIE_INTERFACE (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "OldieInterface");
        }
      break;

    case 15:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IS_UNKNOWN_XML_TAGS (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "UnknownXmlTags");
        }
      break;

    case 16:
      interface = g_value_get_object (value);
      if (interface != NULL)
        {
          g_warn_if_fail (FOO_IS_FDPASSING (interface));
          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);
        }
      else
        {
          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "FDPassing");
        }
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (_object, prop_id, pspec);
      break;
  }
}

static void
foo_object_skeleton_get_property (GObject      *_object,
  guint         prop_id,
  GValue       *value,
  GParamSpec   *pspec)
{
  FooObjectSkeleton *object = FOO_OBJECT_SKELETON (_object);
  GDBusInterface *interface;

  switch (prop_id)
    {
    case 1:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Bar");
      g_value_take_object (value, interface);
      break;

    case 2:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Bar.Frobnicator");
      g_value_take_object (value, interface);
      break;

    case 3:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Baz");
      g_value_take_object (value, interface);
      break;

    case 4:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "com.acme.Coyote");
      g_value_take_object (value, interface);
      break;

    case 5:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "com.acme.Rocket");
      g_value_take_object (value, interface);
      break;

    case 6:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Bat");
      g_value_take_object (value, interface);
      break;

    case 7:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.Authorize");
      g_value_take_object (value, interface);
      break;

    case 8:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.MethodThreads");
      g_value_take_object (value, interface);
      break;

    case 9:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "org.project.InlineDocs");
      g_value_take_object (value, interface);
      break;

    case 10:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "ChangingInterfaceV1");
      g_value_take_object (value, interface);
      break;

    case 11:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "ChangingInterfaceV2");
      g_value_take_object (value, interface);
      break;

    case 12:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "ChangingInterfaceV10");
      g_value_take_object (value, interface);
      break;

    case 13:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "TestUglyCaseInterface");
      g_value_take_object (value, interface);
      break;

    case 14:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "OldieInterface");
      g_value_take_object (value, interface);
      break;

    case 15:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "UnknownXmlTags");
      g_value_take_object (value, interface);
      break;

    case 16:
      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "FDPassing");
      g_value_take_object (value, interface);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (_object, prop_id, pspec);
      break;
  }
}

static void
foo_object_skeleton_class_init (FooObjectSkeletonClass *klass)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);

  gobject_class->set_property = foo_object_skeleton_set_property;
  gobject_class->get_property = foo_object_skeleton_get_property;

  g_object_class_override_property (gobject_class, 1, "bar");
  g_object_class_override_property (gobject_class, 2, "bar-frobnicator");
  g_object_class_override_property (gobject_class, 3, "baz");
  g_object_class_override_property (gobject_class, 4, "com-acme-coyote");
  g_object_class_override_property (gobject_class, 5, "rocket123");
  g_object_class_override_property (gobject_class, 6, "bat");
  g_object_class_override_property (gobject_class, 7, "authorize");
  g_object_class_override_property (gobject_class, 8, "method-threads");
  g_object_class_override_property (gobject_class, 9, "inline-docs");
  g_object_class_override_property (gobject_class, 10, "changing-interface-v1");
  g_object_class_override_property (gobject_class, 11, "changing-interface-v2");
  g_object_class_override_property (gobject_class, 12, "changing-interface-v10");
  g_object_class_override_property (gobject_class, 13, "test-ugly-case-interface");
  g_object_class_override_property (gobject_class, 14, "oldie-interface");
  g_object_class_override_property (gobject_class, 15, "unknown-xml-tags");
  g_object_class_override_property (gobject_class, 16, "fdpassing");
}

/**
 * foo_object_skeleton_new:
 * @object_path: An object path.
 *
 * Creates a new skeleton object.
 *
 * Returns: (transfer full): The skeleton object.
 */
FooObjectSkeleton *
foo_object_skeleton_new (const gchar *object_path)
{
  g_return_val_if_fail (g_variant_is_object_path (object_path), NULL);
  return FOO_OBJECT_SKELETON (g_object_new (FOO_TYPE_OBJECT_SKELETON, "object-path", object_path, NULL));
}

/**
 * foo_object_skeleton_set_bar:
 * @object: A #FooObjectSkeleton.
 * @interface_: (allow-none): A #FooBar or %NULL to clear the interface.
 *
 * Sets the #FooBar instance for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar.top_of_page">org.project.Bar</link> on @object.
 */
void foo_object_skeleton_set_bar (FooObjectSkeleton *object, FooBar *interface_)
{
  g_object_set (G_OBJECT (object), "bar", interface_, NULL);
}

/**
 * foo_object_skeleton_set_bar_frobnicator:
 * @object: A #FooObjectSkeleton.
 * @interface_: (allow-none): A #FooBarFrobnicator or %NULL to clear the interface.
 *
 * Sets the #FooBarFrobnicator instance for the D-Bus interface <link linkend="gdbus-interface-org-project-Bar-Frobnicator.top_of_page">org.project.Bar.Frobnicator</link> on @object.
 */
void foo_object_skeleton_set_bar_frobnicator (FooObjectSkeleton *object, FooBarFrobnicator *interface_)
{
  g_object_set (G_OBJECT (object), "bar-frobnicator", interface_, NULL);
}

/**
 * foo_object_skeleton_set_baz:
 * @object: A #FooObjectSkeleton.
 * @interface_: (allow-none): A #FooBaz or %NULL to clear the interface.
 *
 * Sets the #FooBaz instance for the D-Bus interface <link linkend="gdbus-interface-org-project-Baz.top_of_page">org.project.Baz</link> on @object.
 */
void foo_object_skeleton_set_baz (FooObjectSkeleton *object, FooBaz *interface_)
{
  g_object_set (G_OBJECT (object), "baz", interface_, NULL);
}

/**
 * foo_object_skeleton_set_com_acme_coyote:
 * @object: A #FooObjectSkeleton.
 * @interface_: (allow-none): A #FooComAcmeCoyote or %NULL to clear the interface.
 *
 * Sets the #FooComAcmeCoyote instance for the D-Bus interface <link linkend="gdbus-interface-com-acme-Coyote.top_of_page">com.acme.Coyote</link> on @object.
 */
void foo_object_skeleton_set_com_acme_coyote (FooObjectSkeleton *object, FooComAcmeCoyote *interface_)
{
  g_object_set (G_OBJECT (object), "com-acme-coyote", interface_, NULL);
}

/**
 * foo_object_skeleton_set_rocket123:
 * @object: A #FooObjectSkeleton.
 * @interface_: (allow-none): A #FooRocket123 or %NULL to clear the interface.
 *
 * Sets the #FooRocket123 instance for the D-Bus interface <link linkend="gdbus-interface-com-acme-Rocket.top_of_page">com.acme.Rocket</link> on @object.
 */
void foo_object_skeleton_set_rocket123 (FooObjectSkeleton *object, FooRocket123 *interface_)
{
  g_object_set (G_OBJECT (object), "rocket123", interface_, NULL);
}

/**
 * foo_object_skeleton_set_bat:
 * @object: A #FooObjectSkeleton.
 * @interface_: (allow-none): A #FooBat or %NULL to clear the interface.
 *
 * Sets the #FooBat instance for the D-Bus interface <link linkend="gdbus-interface-org-project-Bat.top_of_page">org.project.Bat</link> on @object.
 */
void foo_object_skeleton_set_bat (FooObjectSkeleton *object, FooBat *interface_)
{
  g_object_set (G_OBJECT (object), "bat", interface_, NULL);
}

/**
 * foo_object_skeleton_set_authorize:
 * @object: A #FooObjectSkeleton.
 * @interface_: (allow-none): A #FooAuthorize or %NULL to clear the interface.
 *
 * Sets the #FooAuthorize instance for the D-Bus interface <link linkend="gdbus-interface-org-project-Authorize.top_of_page">org.project.Authorize</link> on @object.
 */
void foo_object_skeleton_set_authorize (FooObjectSkeleton *object, FooAuthorize *interface_)
{
  g_object_set (G_OBJECT (object), "authorize", interface_, NULL);
}

/**
 * foo_object_skeleton_set_method_threads:
 * @object: A #FooObjectSkeleton.
 * @interface_: (allow-none): A #FooMethodThreads or %NULL to clear the interface.
 *
 * Sets the #FooMethodThreads instance for the D-Bus interface <link linkend="gdbus-interface-org-project-MethodThreads.top_of_page">org.project.MethodThreads</link> on @object.
 */
void foo_object_skeleton_set_method_threads (FooObjectSkeleton *object, FooMethodThreads *interface_)
{
  g_object_set (G_OBJECT (object), "method-threads", interface_, NULL);
}

/**
 * foo_object_skeleton_set_inline_docs:
 * @object: A #FooObjectSkeleton.
 * @interface_: (allow-none): A #FooInlineDocs or %NULL to clear the interface.
 *
 * Sets the #FooInlineDocs instance for the D-Bus interface <link linkend="gdbus-interface-org-project-InlineDocs.top_of_page">org.project.InlineDocs</link> on @object.
 */
void foo_object_skeleton_set_inline_docs (FooObjectSkeleton *object, FooInlineDocs *interface_)
{
  g_object_set (G_OBJECT (object), "inline-docs", interface_, NULL);
}

/**
 * foo_object_skeleton_set_changing_interface_v1:
 * @object: A #FooObjectSkeleton.
 * @interface_: (allow-none): A #FooChangingInterfaceV1 or %NULL to clear the interface.
 *
 * Sets the #FooChangingInterfaceV1 instance for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV1.top_of_page">ChangingInterfaceV1</link> on @object.
 */
void foo_object_skeleton_set_changing_interface_v1 (FooObjectSkeleton *object, FooChangingInterfaceV1 *interface_)
{
  g_object_set (G_OBJECT (object), "changing-interface-v1", interface_, NULL);
}

/**
 * foo_object_skeleton_set_changing_interface_v2:
 * @object: A #FooObjectSkeleton.
 * @interface_: (allow-none): A #FooChangingInterfaceV2 or %NULL to clear the interface.
 *
 * Sets the #FooChangingInterfaceV2 instance for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV2.top_of_page">ChangingInterfaceV2</link> on @object.
 *
 * Since: 2.0
 */
void foo_object_skeleton_set_changing_interface_v2 (FooObjectSkeleton *object, FooChangingInterfaceV2 *interface_)
{
  g_object_set (G_OBJECT (object), "changing-interface-v2", interface_, NULL);
}

/**
 * foo_object_skeleton_set_changing_interface_v10:
 * @object: A #FooObjectSkeleton.
 * @interface_: (allow-none): A #FooChangingInterfaceV10 or %NULL to clear the interface.
 *
 * Sets the #FooChangingInterfaceV10 instance for the D-Bus interface <link linkend="gdbus-interface-ChangingInterfaceV10.top_of_page">ChangingInterfaceV10</link> on @object.
 *
 * Since: 10.0
 */
void foo_object_skeleton_set_changing_interface_v10 (FooObjectSkeleton *object, FooChangingInterfaceV10 *interface_)
{
  g_object_set (G_OBJECT (object), "changing-interface-v10", interface_, NULL);
}

/**
 * foo_object_skeleton_set_test_ugly_case_interface:
 * @object: A #FooObjectSkeleton.
 * @interface_: (allow-none): A #FooTesTuglyCASEInterface or %NULL to clear the interface.
 *
 * Sets the #FooTesTuglyCASEInterface instance for the D-Bus interface <link linkend="gdbus-interface-TestUglyCaseInterface.top_of_page">TestUglyCaseInterface</link> on @object.
 */
void foo_object_skeleton_set_test_ugly_case_interface (FooObjectSkeleton *object, FooTesTuglyCASEInterface *interface_)
{
  g_object_set (G_OBJECT (object), "test-ugly-case-interface", interface_, NULL);
}

/**
 * foo_object_skeleton_set_oldie_interface:
 * @object: A #FooObjectSkeleton.
 * @interface_: (allow-none): A #FooOldieInterface or %NULL to clear the interface.
 *
 * Sets the #FooOldieInterface instance for the D-Bus interface <link linkend="gdbus-interface-OldieInterface.top_of_page">OldieInterface</link> on @object.
 *
 * Deprecated: The D-Bus interface has been deprecated.
 */
void foo_object_skeleton_set_oldie_interface (FooObjectSkeleton *object, FooOldieInterface *interface_)
{
  g_object_set (G_OBJECT (object), "oldie-interface", interface_, NULL);
}

/**
 * foo_object_skeleton_set_unknown_xml_tags:
 * @object: A #FooObjectSkeleton.
 * @interface_: (allow-none): A #FooUnknownXmlTags or %NULL to clear the interface.
 *
 * Sets the #FooUnknownXmlTags instance for the D-Bus interface <link linkend="gdbus-interface-UnknownXmlTags.top_of_page">UnknownXmlTags</link> on @object.
 */
void foo_object_skeleton_set_unknown_xml_tags (FooObjectSkeleton *object, FooUnknownXmlTags *interface_)
{
  g_object_set (G_OBJECT (object), "unknown-xml-tags", interface_, NULL);
}

/**
 * foo_object_skeleton_set_fdpassing:
 * @object: A #FooObjectSkeleton.
 * @interface_: (allow-none): A #FooFDPassing or %NULL to clear the interface.
 *
 * Sets the #FooFDPassing instance for the D-Bus interface <link linkend="gdbus-interface-FDPassing.top_of_page">FDPassing</link> on @object.
 */
void foo_object_skeleton_set_fdpassing (FooObjectSkeleton *object, FooFDPassing *interface_)
{
  g_object_set (G_OBJECT (object), "fdpassing", interface_, NULL);
}


/* ------------------------------------------------------------------------
 * Code for ObjectManager client
 * ------------------------------------------------------------------------
 */

/**
 * SECTION:FooObjectManagerClient
 * @title: FooObjectManagerClient
 * @short_description: Generated GDBusObjectManagerClient type
 *
 * This section contains a #GDBusObjectManagerClient that uses foo_object_manager_client_get_proxy_type() as the #GDBusProxyTypeFunc.
 */

/**
 * FooObjectManagerClient:
 *
 * The #FooObjectManagerClient structure contains only private data and should only be accessed using the provided API.
 */

/**
 * FooObjectManagerClientClass:
 * @parent_class: The parent class.
 *
 * Class structure for #FooObjectManagerClient.
 */

G_DEFINE_TYPE (FooObjectManagerClient, foo_object_manager_client, G_TYPE_DBUS_OBJECT_MANAGER_CLIENT);

static void
foo_object_manager_client_init (FooObjectManagerClient *manager)
{
}

static void
foo_object_manager_client_class_init (FooObjectManagerClientClass *klass)
{
}

/**
 * foo_object_manager_client_get_proxy_type:
 * @manager: A #GDBusObjectManagerClient.
 * @object_path: The object path of the remote object (unused).
 * @interface_name: (allow-none): Interface name of the remote object or %NULL to get the object proxy #GType.
 * @user_data: User data (unused).
 *
 * A #GDBusProxyTypeFunc that maps @interface_name to the generated #GDBusObjectProxy<!-- -->- and #GDBusProxy<!-- -->-derived types.
 *
 * Returns: A #GDBusProxy<!-- -->-derived #GType if @interface_name is not %NULL, otherwise the #GType for #FooObjectProxy.
 */
GType
foo_object_manager_client_get_proxy_type (GDBusObjectManagerClient *manager, const gchar *object_path, const gchar *interface_name, gpointer user_data)
{
  static gsize once_init_value = 0;
  static GHashTable *lookup_hash;
  GType ret;

  if (interface_name == NULL)
    return FOO_TYPE_OBJECT_PROXY;
  if (g_once_init_enter (&once_init_value))
    {
      lookup_hash = g_hash_table_new (g_str_hash, g_str_equal);
      g_hash_table_insert (lookup_hash, "org.project.Bar", GSIZE_TO_POINTER (FOO_TYPE_BAR_PROXY));
      g_hash_table_insert (lookup_hash, "org.project.Bar.Frobnicator", GSIZE_TO_POINTER (FOO_TYPE_BAR_FROBNICATOR_PROXY));
      g_hash_table_insert (lookup_hash, "org.project.Baz", GSIZE_TO_POINTER (FOO_TYPE_BAZ_PROXY));
      g_hash_table_insert (lookup_hash, "com.acme.Coyote", GSIZE_TO_POINTER (FOO_TYPE_COM_ACME_COYOTE_PROXY));
      g_hash_table_insert (lookup_hash, "com.acme.Rocket", GSIZE_TO_POINTER (FOO_TYPE_ROCKET123_PROXY));
      g_hash_table_insert (lookup_hash, "org.project.Bat", GSIZE_TO_POINTER (FOO_TYPE_BAT_PROXY));
      g_hash_table_insert (lookup_hash, "org.project.Authorize", GSIZE_TO_POINTER (FOO_TYPE_AUTHORIZE_PROXY));
      g_hash_table_insert (lookup_hash, "org.project.MethodThreads", GSIZE_TO_POINTER (FOO_TYPE_METHOD_THREADS_PROXY));
      g_hash_table_insert (lookup_hash, "org.project.InlineDocs", GSIZE_TO_POINTER (FOO_TYPE_INLINE_DOCS_PROXY));
      g_hash_table_insert (lookup_hash, "ChangingInterfaceV1", GSIZE_TO_POINTER (FOO_TYPE_CHANGING_INTERFACE_V1_PROXY));
      g_hash_table_insert (lookup_hash, "ChangingInterfaceV2", GSIZE_TO_POINTER (FOO_TYPE_CHANGING_INTERFACE_V2_PROXY));
      g_hash_table_insert (lookup_hash, "ChangingInterfaceV10", GSIZE_TO_POINTER (FOO_TYPE_CHANGING_INTERFACE_V10_PROXY));
      g_hash_table_insert (lookup_hash, "TestUglyCaseInterface", GSIZE_TO_POINTER (FOO_TYPE_TEST_UGLY_CASE_INTERFACE_PROXY));
      g_hash_table_insert (lookup_hash, "OldieInterface", GSIZE_TO_POINTER (FOO_TYPE_OLDIE_INTERFACE_PROXY));
      g_hash_table_insert (lookup_hash, "UnknownXmlTags", GSIZE_TO_POINTER (FOO_TYPE_UNKNOWN_XML_TAGS_PROXY));
      g_hash_table_insert (lookup_hash, "FDPassing", GSIZE_TO_POINTER (FOO_TYPE_FDPASSING_PROXY));
      g_once_init_leave (&once_init_value, 1);
    }
  ret = (GType) GPOINTER_TO_SIZE (g_hash_table_lookup (lookup_hash, interface_name));
  if (ret == (GType) 0)
    ret = G_TYPE_DBUS_PROXY;
  return ret;
}

/**
 * foo_object_manager_client_new:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Asynchronously creates #GDBusObjectManagerClient using foo_object_manager_client_get_proxy_type() as the #GDBusProxyTypeFunc. See g_dbus_object_manager_client_new() for more details.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_object_manager_client_new_finish() to get the result of the operation.
 *
 * See foo_object_manager_client_new_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_object_manager_client_new (
    GDBusConnection        *connection,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GAsyncReadyCallback     callback,
    gpointer                user_data)
{
  g_async_initable_new_async (FOO_TYPE_OBJECT_MANAGER_CLIENT, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "flags", flags, "name", name, "connection", connection, "object-path", object_path, "get-proxy-type-func", foo_object_manager_client_get_proxy_type, NULL);
}

/**
 * foo_object_manager_client_new_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_object_manager_client_new().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_object_manager_client_new().
 *
 * Returns: (transfer full) (type FooObjectManagerClient): The constructed object manager client or %NULL if @error is set.
 */
GDBusObjectManager *
foo_object_manager_client_new_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return G_DBUS_OBJECT_MANAGER (ret);
  else
    return NULL;
}

/**
 * foo_object_manager_client_new_sync:
 * @connection: A #GDBusConnection.
 * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.
 * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Synchronously creates #GDBusObjectManagerClient using foo_object_manager_client_get_proxy_type() as the #GDBusProxyTypeFunc. See g_dbus_object_manager_client_new_sync() for more details.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_object_manager_client_new() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooObjectManagerClient): The constructed object manager client or %NULL if @error is set.
 */
GDBusObjectManager *
foo_object_manager_client_new_sync (
    GDBusConnection        *connection,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GError                **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_OBJECT_MANAGER_CLIENT, cancellable, error, "flags", flags, "name", name, "connection", connection, "object-path", object_path, "get-proxy-type-func", foo_object_manager_client_get_proxy_type, NULL);
  if (ret != NULL)
    return G_DBUS_OBJECT_MANAGER (ret);
  else
    return NULL;
}


/**
 * foo_object_manager_client_new_for_bus:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
 * @user_data: User data to pass to @callback.
 *
 * Like foo_object_manager_client_new() but takes a #GBusType instead of a #GDBusConnection.
 *
 * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
 * You can then call foo_object_manager_client_new_for_bus_finish() to get the result of the operation.
 *
 * See foo_object_manager_client_new_for_bus_sync() for the synchronous, blocking version of this constructor.
 */
void
foo_object_manager_client_new_for_bus (
    GBusType                bus_type,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GAsyncReadyCallback     callback,
    gpointer                user_data)
{
  g_async_initable_new_async (FOO_TYPE_OBJECT_MANAGER_CLIENT, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "flags", flags, "name", name, "bus-type", bus_type, "object-path", object_path, "get-proxy-type-func", foo_object_manager_client_get_proxy_type, NULL);
}

/**
 * foo_object_manager_client_new_for_bus_finish:
 * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to foo_object_manager_client_new_for_bus().
 * @error: Return location for error or %NULL
 *
 * Finishes an operation started with foo_object_manager_client_new_for_bus().
 *
 * Returns: (transfer full) (type FooObjectManagerClient): The constructed object manager client or %NULL if @error is set.
 */
GDBusObjectManager *
foo_object_manager_client_new_for_bus_finish (
    GAsyncResult        *res,
    GError             **error)
{
  GObject *ret;
  GObject *source_object;
  source_object = g_async_result_get_source_object (res);
  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
  g_object_unref (source_object);
  if (ret != NULL)
    return G_DBUS_OBJECT_MANAGER (ret);
  else
    return NULL;
}

/**
 * foo_object_manager_client_new_for_bus_sync:
 * @bus_type: A #GBusType.
 * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.
 * @name: A bus name (well-known or unique).
 * @object_path: An object path.
 * @cancellable: (allow-none): A #GCancellable or %NULL.
 * @error: Return location for error or %NULL
 *
 * Like foo_object_manager_client_new_sync() but takes a #GBusType instead of a #GDBusConnection.
 *
 * The calling thread is blocked until a reply is received.
 *
 * See foo_object_manager_client_new_for_bus() for the asynchronous version of this constructor.
 *
 * Returns: (transfer full) (type FooObjectManagerClient): The constructed object manager client or %NULL if @error is set.
 */
GDBusObjectManager *
foo_object_manager_client_new_for_bus_sync (
    GBusType                bus_type,
    GDBusObjectManagerClientFlags  flags,
    const gchar            *name,
    const gchar            *object_path,
    GCancellable           *cancellable,
    GError                **error)
{
  GInitable *ret;
  ret = g_initable_new (FOO_TYPE_OBJECT_MANAGER_CLIENT, cancellable, error, "flags", flags, "name", name, "bus-type", bus_type, "object-path", object_path, "get-proxy-type-func", foo_object_manager_client_get_proxy_type, NULL);
  if (ret != NULL)
    return G_DBUS_OBJECT_MANAGER (ret);
  else
    return NULL;
}



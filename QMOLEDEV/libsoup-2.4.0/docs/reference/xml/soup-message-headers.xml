<?xml version="1.0"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" 
               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<refentry id="libsoup-24-SoupMessageHeaders">
<refmeta>
<refentrytitle role="top_of_page">SoupMessageHeaders</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>LIBSOUP-2.4 Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>SoupMessageHeaders</refname>
<refpurpose>HTTP message headers</refpurpose>
<!--[<xref linkend="desc" endterm="desc.title"/>]-->
</refnamediv>

<refsynopsisdiv role="synopsis">
<title role="synopsis.title">Synopsis</title>

<synopsis>



typedef             <link linkend="SoupMessageHeaders">SoupMessageHeaders</link>;
enum                <link linkend="SoupMessageHeadersType">SoupMessageHeadersType</link>;
<link linkend="SoupMessageHeaders">SoupMessageHeaders</link>* <link linkend="soup-message-headers-new">soup_message_headers_new</link>            (<link linkend="SoupMessageHeadersType">SoupMessageHeadersType</link> type);
<link linkend="void">void</link>                <link linkend="soup-message-headers-free">soup_message_headers_free</link>           (<link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs);

<link linkend="void">void</link>                <link linkend="soup-message-headers-append">soup_message_headers_append</link>         (<link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs,
                                                         const <link linkend="char">char</link> *name,
                                                         const <link linkend="char">char</link> *value);
<link linkend="void">void</link>                <link linkend="soup-message-headers-replace">soup_message_headers_replace</link>        (<link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs,
                                                         const <link linkend="char">char</link> *name,
                                                         const <link linkend="char">char</link> *value);
<link linkend="void">void</link>                <link linkend="soup-message-headers-remove">soup_message_headers_remove</link>         (<link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs,
                                                         const <link linkend="char">char</link> *name);
<link linkend="void">void</link>                <link linkend="soup-message-headers-clear">soup_message_headers_clear</link>          (<link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs);
const <link linkend="char">char</link>*         <link linkend="soup-message-headers-get">soup_message_headers_get</link>            (<link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs,
                                                         const <link linkend="char">char</link> *name);

<link linkend="void">void</link>                (<link linkend="SoupMessageHeadersForeachFunc">*SoupMessageHeadersForeachFunc</link>)    (const <link linkend="char">char</link> *name,
                                                         const <link linkend="char">char</link> *value,
                                                         <link linkend="gpointer">gpointer</link> user_data);
<link linkend="void">void</link>                <link linkend="soup-message-headers-foreach">soup_message_headers_foreach</link>        (<link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs,
                                                         <link linkend="SoupMessageHeadersForeachFunc">SoupMessageHeadersForeachFunc</link> func,
                                                         <link linkend="gpointer">gpointer</link> user_data);

                    <link linkend="SoupMessageHeadersIter">SoupMessageHeadersIter</link>;
<link linkend="void">void</link>                <link linkend="soup-message-headers-iter-init">soup_message_headers_iter_init</link>      (<link linkend="SoupMessageHeadersIter">SoupMessageHeadersIter</link> *iter,
                                                         <link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs);
<link linkend="gboolean">gboolean</link>            <link linkend="soup-message-headers-iter-next">soup_message_headers_iter_next</link>      (<link linkend="SoupMessageHeadersIter">SoupMessageHeadersIter</link> *iter,
                                                         const <link linkend="char">char</link> **name,
                                                         const <link linkend="char">char</link> **value);

enum                <link linkend="SoupEncoding">SoupEncoding</link>;
<link linkend="SoupEncoding">SoupEncoding</link>        <link linkend="soup-message-headers-get-encoding">soup_message_headers_get_encoding</link>   (<link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs);
<link linkend="void">void</link>                <link linkend="soup-message-headers-set-encoding">soup_message_headers_set_encoding</link>   (<link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs,
                                                         <link linkend="SoupEncoding">SoupEncoding</link> encoding);
<link linkend="goffset">goffset</link>             <link linkend="soup-message-headers-get-content-length">soup_message_headers_get_content_length</link>
                                                        (<link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs);
<link linkend="void">void</link>                <link linkend="soup-message-headers-set-content-length">soup_message_headers_set_content_length</link>
                                                        (<link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs,
                                                         <link linkend="goffset">goffset</link> content_length);

enum                <link linkend="SoupExpectation">SoupExpectation</link>;
<link linkend="SoupExpectation">SoupExpectation</link>     <link linkend="soup-message-headers-get-expectations">soup_message_headers_get_expectations</link>
                                                        (<link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs);
<link linkend="void">void</link>                <link linkend="soup-message-headers-set-expectations">soup_message_headers_set_expectations</link>
                                                        (<link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs,
                                                         <link linkend="SoupExpectation">SoupExpectation</link> expectations);

</synopsis>
</refsynopsisdiv>









<refsect1 role="desc">
<title role="desc.title">Description</title>
<para>
<link linkend="SoupMessageHeaders"><type>SoupMessageHeaders</type></link> represents the HTTP message headers associated
with a request or response.</para>
<para>

</para>
</refsect1>

<refsect1 role="details">
<title role="details.title">Details</title>
<refsect2>
<title><anchor id="SoupMessageHeaders" role="typedef"/>SoupMessageHeaders</title>
<indexterm><primary>SoupMessageHeaders</primary></indexterm><programlisting>typedef struct SoupMessageHeaders SoupMessageHeaders;
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="SoupMessageHeadersType" role="enum"/>enum SoupMessageHeadersType</title>
<indexterm><primary>SoupMessageHeadersType</primary></indexterm><programlisting>typedef enum {
	SOUP_MESSAGE_HEADERS_REQUEST,
	SOUP_MESSAGE_HEADERS_RESPONSE
} SoupMessageHeadersType;
</programlisting>
<para>
Value passed to <link linkend="soup-message-headers-new"><function>soup_message_headers_new()</function></link> to set certain default
behaviors.</para>
<para>

</para><variablelist role="enum">
<varlistentry>
<term><anchor id="SOUP-MESSAGE-HEADERS-REQUEST:CAPS" role="constant"/><literal>SOUP_MESSAGE_HEADERS_REQUEST</literal></term>
<listitem><simpara> request headers
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="SOUP-MESSAGE-HEADERS-RESPONSE:CAPS" role="constant"/><literal>SOUP_MESSAGE_HEADERS_RESPONSE</literal></term>
<listitem><simpara> response headers
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-headers-new" role="function"/>soup_message_headers_new ()</title>
<indexterm><primary>soup_message_headers_new</primary></indexterm><programlisting><link linkend="SoupMessageHeaders">SoupMessageHeaders</link>* soup_message_headers_new            (<link linkend="SoupMessageHeadersType">SoupMessageHeadersType</link> type);</programlisting>
<para>
Creates a <link linkend="SoupMessageHeaders"><type>SoupMessageHeaders</type></link>. (<link linkend="SoupMessage"><type>SoupMessage</type></link> does this
automatically for its own headers. You would only need to use this
method if you are manually parsing or generating message headers.)</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara> the type of headers
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> a new <link linkend="SoupMessageHeaders"><type>SoupMessageHeaders</type></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-headers-free" role="function"/>soup_message_headers_free ()</title>
<indexterm><primary>soup_message_headers_free</primary></indexterm><programlisting><link linkend="void">void</link>                soup_message_headers_free           (<link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs);</programlisting>
<para>
Frees <parameter>hdrs</parameter>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>hdrs</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessageHeaders"><type>SoupMessageHeaders</type></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-headers-append" role="function"/>soup_message_headers_append ()</title>
<indexterm><primary>soup_message_headers_append</primary></indexterm><programlisting><link linkend="void">void</link>                soup_message_headers_append         (<link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs,
                                                         const <link linkend="char">char</link> *name,
                                                         const <link linkend="char">char</link> *value);</programlisting>
<para>
Appends a new header with name <parameter>name</parameter> and value <parameter>value</parameter> to <parameter>hdrs</parameter>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>hdrs</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessageHeaders"><type>SoupMessageHeaders</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>name</parameter>&nbsp;:</term>
<listitem><simpara> the header name to add
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>value</parameter>&nbsp;:</term>
<listitem><simpara> the new value of <parameter>name</parameter>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-headers-replace" role="function"/>soup_message_headers_replace ()</title>
<indexterm><primary>soup_message_headers_replace</primary></indexterm><programlisting><link linkend="void">void</link>                soup_message_headers_replace        (<link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs,
                                                         const <link linkend="char">char</link> *name,
                                                         const <link linkend="char">char</link> *value);</programlisting>
<para>
Replaces the value of the header <parameter>name</parameter> in <parameter>hdrs</parameter> with <parameter>value</parameter>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>hdrs</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessageHeaders"><type>SoupMessageHeaders</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>name</parameter>&nbsp;:</term>
<listitem><simpara> the header name to replace
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>value</parameter>&nbsp;:</term>
<listitem><simpara> the new value of <parameter>name</parameter>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-headers-remove" role="function"/>soup_message_headers_remove ()</title>
<indexterm><primary>soup_message_headers_remove</primary></indexterm><programlisting><link linkend="void">void</link>                soup_message_headers_remove         (<link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs,
                                                         const <link linkend="char">char</link> *name);</programlisting>
<para>
Removes <parameter>name</parameter> from <parameter>hdrs</parameter>. If there are multiple values for <parameter>name</parameter>,
they are all removed.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>hdrs</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessageHeaders"><type>SoupMessageHeaders</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>name</parameter>&nbsp;:</term>
<listitem><simpara> the header name to remove
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-headers-clear" role="function"/>soup_message_headers_clear ()</title>
<indexterm><primary>soup_message_headers_clear</primary></indexterm><programlisting><link linkend="void">void</link>                soup_message_headers_clear          (<link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs);</programlisting>
<para>
Clears <parameter>hdrs</parameter>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>hdrs</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessageHeaders"><type>SoupMessageHeaders</type></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-headers-get" role="function"/>soup_message_headers_get ()</title>
<indexterm><primary>soup_message_headers_get</primary></indexterm><programlisting>const <link linkend="char">char</link>*         soup_message_headers_get            (<link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs,
                                                         const <link linkend="char">char</link> *name);</programlisting>
<para>
Gets the value of header <parameter>name</parameter> in <parameter>hdrs</parameter>.
</para>
<para>
If <parameter>name</parameter> has multiple values in <parameter>hdrs</parameter>, <link linkend="soup-message-headers-get"><function>soup_message_headers_get()</function></link>
will concatenate all of the values together, separated by commas.
This is sometimes awkward to parse (eg, WWW-Authenticate,
Set-Cookie), but you have to be able to deal with it anyway,
because an upstream proxy could do the same thing.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>hdrs</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessageHeaders"><type>SoupMessageHeaders</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>name</parameter>&nbsp;:</term>
<listitem><simpara> header name
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the header's value or <link linkend="NULL:CAPS"><literal>NULL</literal></link> if not found.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="SoupMessageHeadersForeachFunc" role="function"/>SoupMessageHeadersForeachFunc ()</title>
<indexterm><primary>SoupMessageHeadersForeachFunc</primary></indexterm><programlisting><link linkend="void">void</link>                (*SoupMessageHeadersForeachFunc)    (const <link linkend="char">char</link> *name,
                                                         const <link linkend="char">char</link> *value,
                                                         <link linkend="gpointer">gpointer</link> user_data);</programlisting>
<para>
The callback passed to <link linkend="soup-message-headers-foreach"><function>soup_message_headers_foreach()</function></link>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>name</parameter>&nbsp;:</term>
<listitem><simpara> the header name
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>value</parameter>&nbsp;:</term>
<listitem><simpara> the header value
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&nbsp;:</term>
<listitem><simpara> the data passed to <link linkend="soup-message-headers-foreach"><function>soup_message_headers_foreach()</function></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-headers-foreach" role="function"/>soup_message_headers_foreach ()</title>
<indexterm><primary>soup_message_headers_foreach</primary></indexterm><programlisting><link linkend="void">void</link>                soup_message_headers_foreach        (<link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs,
                                                         <link linkend="SoupMessageHeadersForeachFunc">SoupMessageHeadersForeachFunc</link> func,
                                                         <link linkend="gpointer">gpointer</link> user_data);</programlisting>
<para>
Calls <parameter>func</parameter> once for each header value in <parameter>hdrs</parameter>.
</para>
<para>
Beware that unlike <link linkend="soup-message-headers-get"><function>soup_message_headers_get()</function></link>, this processes the
headers in exactly the way they were added, rather than
concatenating multiple same-named headers into a single value.
(This is intentional; it ensures that if you call
<link linkend="soup-message-headers-append"><function>soup_message_headers_append()</function></link> multiple times with the same name,
then the I/O code will output multiple copies of the header when
sending the message to the remote implementation, which may be
required for interoperability in some cases.)
</para>
<para>
You may not modify the headers from <parameter>func</parameter>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>hdrs</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessageHeaders"><type>SoupMessageHeaders</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>func</parameter>&nbsp;:</term>
<listitem><simpara> callback function to run for each header
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&nbsp;:</term>
<listitem><simpara> data to pass to <parameter>func</parameter>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="SoupMessageHeadersIter" role="struct"/>SoupMessageHeadersIter</title>
<indexterm><primary>SoupMessageHeadersIter</primary></indexterm><programlisting>typedef struct {
} SoupMessageHeadersIter;
</programlisting>
<para>
An opaque type used to iterate over a <link linkend="SoupMessageHeaders"><literal>SoupMessageHeaders</literal></link>
structure.
</para>
<para>
After intializing the iterator with
<link linkend="soup-message-headers-iter-init"><function>soup_message_headers_iter_init()</function></link>, call
<link linkend="soup-message-headers-iter-next"><function>soup_message_headers_iter_next()</function></link> to fetch data from it.
</para>
<para>
You may not modify the headers while iterating over them.</para>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="soup-message-headers-iter-init" role="function"/>soup_message_headers_iter_init ()</title>
<indexterm><primary>soup_message_headers_iter_init</primary></indexterm><programlisting><link linkend="void">void</link>                soup_message_headers_iter_init      (<link linkend="SoupMessageHeadersIter">SoupMessageHeadersIter</link> *iter,
                                                         <link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs);</programlisting>
<para>
Initializes <parameter>iter</parameter> for iterating <parameter>hdrs</parameter>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>iter</parameter>&nbsp;:</term>
<listitem><simpara> a pointer to a <link linkend="SoupMessageHeadersIter"><literal>SoupMessageHeadersIter</literal></link> structure
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>hdrs</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessageHeaders"><literal>SoupMessageHeaders</literal></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-headers-iter-next" role="function"/>soup_message_headers_iter_next ()</title>
<indexterm><primary>soup_message_headers_iter_next</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            soup_message_headers_iter_next      (<link linkend="SoupMessageHeadersIter">SoupMessageHeadersIter</link> *iter,
                                                         const <link linkend="char">char</link> **name,
                                                         const <link linkend="char">char</link> **value);</programlisting>
<para>
Yields the next name/value pair in the <link linkend="SoupMessageHeaders"><literal>SoupMessageHeaders</literal></link> being
iterated by <parameter>iter</parameter>. If <parameter>iter</parameter> has already yielded the last header,
then <link linkend="soup-message-headers-iter-next"><function>soup_message_headers_iter_next()</function></link> will return <link linkend="FALSE:CAPS"><literal>FALSE</literal></link> and <parameter>name</parameter>
and <parameter>value</parameter> will be unchanged.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>iter</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessageHeadersIter"><literal>SoupMessageHeadersIter</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>name</parameter>&nbsp;:</term>
<listitem><simpara> pointer to a variable to return the header name in
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>value</parameter>&nbsp;:</term>
<listitem><simpara> pointer to a variable to return the header value in
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> if another name and value were returned, <link linkend="FALSE:CAPS"><literal>FALSE</literal></link>
if the end of the headers has been reached.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="SoupEncoding" role="enum"/>enum SoupEncoding</title>
<indexterm><primary>SoupEncoding</primary></indexterm><programlisting>typedef enum {
	SOUP_ENCODING_UNRECOGNIZED,
	SOUP_ENCODING_NONE,
	SOUP_ENCODING_CONTENT_LENGTH,
	SOUP_ENCODING_EOF,
	SOUP_ENCODING_CHUNKED,
	SOUP_ENCODING_BYTERANGES
} SoupEncoding;
</programlisting>
<para>
How a message body is encoded for transport</para>
<para>

</para><variablelist role="enum">
<varlistentry>
<term><anchor id="SOUP-ENCODING-UNRECOGNIZED:CAPS" role="constant"/><literal>SOUP_ENCODING_UNRECOGNIZED</literal></term>
<listitem><simpara> unknown / error
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="SOUP-ENCODING-NONE:CAPS" role="constant"/><literal>SOUP_ENCODING_NONE</literal></term>
<listitem><simpara> no body is present (which is not the same as a
0-length body, and only occurs in certain places)
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="SOUP-ENCODING-CONTENT-LENGTH:CAPS" role="constant"/><literal>SOUP_ENCODING_CONTENT_LENGTH</literal></term>
<listitem><simpara> Content-Length encoding
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="SOUP-ENCODING-EOF:CAPS" role="constant"/><literal>SOUP_ENCODING_EOF</literal></term>
<listitem><simpara> Response body ends when the connection is closed
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="SOUP-ENCODING-CHUNKED:CAPS" role="constant"/><literal>SOUP_ENCODING_CHUNKED</literal></term>
<listitem><simpara> chunked encoding (currently only supported
for response)
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="SOUP-ENCODING-BYTERANGES:CAPS" role="constant"/><literal>SOUP_ENCODING_BYTERANGES</literal></term>
<listitem><simpara> multipart/byteranges (Reserved for future
use: NOT CURRENTLY IMPLEMENTED)
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-headers-get-encoding" role="function"/>soup_message_headers_get_encoding ()</title>
<indexterm><primary>soup_message_headers_get_encoding</primary></indexterm><programlisting><link linkend="SoupEncoding">SoupEncoding</link>        soup_message_headers_get_encoding   (<link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs);</programlisting>
<para>
Gets the message body encoding that <parameter>hdrs</parameter> declare. This may not
always correspond to the encoding used on the wire; eg, a HEAD
response may declare a Content-Length or Transfer-Encoding, but
it will never actually include a body.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>hdrs</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessageHeaders"><type>SoupMessageHeaders</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the encoding declared by <parameter>hdrs</parameter>.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-headers-set-encoding" role="function"/>soup_message_headers_set_encoding ()</title>
<indexterm><primary>soup_message_headers_set_encoding</primary></indexterm><programlisting><link linkend="void">void</link>                soup_message_headers_set_encoding   (<link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs,
                                                         <link linkend="SoupEncoding">SoupEncoding</link> encoding);</programlisting>
<para>
Sets the message body encoding that <parameter>hdrs</parameter> will declare. In particular,
you should use this if you are going to send a request or response in
chunked encoding.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>hdrs</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessageHeaders"><type>SoupMessageHeaders</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>encoding</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupEncoding"><type>SoupEncoding</type></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-headers-get-content-length" role="function"/>soup_message_headers_get_content_length ()</title>
<indexterm><primary>soup_message_headers_get_content_length</primary></indexterm><programlisting><link linkend="goffset">goffset</link>             soup_message_headers_get_content_length
                                                        (<link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs);</programlisting>
<para>
Gets the message body length that <parameter>hdrs</parameter> declare. This will only
be non-0 if <link linkend="soup-message-headers-get-encoding"><function>soup_message_headers_get_encoding()</function></link> returns
<link linkend="SOUP-ENCODING-CONTENT-LENGTH:CAPS"><literal>SOUP_ENCODING_CONTENT_LENGTH</literal></link>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>hdrs</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessageHeaders"><type>SoupMessageHeaders</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the message body length declared by <parameter>hdrs</parameter>.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-headers-set-content-length" role="function"/>soup_message_headers_set_content_length ()</title>
<indexterm><primary>soup_message_headers_set_content_length</primary></indexterm><programlisting><link linkend="void">void</link>                soup_message_headers_set_content_length
                                                        (<link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs,
                                                         <link linkend="goffset">goffset</link> content_length);</programlisting>
<para>
Sets the message body length that <parameter>hdrs</parameter> will declare, and sets
<parameter>hdrs</parameter>'s encoding to <link linkend="SOUP-ENCODING-CONTENT-LENGTH:CAPS"><literal>SOUP_ENCODING_CONTENT_LENGTH</literal></link>.
</para>
<para>
You do not normally need to call this; if <parameter>hdrs</parameter> is set to use
Content-Length encoding, libsoup will automatically set its
Content-Length header for you immediately before sending the
headers. One situation in which this method is useful is when
generating the response to a HEAD request; Calling
<link linkend="soup-message-headers-set-content-length"><function>soup_message_headers_set_content_length()</function></link> allows you to put the
correct content length into the response without needing to waste
memory by filling in a response body which won't actually be sent.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>hdrs</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessageHeaders"><type>SoupMessageHeaders</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>content_length</parameter>&nbsp;:</term>
<listitem><simpara> the message body length
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="SoupExpectation" role="enum"/>enum SoupExpectation</title>
<indexterm><primary>SoupExpectation</primary></indexterm><programlisting>typedef enum {
	SOUP_EXPECTATION_UNRECOGNIZED = (1 &lt;&lt; 0),
	SOUP_EXPECTATION_CONTINUE     = (1 &lt;&lt; 1)
} SoupExpectation;
</programlisting>
<para>
Represents the parsed value of the "Expect" header.</para>
<para>

</para><variablelist role="enum">
<varlistentry>
<term><anchor id="SOUP-EXPECTATION-UNRECOGNIZED:CAPS" role="constant"/><literal>SOUP_EXPECTATION_UNRECOGNIZED</literal></term>
<listitem><simpara> any unrecognized expectation
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="SOUP-EXPECTATION-CONTINUE:CAPS" role="constant"/><literal>SOUP_EXPECTATION_CONTINUE</literal></term>
<listitem><simpara> "100-continue"
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-headers-get-expectations" role="function"/>soup_message_headers_get_expectations ()</title>
<indexterm><primary>soup_message_headers_get_expectations</primary></indexterm><programlisting><link linkend="SoupExpectation">SoupExpectation</link>     soup_message_headers_get_expectations
                                                        (<link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs);</programlisting>
<para>
Gets the expectations declared by <parameter>hdrs</parameter>'s "Expect" header.
Currently this will either be <link linkend="SOUP-EXPECTATION-CONTINUE:CAPS"><literal>SOUP_EXPECTATION_CONTINUE</literal></link> or
<link linkend="SOUP-EXPECTATION-UNRECOGNIZED:CAPS"><literal>SOUP_EXPECTATION_UNRECOGNIZED</literal></link>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>hdrs</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessageHeaders"><type>SoupMessageHeaders</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the contents of <parameter>hdrs</parameter>'s "Expect" header
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-headers-set-expectations" role="function"/>soup_message_headers_set_expectations ()</title>
<indexterm><primary>soup_message_headers_set_expectations</primary></indexterm><programlisting><link linkend="void">void</link>                soup_message_headers_set_expectations
                                                        (<link linkend="SoupMessageHeaders">SoupMessageHeaders</link> *hdrs,
                                                         <link linkend="SoupExpectation">SoupExpectation</link> expectations);</programlisting>
<para>
Sets <parameter>hdrs</parameter>'s "Expect" header according to <parameter>expectations</parameter>.
</para>
<para>
Currently <link linkend="SOUP-EXPECTATION-CONTINUE:CAPS"><literal>SOUP_EXPECTATION_CONTINUE</literal></link> is the only known expectation
value. You should set this value on a request if you are sending a
large message body (eg, via POST or PUT), and want to give the
server a chance to reject the request after seeing just the headers
(eg, because it will require authentication before allowing you to
post, or because you're POSTing to a URL that doesn't exist). This
saves you from having to transmit the large request body when the
server is just going to ignore it anyway.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>hdrs</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessageHeaders"><type>SoupMessageHeaders</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>expectations</parameter>&nbsp;:</term>
<listitem><simpara> the expectations to set
</simpara></listitem></varlistentry>
</variablelist></refsect2>

</refsect1>



<refsect1>
<title>See Also</title>
<link linkend="SoupMessage"><type>SoupMessage</type></link>
</refsect1>


<refsect1><refsect2 /><refsect2 /></refsect1>
</refentry>

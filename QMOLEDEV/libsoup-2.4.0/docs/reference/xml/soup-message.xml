<?xml version="1.0"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" 
               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<refentry id="SoupMessage">
<refmeta>
<refentrytitle role="top_of_page">SoupMessage</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>LIBSOUP-2.4 Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>SoupMessage</refname>
<refpurpose>An HTTP request and response.</refpurpose>
<!--[<xref linkend="desc" endterm="desc.title"/>]-->
</refnamediv>

<refsynopsisdiv role="synopsis">
<title role="synopsis.title">Synopsis</title>

<synopsis>



struct              <link linkend="SoupMessage-struct">SoupMessage</link>;

<link linkend="SoupMessage">SoupMessage</link>*        <link linkend="soup-message-new">soup_message_new</link>                    (const <link linkend="char">char</link> *method,
                                                         const <link linkend="char">char</link> *uri_string);
<link linkend="SoupMessage">SoupMessage</link>*        <link linkend="soup-message-new-from-uri">soup_message_new_from_uri</link>           (const <link linkend="char">char</link> *method,
                                                         <link linkend="SoupURI">SoupURI</link> *uri);
<link linkend="void">void</link>                <link linkend="soup-message-set-request">soup_message_set_request</link>            (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         const <link linkend="char">char</link> *content_type,
                                                         <link linkend="SoupMemoryUse">SoupMemoryUse</link> req_use,
                                                         const <link linkend="char">char</link> *req_body,
                                                         <link linkend="gsize">gsize</link> req_length);
<link linkend="void">void</link>                <link linkend="soup-message-set-response">soup_message_set_response</link>           (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         const <link linkend="char">char</link> *content_type,
                                                         <link linkend="SoupMemoryUse">SoupMemoryUse</link> resp_use,
                                                         const <link linkend="char">char</link> *resp_body,
                                                         <link linkend="gsize">gsize</link> resp_length);

enum                <link linkend="SoupHTTPVersion">SoupHTTPVersion</link>;
<link linkend="void">void</link>                <link linkend="soup-message-set-http-version">soup_message_set_http_version</link>       (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="SoupHTTPVersion">SoupHTTPVersion</link> version);
<link linkend="SoupHTTPVersion">SoupHTTPVersion</link>     <link linkend="soup-message-get-http-version">soup_message_get_http_version</link>       (<link linkend="SoupMessage">SoupMessage</link> *msg);
<link linkend="SoupURI">SoupURI</link>*            <link linkend="soup-message-get-uri">soup_message_get_uri</link>                (<link linkend="SoupMessage">SoupMessage</link> *msg);
<link linkend="void">void</link>                <link linkend="soup-message-set-uri">soup_message_set_uri</link>                (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="SoupURI">SoupURI</link> *uri);

<link linkend="void">void</link>                <link linkend="soup-message-set-status">soup_message_set_status</link>             (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="guint">guint</link> status_code);
<link linkend="void">void</link>                <link linkend="soup-message-set-status-full">soup_message_set_status_full</link>        (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="guint">guint</link> status_code,
                                                         const <link linkend="char">char</link> *reason_phrase);
<link linkend="gboolean">gboolean</link>            <link linkend="soup-message-is-keepalive">soup_message_is_keepalive</link>           (<link linkend="SoupMessage">SoupMessage</link> *msg);

<link linkend="guint">guint</link>               <link linkend="soup-message-add-header-handler">soup_message_add_header_handler</link>     (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         const <link linkend="char">char</link> *signal,
                                                         const <link linkend="char">char</link> *header,
                                                         <link linkend="GCallback">GCallback</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data);
<link linkend="guint">guint</link>               <link linkend="soup-message-add-status-code-handler">soup_message_add_status_code_handler</link>
                                                        (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         const <link linkend="char">char</link> *signal,
                                                         <link linkend="guint">guint</link> status_code,
                                                         <link linkend="GCallback">GCallback</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data);

enum                <link linkend="SoupMessageFlags">SoupMessageFlags</link>;
<link linkend="void">void</link>                <link linkend="soup-message-set-flags">soup_message_set_flags</link>              (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="SoupMessageFlags">SoupMessageFlags</link> flags);
<link linkend="SoupMessageFlags">SoupMessageFlags</link>    <link linkend="soup-message-get-flags">soup_message_get_flags</link>              (<link linkend="SoupMessage">SoupMessage</link> *msg);
<link linkend="SoupBuffer">SoupBuffer</link>*         (<link linkend="SoupChunkAllocator">*SoupChunkAllocator</link>)               (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="gsize">gsize</link> max_len,
                                                         <link linkend="gpointer">gpointer</link> user_data);
<link linkend="void">void</link>                <link linkend="soup-message-set-chunk-allocator">soup_message_set_chunk_allocator</link>    (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="SoupChunkAllocator">SoupChunkAllocator</link> allocator,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy_notify);

#define             <link linkend="SOUP-MESSAGE-METHOD:CAPS">SOUP_MESSAGE_METHOD</link>
#define             <link linkend="SOUP-MESSAGE-URI:CAPS">SOUP_MESSAGE_URI</link>
#define             <link linkend="SOUP-MESSAGE-HTTP-VERSION:CAPS">SOUP_MESSAGE_HTTP_VERSION</link>
#define             <link linkend="SOUP-MESSAGE-FLAGS:CAPS">SOUP_MESSAGE_FLAGS</link>
#define             <link linkend="SOUP-MESSAGE-STATUS-CODE:CAPS">SOUP_MESSAGE_STATUS_CODE</link>
#define             <link linkend="SOUP-MESSAGE-REASON-PHRASE:CAPS">SOUP_MESSAGE_REASON_PHRASE</link>


</synopsis>
</refsynopsisdiv>

<refsect1 role="object_hierarchy">
<title role="object_hierarchy.title">Object Hierarchy</title>
<synopsis>

  <link linkend="GObject">GObject</link>
   +----SoupMessage
</synopsis>

</refsect1>





<refsect1 role="properties">
<title role="properties.title">Properties</title>
<synopsis>

  &quot;<link linkend="SoupMessage--flags">flags</link>&quot;                    <link linkend="SoupMessageFlags">SoupMessageFlags</link>      : Read / Write
  &quot;<link linkend="SoupMessage--http-version">http-version</link>&quot;             <link linkend="SoupHTTPVersion">SoupHTTPVersion</link>       : Read / Write
  &quot;<link linkend="SoupMessage--method">method</link>&quot;                   <link linkend="gchararray">gchararray</link>            : Read / Write
  &quot;<link linkend="SoupMessage--reason-phrase">reason-phrase</link>&quot;            <link linkend="gchararray">gchararray</link>            : Read / Write
  &quot;<link linkend="SoupMessage--status-code">status-code</link>&quot;              <link linkend="guint">guint</link>                 : Read / Write
  &quot;<link linkend="SoupMessage--uri">uri</link>&quot;                      <link linkend="SoupURI">SoupURI</link>               : Read / Write
</synopsis>
</refsect1>

<refsect1 role="signal_proto">
<title role="signal_proto.title">Signals</title>
<synopsis>

  &quot;<link linkend="SoupMessage-finished">finished</link>&quot;                                       : Run First
  &quot;<link linkend="SoupMessage-got-body">got-body</link>&quot;                                       : Run First
  &quot;<link linkend="SoupMessage-got-chunk">got-chunk</link>&quot;                                      : Run First
  &quot;<link linkend="SoupMessage-got-headers">got-headers</link>&quot;                                    : Run First
  &quot;<link linkend="SoupMessage-got-informational">got-informational</link>&quot;                              : Run First
  &quot;<link linkend="SoupMessage-restarted">restarted</link>&quot;                                      : Run First
  &quot;<link linkend="SoupMessage-wrote-body">wrote-body</link>&quot;                                     : Run First
  &quot;<link linkend="SoupMessage-wrote-chunk">wrote-chunk</link>&quot;                                    : Run First
  &quot;<link linkend="SoupMessage-wrote-headers">wrote-headers</link>&quot;                                  : Run First
  &quot;<link linkend="SoupMessage-wrote-informational">wrote-informational</link>&quot;                            : Run First
</synopsis>
</refsect1>


<refsect1 role="desc">
<title role="desc.title">Description</title>
<para>
A <link linkend="SoupMessage"><type>SoupMessage</type></link> represents an HTTP message that is being sent or
received.
</para>
<para>
For client-side usage, you would create a <link linkend="SoupMessage"><type>SoupMessage</type></link> with
<link linkend="soup-message-new"><function>soup_message_new()</function></link> or <link linkend="soup-message-new-from-uri"><function>soup_message_new_from_uri()</function></link>, set up its
fields appropriate, and send it via a <link linkend="SoupSession"><type>SoupSession</type></link>.
</para>
<para>
For server-side usage, <link linkend="SoupServer"><type>SoupServer</type></link> will create <link linkend="SoupMessage"><type>SoupMessage</type></link><!--
-->s automatically for incoming requests, which your application
will receive via handlers.
</para>
<para>
Note that libsoup's terminology here does not quite match the HTTP
specification: in RFC 2616, an "HTTP-message" is
<emphasis>either</emphasis> a Request, <emphasis>or</emphasis> a
Response. In libsoup, a <link linkend="SoupMessage"><type>SoupMessage</type></link> combines both the request and
the response.</para>
<para>

</para>
</refsect1>

<refsect1 role="details">
<title role="details.title">Details</title>
<refsect2>
<title><anchor id="SoupMessage-struct" role="struct"/>struct SoupMessage</title>
<indexterm><primary>SoupMessage</primary></indexterm><programlisting>struct SoupMessage {
	const char         *method;

	guint               status_code;
	const char         *reason_phrase;

	SoupMessageBody    *request_body;
	SoupMessageHeaders *request_headers;

	SoupMessageBody    *response_body;
	SoupMessageHeaders *response_headers;
};
</programlisting>
<para>
Represents an HTTP message being sent or received.
</para>
<para>
As described in the <link linkend="SoupMessageBody"><type>SoupMessageBody</type></link> documentation, the
<parameter>request_body</parameter> and <parameter>response_body</parameter> <link linkend="data"><literal>data</literal></link> fields will not necessarily
be filled in at all times. When they are filled in, they will be
terminated with a '\0' byte (which is not included in the <link linkend="length"><literal>length</literal></link>),
so you can use them as ordinary C strings (assuming that you know
that the body doesn't have any other '\0' bytes).
</para>
<para>
For a client-side <link linkend="SoupMessage"><type>SoupMessage</type></link>, <parameter>request_body</parameter>'s <link linkend="data"><literal>data</literal></link> is usually
filled in right before libsoup writes the request to the network,
but you should not count on this; use <link linkend="soup-message-body-flatten"><function>soup_message_body_flatten()</function></link>
if you want to ensure that <link linkend="data"><literal>data</literal></link> is filled in. <parameter>response_body</parameter>'s
<link linkend="data"><literal>data</literal></link> will be filled in before <link linkend="SoupMessage-finished"><type>"finished"</type></link> is emitted,
unless you set the <link linkend="SOUP-MESSAGE-OVERWRITE-CHUNKS:CAPS"><literal>SOUP_MESSAGE_OVERWRITE_CHUNKS</literal></link> flag.
</para>
<para>
For a server-side <link linkend="SoupMessage"><type>SoupMessage</type></link>, <parameter>request_body</parameter>'s <link linkend="data"><literal>data</literal></link> will be
filled in before <link linkend="SoupMessage-got-body"><type>"got_body"</type></link> is emitted.</para>
<para>

</para><variablelist role="struct">
<varlistentry>
<term>const&nbsp;<link linkend="char">char</link>&nbsp;*<structfield>method</structfield>;</term>
<listitem><simpara> the HTTP method
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="guint">guint</link>&nbsp;<structfield>status_code</structfield>;</term>
<listitem><simpara> the HTTP status code
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>const&nbsp;<link linkend="char">char</link>&nbsp;*<structfield>reason_phrase</structfield>;</term>
<listitem><simpara> the status phrase associated with <parameter>status_code</parameter>
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="SoupMessageBody">SoupMessageBody</link>&nbsp;*<structfield>request_body</structfield>;</term>
<listitem><simpara> the request body
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="SoupMessageHeaders">SoupMessageHeaders</link>&nbsp;*<structfield>request_headers</structfield>;</term>
<listitem><simpara> the request headers
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="SoupMessageBody">SoupMessageBody</link>&nbsp;*<structfield>response_body</structfield>;</term>
<listitem><simpara> the response body
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="SoupMessageHeaders">SoupMessageHeaders</link>&nbsp;*<structfield>response_headers</structfield>;</term>
<listitem><simpara> the response headers
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-new" role="function"/>soup_message_new ()</title>
<indexterm><primary>soup_message_new</primary></indexterm><programlisting><link linkend="SoupMessage">SoupMessage</link>*        soup_message_new                    (const <link linkend="char">char</link> *method,
                                                         const <link linkend="char">char</link> *uri_string);</programlisting>
<para>
Creates a new empty <link linkend="SoupMessage"><type>SoupMessage</type></link>, which will connect to <parameter>uri</parameter></para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>method</parameter>&nbsp;:</term>
<listitem><simpara> the HTTP method for the created request
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>uri_string</parameter>&nbsp;:</term>
<listitem><simpara> the destination endpoint (as a string)
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the new <link linkend="SoupMessage"><type>SoupMessage</type></link> (or <link linkend="NULL:CAPS"><literal>NULL</literal></link> if <parameter>uri</parameter> could not
be parsed).
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-new-from-uri" role="function"/>soup_message_new_from_uri ()</title>
<indexterm><primary>soup_message_new_from_uri</primary></indexterm><programlisting><link linkend="SoupMessage">SoupMessage</link>*        soup_message_new_from_uri           (const <link linkend="char">char</link> *method,
                                                         <link linkend="SoupURI">SoupURI</link> *uri);</programlisting>
<para>
Creates a new empty <link linkend="SoupMessage"><type>SoupMessage</type></link>, which will connect to <parameter>uri</parameter></para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>method</parameter>&nbsp;:</term>
<listitem><simpara> the HTTP method for the created request
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>uri</parameter>&nbsp;:</term>
<listitem><simpara> the destination endpoint (as a <link linkend="SoupURI"><type>SoupURI</type></link>)
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the new <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-set-request" role="function"/>soup_message_set_request ()</title>
<indexterm><primary>soup_message_set_request</primary></indexterm><programlisting><link linkend="void">void</link>                soup_message_set_request            (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         const <link linkend="char">char</link> *content_type,
                                                         <link linkend="SoupMemoryUse">SoupMemoryUse</link> req_use,
                                                         const <link linkend="char">char</link> *req_body,
                                                         <link linkend="gsize">gsize</link> req_length);</programlisting>
<para>
Convenience function to set the request body of a <link linkend="SoupMessage"><type>SoupMessage</type></link>. If
<parameter>content_type</parameter> is <link linkend="NULL:CAPS"><literal>NULL</literal></link>, the request body must be empty as well.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> the message
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>content_type</parameter>&nbsp;:</term>
<listitem><simpara> MIME Content-Type of the body
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>req_use</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMemoryUse"><type>SoupMemoryUse</type></link> describing how to handle <parameter>req_body</parameter>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>req_body</parameter>&nbsp;:</term>
<listitem><simpara> a data buffer containing the body of the message request.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>req_length</parameter>&nbsp;:</term>
<listitem><simpara> the byte length of <parameter>req_body</parameter>.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-set-response" role="function"/>soup_message_set_response ()</title>
<indexterm><primary>soup_message_set_response</primary></indexterm><programlisting><link linkend="void">void</link>                soup_message_set_response           (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         const <link linkend="char">char</link> *content_type,
                                                         <link linkend="SoupMemoryUse">SoupMemoryUse</link> resp_use,
                                                         const <link linkend="char">char</link> *resp_body,
                                                         <link linkend="gsize">gsize</link> resp_length);</programlisting>
<para>
Convenience function to set the response body of a <link linkend="SoupMessage"><type>SoupMessage</type></link>. If
<parameter>content_type</parameter> is <link linkend="NULL:CAPS"><literal>NULL</literal></link>, the response body must be empty as well.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> the message
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>content_type</parameter>&nbsp;:</term>
<listitem><simpara> MIME Content-Type of the body
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>resp_use</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMemoryUse"><type>SoupMemoryUse</type></link> describing how to handle <parameter>resp_body</parameter>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>resp_body</parameter>&nbsp;:</term>
<listitem><simpara> a data buffer containing the body of the message response.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>resp_length</parameter>&nbsp;:</term>
<listitem><simpara> the byte length of <parameter>resp_body</parameter>.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="SoupHTTPVersion" role="enum"/>enum SoupHTTPVersion</title>
<indexterm><primary>SoupHTTPVersion</primary></indexterm><programlisting>typedef enum {
	SOUP_HTTP_1_0 = 0,
	SOUP_HTTP_1_1 = 1
} SoupHTTPVersion;
</programlisting>
<para>
Indicates the HTTP protocol version being used.</para>
<para>

</para><variablelist role="enum">
<varlistentry>
<term><anchor id="SOUP-HTTP-1-0:CAPS" role="constant"/><literal>SOUP_HTTP_1_0</literal></term>
<listitem><simpara> HTTP 1.0 (RFC 1945)
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="SOUP-HTTP-1-1:CAPS" role="constant"/><literal>SOUP_HTTP_1_1</literal></term>
<listitem><simpara> HTTP 1.1 (RFC 2616)
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-set-http-version" role="function"/>soup_message_set_http_version ()</title>
<indexterm><primary>soup_message_set_http_version</primary></indexterm><programlisting><link linkend="void">void</link>                soup_message_set_http_version       (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="SoupHTTPVersion">SoupHTTPVersion</link> version);</programlisting>
<para>
Sets the HTTP version on <parameter>msg</parameter>. The default version is
<link linkend="SOUP-HTTP-1-1:CAPS"><literal>SOUP_HTTP_1_1</literal></link>. Setting it to <link linkend="SOUP-HTTP-1-0:CAPS"><literal>SOUP_HTTP_1_0</literal></link> will prevent certain
functionality from being used.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>version</parameter>&nbsp;:</term>
<listitem><simpara> the HTTP version
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-get-http-version" role="function"/>soup_message_get_http_version ()</title>
<indexterm><primary>soup_message_get_http_version</primary></indexterm><programlisting><link linkend="SoupHTTPVersion">SoupHTTPVersion</link>     soup_message_get_http_version       (<link linkend="SoupMessage">SoupMessage</link> *msg);</programlisting>
<para>
Gets the HTTP version of <parameter>msg</parameter>. This is the minimum of the
version from the request and the version from the response.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the HTTP version
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-get-uri" role="function"/>soup_message_get_uri ()</title>
<indexterm><primary>soup_message_get_uri</primary></indexterm><programlisting><link linkend="SoupURI">SoupURI</link>*            soup_message_get_uri                (<link linkend="SoupMessage">SoupMessage</link> *msg);</programlisting>
<para>
Gets <parameter>msg</parameter>'s URI</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the URI <parameter>msg</parameter> is targeted for.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-set-uri" role="function"/>soup_message_set_uri ()</title>
<indexterm><primary>soup_message_set_uri</primary></indexterm><programlisting><link linkend="void">void</link>                soup_message_set_uri                (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="SoupURI">SoupURI</link> *uri);</programlisting>
<para>
Sets <parameter>msg</parameter>'s URI to <parameter>uri</parameter>. If <parameter>msg</parameter> has already been sent and you want
to re-send it with the new URI, you need to call
<link linkend="soup-session-requeue-message"><function>soup_session_requeue_message()</function></link>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>uri</parameter>&nbsp;:</term>
<listitem><simpara> the new <link linkend="SoupURI"><type>SoupURI</type></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-set-status" role="function"/>soup_message_set_status ()</title>
<indexterm><primary>soup_message_set_status</primary></indexterm><programlisting><link linkend="void">void</link>                soup_message_set_status             (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="guint">guint</link> status_code);</programlisting>
<para>
Sets <parameter>msg</parameter>'s status code to <parameter>status_code</parameter>. If <parameter>status_code</parameter> is a
known value, it will also set <parameter>msg</parameter>'s reason_phrase.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>status_code</parameter>&nbsp;:</term>
<listitem><simpara> an HTTP status code
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-set-status-full" role="function"/>soup_message_set_status_full ()</title>
<indexterm><primary>soup_message_set_status_full</primary></indexterm><programlisting><link linkend="void">void</link>                soup_message_set_status_full        (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="guint">guint</link> status_code,
                                                         const <link linkend="char">char</link> *reason_phrase);</programlisting>
<para>
Sets <parameter>msg</parameter>'s status code and reason phrase.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>status_code</parameter>&nbsp;:</term>
<listitem><simpara> an HTTP status code
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>reason_phrase</parameter>&nbsp;:</term>
<listitem><simpara> a description of the status
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-is-keepalive" role="function"/>soup_message_is_keepalive ()</title>
<indexterm><primary>soup_message_is_keepalive</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            soup_message_is_keepalive           (<link linkend="SoupMessage">SoupMessage</link> *msg);</programlisting>
<para>
Determines whether or not <parameter>msg</parameter>'s connection can be kept alive for
further requests after processing <parameter>msg</parameter>, based on the HTTP version,
Connection header, etc.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> or <link linkend="FALSE:CAPS"><literal>FALSE</literal></link>.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-add-header-handler" role="function"/>soup_message_add_header_handler ()</title>
<indexterm><primary>soup_message_add_header_handler</primary></indexterm><programlisting><link linkend="guint">guint</link>               soup_message_add_header_handler     (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         const <link linkend="char">char</link> *signal,
                                                         const <link linkend="char">char</link> *header,
                                                         <link linkend="GCallback">GCallback</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data);</programlisting>
<para>
Adds a signal handler to <parameter>msg</parameter> for <parameter>signal</parameter>, as with
<link linkend="g-signal-connect"><function>g_signal_connect()</function></link>, but with two differences: the <parameter>callback</parameter> will
only be run if <parameter>msg</parameter> has a header named <parameter>header</parameter>, and it will only be
run if no earlier handler cancelled or requeued the message.
</para>
<para>
If <parameter>signal</parameter> is one of the "got" signals (eg, "got_headers"), or
"finished" or "restarted", then <parameter>header</parameter> is matched against the
incoming message headers (that is, the <link linkend="request-headers"><type>request_headers</type></link> for a
client <link linkend="SoupMessage"><type>SoupMessage</type></link>, or the <link linkend="response-headers"><type>response_headers</type></link> for a server
<link linkend="SoupMessage"><type>SoupMessage</type></link>). If <parameter>signal</parameter> is one of the "wrote" signals, then
<parameter>header</parameter> is matched against the outgoing message headers.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>signal</parameter>&nbsp;:</term>
<listitem><simpara> signal to connect the handler to.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>header</parameter>&nbsp;:</term>
<listitem><simpara> HTTP response header to match against
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&nbsp;:</term>
<listitem><simpara> the header handler
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&nbsp;:</term>
<listitem><simpara> data to pass to <parameter>handler_cb</parameter>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the handler ID from <link linkend="g-signal-connect"><function>g_signal_connect()</function></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-add-status-code-handler" role="function"/>soup_message_add_status_code_handler ()</title>
<indexterm><primary>soup_message_add_status_code_handler</primary></indexterm><programlisting><link linkend="guint">guint</link>               soup_message_add_status_code_handler
                                                        (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         const <link linkend="char">char</link> *signal,
                                                         <link linkend="guint">guint</link> status_code,
                                                         <link linkend="GCallback">GCallback</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data);</programlisting>
<para>
Adds a signal handler to <parameter>msg</parameter> for <parameter>signal</parameter>, as with
<link linkend="g-signal-connect"><function>g_signal_connect()</function></link> but with two differences: the <parameter>callback</parameter> will
only be run if <parameter>msg</parameter> has the status <parameter>status_code</parameter>, and it will only
be run if no earlier handler cancelled or requeued the message.
</para>
<para>
<parameter>signal</parameter> must be a signal that will be emitted after <parameter>msg</parameter>'s status
is set. For a client <link linkend="SoupMessage"><type>SoupMessage</type></link>, this means it can't be a "wrote"
signal. For a server <link linkend="SoupMessage"><type>SoupMessage</type></link>, this means it can't be a "got"
signal.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>signal</parameter>&nbsp;:</term>
<listitem><simpara> signal to connect the handler to.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>status_code</parameter>&nbsp;:</term>
<listitem><simpara> status code to match against
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&nbsp;:</term>
<listitem><simpara> the header handler
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&nbsp;:</term>
<listitem><simpara> data to pass to <parameter>handler_cb</parameter>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the handler ID from <link linkend="g-signal-connect"><function>g_signal_connect()</function></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="SoupMessageFlags" role="enum"/>enum SoupMessageFlags</title>
<indexterm><primary>SoupMessageFlags</primary></indexterm><programlisting>typedef enum {
	SOUP_MESSAGE_NO_REDIRECT      = (1 &lt;&lt; 1),
	SOUP_MESSAGE_OVERWRITE_CHUNKS = (1 &lt;&lt; 3),
} SoupMessageFlags;
</programlisting>
<para>
Various flags that can be set on a <link linkend="SoupMessage"><type>SoupMessage</type></link> to alter its
behavior.</para>
<para>

</para><variablelist role="enum">
<varlistentry>
<term><anchor id="SOUP-MESSAGE-NO-REDIRECT:CAPS" role="constant"/><literal>SOUP_MESSAGE_NO_REDIRECT</literal></term>
<listitem><simpara> The session should not follow redirect
(3xx) responses received by this message.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="SOUP-MESSAGE-OVERWRITE-CHUNKS:CAPS" role="constant"/><literal>SOUP_MESSAGE_OVERWRITE_CHUNKS</literal></term>
<listitem><simpara> Each chunk of the response will be
freed after its corresponding <link linkend="got-chunk"><literal>got_chunk</literal></link> signal is emitted, meaning
<link linkend="response"><literal>response</literal></link> will still be empty after the message is complete. You
can use this to save memory if you expect the response to be large
and you are able to process it a chunk at a time.
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-set-flags" role="function"/>soup_message_set_flags ()</title>
<indexterm><primary>soup_message_set_flags</primary></indexterm><programlisting><link linkend="void">void</link>                soup_message_set_flags              (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="SoupMessageFlags">SoupMessageFlags</link> flags);</programlisting>
<para>
Sets the specified flags on <parameter>msg</parameter>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>flags</parameter>&nbsp;:</term>
<listitem><simpara> a set of <link linkend="SoupMessageFlags"><type>SoupMessageFlags</type></link> values
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-get-flags" role="function"/>soup_message_get_flags ()</title>
<indexterm><primary>soup_message_get_flags</primary></indexterm><programlisting><link linkend="SoupMessageFlags">SoupMessageFlags</link>    soup_message_get_flags              (<link linkend="SoupMessage">SoupMessage</link> *msg);</programlisting>
<para>
Gets the flags on <parameter>msg</parameter></para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the flags
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="SoupChunkAllocator" role="function"/>SoupChunkAllocator ()</title>
<indexterm><primary>SoupChunkAllocator</primary></indexterm><programlisting><link linkend="SoupBuffer">SoupBuffer</link>*         (*SoupChunkAllocator)               (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="gsize">gsize</link> max_len,
                                                         <link linkend="gpointer">gpointer</link> user_data);</programlisting>
<para>
The prototype for a chunk allocation callback. This should allocate
a new <link linkend="SoupBuffer"><type>SoupBuffer</type></link> and return it for the I/O layer to read message
body data off the network into.
</para>
<para>
If <parameter>max_len</parameter> is non-0, it indicates the maximum number of bytes that
could be read, based on what is known about the message size. Note
that this might be a very large number, and you should not simply
try to allocate that many bytes blindly. If <parameter>max_len</parameter> is 0, that
means that libsoup does not know how many bytes remain to be read,
and the allocator should return a buffer of a size that it finds
convenient.
</para>
<para>
If the allocator returns <link linkend="NULL:CAPS"><literal>NULL</literal></link>, the message will be paused. It is
up to the application to make sure that it gets unpaused when it
becomes possible to allocate a new buffer.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> the <link linkend="SoupMessage"><type>SoupMessage</type></link> the chunk is being allocated for
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>max_len</parameter>&nbsp;:</term>
<listitem><simpara> the maximum length that will be read, or 0.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&nbsp;:</term>
<listitem><simpara> the data passed to <link linkend="soup-message-set-chunk-allocator"><function>soup_message_set_chunk_allocator()</function></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the new buffer (or <link linkend="NULL:CAPS"><literal>NULL</literal></link>)
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-message-set-chunk-allocator" role="function"/>soup_message_set_chunk_allocator ()</title>
<indexterm><primary>soup_message_set_chunk_allocator</primary></indexterm><programlisting><link linkend="void">void</link>                soup_message_set_chunk_allocator    (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="SoupChunkAllocator">SoupChunkAllocator</link> allocator,
                                                         <link linkend="gpointer">gpointer</link> user_data,
                                                         <link linkend="GDestroyNotify">GDestroyNotify</link> destroy_notify);</programlisting>
<para>
Sets an alternate chunk-allocation function to use when reading
<parameter>msg</parameter>'s body. Every time data is available to read, libsoup will
call <parameter>allocator</parameter>, which should return a <link linkend="SoupBuffer"><type>SoupBuffer</type></link>. (See
<link linkend="SoupChunkAllocator"><type>SoupChunkAllocator</type></link> for additional details.) Libsoup will then read
data from the network into that buffer, and update the buffer's
<link linkend="length"><literal>length</literal></link> to indicate how much data it read.
</para>
<para>
Generally, a custom chunk allocator would be used in conjunction
with <link linkend="SOUP-MESSAGE-OVERWRITE-CHUNKS:CAPS"><literal>SOUP_MESSAGE_OVERWRITE_CHUNKS</literal></link> and <link linkend="SoupMessage-got-chunk"><type>"got_chunk"</type></link>, as
part of a strategy to avoid unnecessary copying of data. However,
you cannot assume that every call to the allocator will be followed
by a call to your <link linkend="got-chunk"><literal>got_chunk</literal></link> handler; if an I/O error occurs, then
the buffer will be unreffed without ever having been used. If your
buffer-allocation strategy requires special cleanup, use
<link linkend="soup-buffer-new-with-owner"><function>soup_buffer_new_with_owner()</function></link> rather than doing the cleanup from the
<link linkend="got-chunk"><literal>got_chunk</literal></link> handler.
</para>
<para>
The other thing to remember when using
<link linkend="SOUP-MESSAGE-OVERWRITE-CHUNKS:CAPS"><literal>SOUP_MESSAGE_OVERWRITE_CHUNKS</literal></link> is that the buffer passed to the
<link linkend="got-chunk"><literal>got_chunk</literal></link> handler will be unreffed after the handler returns, just
as it would be in the non-custom-allocated case. If you want to
hand the chunk data off to some other part of your program to use
later, you'll need to ref the <link linkend="SoupBuffer"><type>SoupBuffer</type></link> (or its owner, in the
<link linkend="soup-buffer-new-with-owner"><function>soup_buffer_new_with_owner()</function></link> case) to ensure that the data remains
valid.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>allocator</parameter>&nbsp;:</term>
<listitem><simpara> the chunk allocator callback
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&nbsp;:</term>
<listitem><simpara> data to pass to <parameter>allocator</parameter>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>destroy_notify</parameter>&nbsp;:</term>
<listitem><simpara> destroy notifier to free <parameter>user_data</parameter> when <parameter>msg</parameter> is
destroyed
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="SOUP-MESSAGE-METHOD:CAPS" role="macro"/>SOUP_MESSAGE_METHOD</title>
<indexterm><primary>SOUP_MESSAGE_METHOD</primary></indexterm><programlisting>#define SOUP_MESSAGE_METHOD        "method"
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="SOUP-MESSAGE-URI:CAPS" role="macro"/>SOUP_MESSAGE_URI</title>
<indexterm><primary>SOUP_MESSAGE_URI</primary></indexterm><programlisting>#define SOUP_MESSAGE_URI           "uri"
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="SOUP-MESSAGE-HTTP-VERSION:CAPS" role="macro"/>SOUP_MESSAGE_HTTP_VERSION</title>
<indexterm><primary>SOUP_MESSAGE_HTTP_VERSION</primary></indexterm><programlisting>#define SOUP_MESSAGE_HTTP_VERSION  "http-version"
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="SOUP-MESSAGE-FLAGS:CAPS" role="macro"/>SOUP_MESSAGE_FLAGS</title>
<indexterm><primary>SOUP_MESSAGE_FLAGS</primary></indexterm><programlisting>#define SOUP_MESSAGE_FLAGS         "flags"
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="SOUP-MESSAGE-STATUS-CODE:CAPS" role="macro"/>SOUP_MESSAGE_STATUS_CODE</title>
<indexterm><primary>SOUP_MESSAGE_STATUS_CODE</primary></indexterm><programlisting>#define SOUP_MESSAGE_STATUS_CODE   "status-code"
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="SOUP-MESSAGE-REASON-PHRASE:CAPS" role="macro"/>SOUP_MESSAGE_REASON_PHRASE</title>
<indexterm><primary>SOUP_MESSAGE_REASON_PHRASE</primary></indexterm><programlisting>#define SOUP_MESSAGE_REASON_PHRASE "reason-phrase"
</programlisting>
<para>

</para></refsect2>

</refsect1>
<refsect1 role="property_details">
<title role="property_details.title">Property Details</title>
<refsect2><title><anchor id="SoupMessage--flags"/>The <literal>&quot;flags&quot;</literal> property</title>
<indexterm><primary>SoupMessage:flags</primary></indexterm><programlisting>  &quot;flags&quot;                    <link linkend="SoupMessageFlags">SoupMessageFlags</link>      : Read / Write</programlisting>
<para>Various message options.</para></refsect2>
<refsect2><title><anchor id="SoupMessage--http-version"/>The <literal>&quot;http-version&quot;</literal> property</title>
<indexterm><primary>SoupMessage:http-version</primary></indexterm><programlisting>  &quot;http-version&quot;             <link linkend="SoupHTTPVersion">SoupHTTPVersion</link>       : Read / Write</programlisting>
<para>The HTTP protocol version to use.</para><para>Default value: SOUP_HTTP_1_1</para>
</refsect2>
<refsect2><title><anchor id="SoupMessage--method"/>The <literal>&quot;method&quot;</literal> property</title>
<indexterm><primary>SoupMessage:method</primary></indexterm><programlisting>  &quot;method&quot;                   <link linkend="gchararray">gchararray</link>            : Read / Write</programlisting>
<para>The message's HTTP method.</para><para>Default value: "GET"</para>
</refsect2>
<refsect2><title><anchor id="SoupMessage--reason-phrase"/>The <literal>&quot;reason-phrase&quot;</literal> property</title>
<indexterm><primary>SoupMessage:reason-phrase</primary></indexterm><programlisting>  &quot;reason-phrase&quot;            <link linkend="gchararray">gchararray</link>            : Read / Write</programlisting>
<para>The HTTP response reason phrase.</para><para>Default value: NULL</para>
</refsect2>
<refsect2><title><anchor id="SoupMessage--status-code"/>The <literal>&quot;status-code&quot;</literal> property</title>
<indexterm><primary>SoupMessage:status-code</primary></indexterm><programlisting>  &quot;status-code&quot;              <link linkend="guint">guint</link>                 : Read / Write</programlisting>
<para>The HTTP response status code.</para><para>Allowed values: &lt;= 599</para>
<para>Default value: 0</para>
</refsect2>
<refsect2><title><anchor id="SoupMessage--uri"/>The <literal>&quot;uri&quot;</literal> property</title>
<indexterm><primary>SoupMessage:uri</primary></indexterm><programlisting>  &quot;uri&quot;                      <link linkend="SoupURI">SoupURI</link>               : Read / Write</programlisting>
<para>The message's Request-URI.</para></refsect2>

</refsect1>

<refsect1 role="signals">
<title role="signals.title">Signal Details</title>
<refsect2><title><anchor id="SoupMessage-finished"/>The <literal>&quot;finished&quot;</literal> signal</title>
<indexterm><primary>SoupMessage::finished</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                        <link linkend="gpointer">gpointer</link>     user_data)      : Run First</programlisting>
<para>
Emitted when all HTTP processing is finished for a message.
(After <link linkend="SoupMessage-got-body"><type>"got_body"</type></link> for client-side messages, or
after <link linkend="SoupMessage-wrote-body"><type>"wrote_body"</type></link> for server-side messages.)</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> the message
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&nbsp;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist></refsect2><refsect2><title><anchor id="SoupMessage-got-body"/>The <literal>&quot;got-body&quot;</literal> signal</title>
<indexterm><primary>SoupMessage::got-body</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                        <link linkend="gpointer">gpointer</link>     user_data)      : Run First</programlisting>
<para>
Emitted after receiving the complete message body. (For a
server-side message, this means it has received the request
body. For a client-side message, this means it has received
the response body and is nearly done with the message.)
</para>
<para>
See also <link linkend="soup-message-add-header-handler"><function>soup_message_add_header_handler()</function></link> and
<link linkend="soup-message-add-status-code-handler"><function>soup_message_add_status_code_handler()</function></link>, which can be used
to connect to a subset of emissions of this signal.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> the message
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&nbsp;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist></refsect2><refsect2><title><anchor id="SoupMessage-got-chunk"/>The <literal>&quot;got-chunk&quot;</literal> signal</title>
<indexterm><primary>SoupMessage::got-chunk</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                        <link linkend="SoupBuffer">SoupBuffer</link>  *chunk,
                                                        <link linkend="gpointer">gpointer</link>     user_data)      : Run First</programlisting>
<para>
Emitted after receiving a chunk of a message body. Note
that "chunk" in this context means any subpiece of the
body, not necessarily the specific HTTP 1.1 chunks sent by
the other side.
</para>
<para>
If you cancel or requeue <parameter>msg</parameter> while processing this signal,
then the current HTTP I/O will be stopped after this signal
emission finished, and <parameter>msg</parameter>'s connection will be closed.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> the message
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>chunk</parameter>&nbsp;:</term>
<listitem><simpara> the just-read chunk
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&nbsp;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist></refsect2><refsect2><title><anchor id="SoupMessage-got-headers"/>The <literal>&quot;got-headers&quot;</literal> signal</title>
<indexterm><primary>SoupMessage::got-headers</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                        <link linkend="gpointer">gpointer</link>     user_data)      : Run First</programlisting>
<para>
Emitted after receiving all message headers for a message.
(For a client-side message, this is after receiving the
Status-Line and response headers; for a server-side
message, it is after receiving the Request-Line and request
headers.)
</para>
<para>
See also <link linkend="soup-message-add-header-handler"><function>soup_message_add_header_handler()</function></link> and
<link linkend="soup-message-add-status-code-handler"><function>soup_message_add_status_code_handler()</function></link>, which can be used
to connect to a subset of emissions of this signal.
</para>
<para>
If you cancel or requeue <parameter>msg</parameter> while processing this signal,
then the current HTTP I/O will be stopped after this signal
emission finished, and <parameter>msg</parameter>'s connection will be closed.
(If you need to requeue a message--eg, after handling
authentication or redirection--it is usually better to
requeue it from a <link linkend="SoupMessage-got-body"><type>"got_body"</type></link> handler rather
than a <link linkend="SoupMessage-got-header"><type>"got_header"</type></link> handler, so that the
existing HTTP connection can be reused.)</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> the message
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&nbsp;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist></refsect2><refsect2><title><anchor id="SoupMessage-got-informational"/>The <literal>&quot;got-informational&quot;</literal> signal</title>
<indexterm><primary>SoupMessage::got-informational</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                        <link linkend="gpointer">gpointer</link>     user_data)      : Run First</programlisting>
<para>
Emitted after receiving a 1xx (Informational) response for
a (client-side) message. The response_headers will be
filled in with the headers associated with the
informational response; however, those header values will
be erased after this signal is done.
</para>
<para>
If you cancel or requeue <parameter>msg</parameter> while processing this signal,
then the current HTTP I/O will be stopped after this signal
emission finished, and <parameter>msg</parameter>'s connection will be closed.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> the message
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&nbsp;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist></refsect2><refsect2><title><anchor id="SoupMessage-restarted"/>The <literal>&quot;restarted&quot;</literal> signal</title>
<indexterm><primary>SoupMessage::restarted</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                        <link linkend="gpointer">gpointer</link>     user_data)      : Run First</programlisting>
<para>
Emitted when a request that was already sent once is now
being sent again (eg, because the first attempt received a
redirection response, or because we needed to use
authentication).</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> the message
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&nbsp;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist></refsect2><refsect2><title><anchor id="SoupMessage-wrote-body"/>The <literal>&quot;wrote-body&quot;</literal> signal</title>
<indexterm><primary>SoupMessage::wrote-body</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                        <link linkend="gpointer">gpointer</link>     user_data)      : Run First</programlisting>
<para>
Emitted immediately after writing the complete body for a
message. (For a client-side message, this means that
libsoup is done writing and is now waiting for the response
from the server. For a server-side message, this means that
libsoup has finished writing the response and is nearly
done with the message.)</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> the message
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&nbsp;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist></refsect2><refsect2><title><anchor id="SoupMessage-wrote-chunk"/>The <literal>&quot;wrote-chunk&quot;</literal> signal</title>
<indexterm><primary>SoupMessage::wrote-chunk</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                        <link linkend="gpointer">gpointer</link>     user_data)      : Run First</programlisting>
<para>
Emitted immediately after writing a body chunk for a message.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> the message
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&nbsp;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist></refsect2><refsect2><title><anchor id="SoupMessage-wrote-headers"/>The <literal>&quot;wrote-headers&quot;</literal> signal</title>
<indexterm><primary>SoupMessage::wrote-headers</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                        <link linkend="gpointer">gpointer</link>     user_data)      : Run First</programlisting>
<para>
Emitted immediately after writing the headers for a
message. (For a client-side message, this is after writing
the request headers; for a server-side message, it is after
writing the response headers.)</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> the message
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&nbsp;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist></refsect2><refsect2><title><anchor id="SoupMessage-wrote-informational"/>The <literal>&quot;wrote-informational&quot;</literal> signal</title>
<indexterm><primary>SoupMessage::wrote-informational</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="SoupMessage">SoupMessage</link> *msg,
                                                        <link linkend="gpointer">gpointer</link>     user_data)      : Run First</programlisting>
<para>
Emitted immediately after writing a 1xx (Informational)
response for a (server-side) message.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> the message
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&nbsp;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist></refsect2>
</refsect1>


<refsect1>
<title>See Also</title>
<link linkend="SoupMessageHeaders"><type>SoupMessageHeaders</type></link>, <link linkend="SoupMessageBody"><type>SoupMessageBody</type></link>
</refsect1>


<refsect1><refsect2 /><refsect2 /></refsect1>
</refentry>

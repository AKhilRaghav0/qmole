<?xml version="1.0"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" 
               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<refentry id="SoupSession">
<refmeta>
<refentrytitle role="top_of_page">SoupSession</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>LIBSOUP-2.4 Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>SoupSession</refname>
<refpurpose>Soup session state object</refpurpose>
<!--[<xref linkend="desc" endterm="desc.title"/>]-->
</refnamediv>

<refsynopsisdiv role="synopsis">
<title role="synopsis.title">Synopsis</title>

<synopsis>



struct              <link linkend="SoupSession-struct">SoupSession</link>;

<link linkend="void">void</link>                (<link linkend="SoupSessionCallback">*SoupSessionCallback</link>)              (<link linkend="SoupSession">SoupSession</link> *session,
                                                         <link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="gpointer">gpointer</link> user_data);
<link linkend="void">void</link>                <link linkend="soup-session-queue-message">soup_session_queue_message</link>          (<link linkend="SoupSession">SoupSession</link> *session,
                                                         <link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="SoupSessionCallback">SoupSessionCallback</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data);
<link linkend="void">void</link>                <link linkend="soup-session-requeue-message">soup_session_requeue_message</link>        (<link linkend="SoupSession">SoupSession</link> *session,
                                                         <link linkend="SoupMessage">SoupMessage</link> *msg);
<link linkend="guint">guint</link>               <link linkend="soup-session-send-message">soup_session_send_message</link>           (<link linkend="SoupSession">SoupSession</link> *session,
                                                         <link linkend="SoupMessage">SoupMessage</link> *msg);
<link linkend="void">void</link>                <link linkend="soup-session-cancel-message">soup_session_cancel_message</link>         (<link linkend="SoupSession">SoupSession</link> *session,
                                                         <link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="guint">guint</link> status_code);
<link linkend="void">void</link>                <link linkend="soup-session-abort">soup_session_abort</link>                  (<link linkend="SoupSession">SoupSession</link> *session);

<link linkend="void">void</link>                <link linkend="soup-session-pause-message">soup_session_pause_message</link>          (<link linkend="SoupSession">SoupSession</link> *session,
                                                         <link linkend="SoupMessage">SoupMessage</link> *msg);
<link linkend="void">void</link>                <link linkend="soup-session-unpause-message">soup_session_unpause_message</link>        (<link linkend="SoupSession">SoupSession</link> *session,
                                                         <link linkend="SoupMessage">SoupMessage</link> *msg);

<link linkend="GMainContext">GMainContext</link>*       <link linkend="soup-session-get-async-context">soup_session_get_async_context</link>      (<link linkend="SoupSession">SoupSession</link> *session);

#define             <link linkend="SOUP-SESSION-PROXY-URI:CAPS">SOUP_SESSION_PROXY_URI</link>
#define             <link linkend="SOUP-SESSION-MAX-CONNS:CAPS">SOUP_SESSION_MAX_CONNS</link>
#define             <link linkend="SOUP-SESSION-MAX-CONNS-PER-HOST:CAPS">SOUP_SESSION_MAX_CONNS_PER_HOST</link>
#define             <link linkend="SOUP-SESSION-USE-NTLM:CAPS">SOUP_SESSION_USE_NTLM</link>
#define             <link linkend="SOUP-SESSION-SSL-CA-FILE:CAPS">SOUP_SESSION_SSL_CA_FILE</link>
#define             <link linkend="SOUP-SESSION-ASYNC-CONTEXT:CAPS">SOUP_SESSION_ASYNC_CONTEXT</link>
#define             <link linkend="SOUP-SESSION-TIMEOUT:CAPS">SOUP_SESSION_TIMEOUT</link>
#define             <link linkend="SOUP-SESSION-USER-AGENT:CAPS">SOUP_SESSION_USER_AGENT</link>

</synopsis>
</refsynopsisdiv>

<refsect1 role="object_hierarchy">
<title role="object_hierarchy.title">Object Hierarchy</title>
<synopsis>

  <link linkend="GObject">GObject</link>
   +----SoupSession
         +----<link linkend="SoupSessionSync">SoupSessionSync</link>
         +----<link linkend="SoupSessionAsync">SoupSessionAsync</link>
</synopsis>

</refsect1>





<refsect1 role="properties">
<title role="properties.title">Properties</title>
<synopsis>

  &quot;<link linkend="SoupSession--async-context">async-context</link>&quot;            <link linkend="gpointer">gpointer</link>              : Read / Write / Construct Only
  &quot;<link linkend="SoupSession--max-conns">max-conns</link>&quot;                <link linkend="gint">gint</link>                  : Read / Write
  &quot;<link linkend="SoupSession--max-conns-per-host">max-conns-per-host</link>&quot;       <link linkend="gint">gint</link>                  : Read / Write
  &quot;<link linkend="SoupSession--proxy-uri">proxy-uri</link>&quot;                <link linkend="SoupURI">SoupURI</link>               : Read / Write
  &quot;<link linkend="SoupSession--ssl-ca-file">ssl-ca-file</link>&quot;              <link linkend="gchararray">gchararray</link>            : Read / Write
  &quot;<link linkend="SoupSession--timeout">timeout</link>&quot;                  <link linkend="guint">guint</link>                 : Read / Write
  &quot;<link linkend="SoupSession--use-ntlm">use-ntlm</link>&quot;                 <link linkend="gboolean">gboolean</link>              : Read / Write
  &quot;<link linkend="SoupSession--user-agent">user-agent</link>&quot;               <link linkend="gchararray">gchararray</link>            : Read / Write
</synopsis>
</refsect1>

<refsect1 role="signal_proto">
<title role="signal_proto.title">Signals</title>
<synopsis>

  &quot;<link linkend="SoupSession-authenticate">authenticate</link>&quot;                                   : Run First
  &quot;<link linkend="SoupSession-request-started">request-started</link>&quot;                                : Run First
</synopsis>
</refsect1>


<refsect1 role="desc">
<title role="desc.title">Description</title>
<para>
<link linkend="SoupSession"><type>SoupSession</type></link> is the object that controls client-side HTTP. A
<link linkend="SoupSession"><type>SoupSession</type></link> encapsulates all of the state that libsoup is keeping
on behalf of your program; cached HTTP connections, authentication
information, etc.
</para>
<para>
Most applications will only need a single <link linkend="SoupSession"><type>SoupSession</type></link>; the primary
reason you might need multiple sessions is if you need to have
multiple independent authentication contexts. (Eg, you are
connecting to a server and authenticating as two different users at
different times; the easiest way to ensure that each <link linkend="SoupMessage"><type>SoupMessage</type></link>
is sent with the authentication information you intended is to use
one session for the first user, and a second session for the other
user.)
</para>
<para>
<link linkend="SoupSession"><type>SoupSession</type></link> itself is an abstract class, with two subclasses. If
you are using the glib main loop, you will generally want to use
<link linkend="SoupSessionAsync"><type>SoupSessionAsync</type></link>, which uses non-blocking I/O and callbacks. On
the other hand, if your application is threaded and you want to do
synchronous I/O in a separate thread from the UI, use
<link linkend="SoupSessionSync"><type>SoupSessionSync</type></link>.</para>
<para>

</para>
</refsect1>

<refsect1 role="details">
<title role="details.title">Details</title>
<refsect2>
<title><anchor id="SoupSession-struct" role="struct"/>struct SoupSession</title>
<indexterm><primary>SoupSession</primary></indexterm><programlisting>struct SoupSession;</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="SoupSessionCallback" role="function"/>SoupSessionCallback ()</title>
<indexterm><primary>SoupSessionCallback</primary></indexterm><programlisting><link linkend="void">void</link>                (*SoupSessionCallback)              (<link linkend="SoupSession">SoupSession</link> *session,
                                                         <link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="gpointer">gpointer</link> user_data);</programlisting>
<para>
Prototype for the callback passed to <link linkend="soup-session-queue-message"><function>soup_session_queue_message()</function></link>,
qv.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>session</parameter>&nbsp;:</term>
<listitem><simpara> the session
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> the message that has finished
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&nbsp;:</term>
<listitem><simpara> the data passed to soup_session_queue_message
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-session-queue-message" role="function"/>soup_session_queue_message ()</title>
<indexterm><primary>soup_session_queue_message</primary></indexterm><programlisting><link linkend="void">void</link>                soup_session_queue_message          (<link linkend="SoupSession">SoupSession</link> *session,
                                                         <link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="SoupSessionCallback">SoupSessionCallback</link> callback,
                                                         <link linkend="gpointer">gpointer</link> user_data);</programlisting>
<para>
Queues the message <parameter>msg</parameter> for sending. All messages are processed
while the glib main loop runs. If <parameter>msg</parameter> has been processed before,
any resources related to the time it was last sent are freed.
</para>
<para>
Upon message completion, the callback specified in <parameter>callback</parameter> will
be invoked (in the thread associated with <parameter>session</parameter>'s async
context). If after returning from this callback the message has not
been requeued, <parameter>msg</parameter> will be unreffed.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>session</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupSession"><type>SoupSession</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> the message to queue
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>callback</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupSessionCallback"><type>SoupSessionCallback</type></link> which will be called after the
message completes or when an unrecoverable error occurs.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&nbsp;:</term>
<listitem><simpara> a pointer passed to <parameter>callback</parameter>.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-session-requeue-message" role="function"/>soup_session_requeue_message ()</title>
<indexterm><primary>soup_session_requeue_message</primary></indexterm><programlisting><link linkend="void">void</link>                soup_session_requeue_message        (<link linkend="SoupSession">SoupSession</link> *session,
                                                         <link linkend="SoupMessage">SoupMessage</link> *msg);</programlisting>
<para>
This causes <parameter>msg</parameter> to be placed back on the queue to be attempted
again.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>session</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupSession"><type>SoupSession</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> the message to requeue
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-session-send-message" role="function"/>soup_session_send_message ()</title>
<indexterm><primary>soup_session_send_message</primary></indexterm><programlisting><link linkend="guint">guint</link>               soup_session_send_message           (<link linkend="SoupSession">SoupSession</link> *session,
                                                         <link linkend="SoupMessage">SoupMessage</link> *msg);</programlisting>
<para>
Synchronously send <parameter>msg</parameter>. This call will not return until the
transfer is finished successfully or there is an unrecoverable
error.
</para>
<para>
<parameter>msg</parameter> is not freed upon return.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>session</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupSession"><type>SoupSession</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> the message to send
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the HTTP status code of the response
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-session-cancel-message" role="function"/>soup_session_cancel_message ()</title>
<indexterm><primary>soup_session_cancel_message</primary></indexterm><programlisting><link linkend="void">void</link>                soup_session_cancel_message         (<link linkend="SoupSession">SoupSession</link> *session,
                                                         <link linkend="SoupMessage">SoupMessage</link> *msg,
                                                         <link linkend="guint">guint</link> status_code);</programlisting>
<para>
Causes <parameter>session</parameter> to immediately finish processing <parameter>msg</parameter>, with a final
status_code of <parameter>status_code</parameter>. Depending on when you cancel it, the
response state may be incomplete or inconsistent.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>session</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupSession"><type>SoupSession</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> the message to cancel
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>status_code</parameter>&nbsp;:</term>
<listitem><simpara> status code to set on <parameter>msg</parameter> (generally
<link linkend="SOUP-STATUS-CANCELLED:CAPS"><literal>SOUP_STATUS_CANCELLED</literal></link>)
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-session-abort" role="function"/>soup_session_abort ()</title>
<indexterm><primary>soup_session_abort</primary></indexterm><programlisting><link linkend="void">void</link>                soup_session_abort                  (<link linkend="SoupSession">SoupSession</link> *session);</programlisting>
<para>
Cancels all pending requests in <parameter>session</parameter>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>session</parameter>&nbsp;:</term>
<listitem><simpara> the session
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-session-pause-message" role="function"/>soup_session_pause_message ()</title>
<indexterm><primary>soup_session_pause_message</primary></indexterm><programlisting><link linkend="void">void</link>                soup_session_pause_message          (<link linkend="SoupSession">SoupSession</link> *session,
                                                         <link linkend="SoupMessage">SoupMessage</link> *msg);</programlisting>
<para>
Pauses HTTP I/O on <parameter>msg</parameter>. Call <link linkend="soup-session-unpause-message"><function>soup_session_unpause_message()</function></link> to
resume I/O.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>session</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupSession"><type>SoupSession</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link> currently running on <parameter>session</parameter>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-session-unpause-message" role="function"/>soup_session_unpause_message ()</title>
<indexterm><primary>soup_session_unpause_message</primary></indexterm><programlisting><link linkend="void">void</link>                soup_session_unpause_message        (<link linkend="SoupSession">SoupSession</link> *session,
                                                         <link linkend="SoupMessage">SoupMessage</link> *msg);</programlisting>
<para>
Resumes HTTP I/O on <parameter>msg</parameter>. Use this to resume after calling
<link linkend="soup-sessino-pause-message"><function>soup_sessino_pause_message()</function></link>.
</para>
<para>
If <parameter>msg</parameter> is being sent via blocking I/O, this will resume reading or
writing immediately. If <parameter>msg</parameter> is using non-blocking I/O, then
reading or writing won't resume until you return to the main loop.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>session</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupSession"><type>SoupSession</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupMessage"><type>SoupMessage</type></link> currently running on <parameter>session</parameter>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="soup-session-get-async-context" role="function"/>soup_session_get_async_context ()</title>
<indexterm><primary>soup_session_get_async_context</primary></indexterm><programlisting><link linkend="GMainContext">GMainContext</link>*       soup_session_get_async_context      (<link linkend="SoupSession">SoupSession</link> *session);</programlisting>
<para>
Gets <parameter>session</parameter>'s async_context. This does not add a ref to the
context, so you will need to ref it yourself if you want it to
outlive its session.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>session</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="SoupSession"><type>SoupSession</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> <parameter>session</parameter>'s <link linkend="GMainContext"><type>GMainContext</type></link>, which may be <link linkend="NULL:CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="SOUP-SESSION-PROXY-URI:CAPS" role="macro"/>SOUP_SESSION_PROXY_URI</title>
<indexterm><primary>SOUP_SESSION_PROXY_URI</primary></indexterm><programlisting>#define SOUP_SESSION_PROXY_URI          "proxy-uri"
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="SOUP-SESSION-MAX-CONNS:CAPS" role="macro"/>SOUP_SESSION_MAX_CONNS</title>
<indexterm><primary>SOUP_SESSION_MAX_CONNS</primary></indexterm><programlisting>#define SOUP_SESSION_MAX_CONNS          "max-conns"
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="SOUP-SESSION-MAX-CONNS-PER-HOST:CAPS" role="macro"/>SOUP_SESSION_MAX_CONNS_PER_HOST</title>
<indexterm><primary>SOUP_SESSION_MAX_CONNS_PER_HOST</primary></indexterm><programlisting>#define SOUP_SESSION_MAX_CONNS_PER_HOST "max-conns-per-host"
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="SOUP-SESSION-USE-NTLM:CAPS" role="macro"/>SOUP_SESSION_USE_NTLM</title>
<indexterm><primary>SOUP_SESSION_USE_NTLM</primary></indexterm><programlisting>#define SOUP_SESSION_USE_NTLM           "use-ntlm"
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="SOUP-SESSION-SSL-CA-FILE:CAPS" role="macro"/>SOUP_SESSION_SSL_CA_FILE</title>
<indexterm><primary>SOUP_SESSION_SSL_CA_FILE</primary></indexterm><programlisting>#define SOUP_SESSION_SSL_CA_FILE        "ssl-ca-file"
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="SOUP-SESSION-ASYNC-CONTEXT:CAPS" role="macro"/>SOUP_SESSION_ASYNC_CONTEXT</title>
<indexterm><primary>SOUP_SESSION_ASYNC_CONTEXT</primary></indexterm><programlisting>#define SOUP_SESSION_ASYNC_CONTEXT      "async-context"
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="SOUP-SESSION-TIMEOUT:CAPS" role="macro"/>SOUP_SESSION_TIMEOUT</title>
<indexterm><primary>SOUP_SESSION_TIMEOUT</primary></indexterm><programlisting>#define SOUP_SESSION_TIMEOUT		"timeout"
</programlisting>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="SOUP-SESSION-USER-AGENT:CAPS" role="macro"/>SOUP_SESSION_USER_AGENT</title>
<indexterm><primary>SOUP_SESSION_USER_AGENT</primary></indexterm><programlisting>#define SOUP_SESSION_USER_AGENT         "user-agent"
</programlisting>
<para>

</para></refsect2>

</refsect1>
<refsect1 role="property_details">
<title role="property_details.title">Property Details</title>
<refsect2><title><anchor id="SoupSession--async-context"/>The <literal>&quot;async-context&quot;</literal> property</title>
<indexterm><primary>SoupSession:async-context</primary></indexterm><programlisting>  &quot;async-context&quot;            <link linkend="gpointer">gpointer</link>              : Read / Write / Construct Only</programlisting>
<para>The GMainContext to dispatch async I/O in.</para></refsect2>
<refsect2><title><anchor id="SoupSession--max-conns"/>The <literal>&quot;max-conns&quot;</literal> property</title>
<indexterm><primary>SoupSession:max-conns</primary></indexterm><programlisting>  &quot;max-conns&quot;                <link linkend="gint">gint</link>                  : Read / Write</programlisting>
<para>The maximum number of connections that the session can open at once.</para><para>Allowed values: &gt;= 1</para>
<para>Default value: 10</para>
</refsect2>
<refsect2><title><anchor id="SoupSession--max-conns-per-host"/>The <literal>&quot;max-conns-per-host&quot;</literal> property</title>
<indexterm><primary>SoupSession:max-conns-per-host</primary></indexterm><programlisting>  &quot;max-conns-per-host&quot;       <link linkend="gint">gint</link>                  : Read / Write</programlisting>
<para>The maximum number of connections that the session can open at once to a given host.</para><para>Allowed values: &gt;= 1</para>
<para>Default value: 2</para>
</refsect2>
<refsect2><title><anchor id="SoupSession--proxy-uri"/>The <literal>&quot;proxy-uri&quot;</literal> property</title>
<indexterm><primary>SoupSession:proxy-uri</primary></indexterm><programlisting>  &quot;proxy-uri&quot;                <link linkend="SoupURI">SoupURI</link>               : Read / Write</programlisting>
<para>The HTTP Proxy to use for this session.</para></refsect2>
<refsect2><title><anchor id="SoupSession--ssl-ca-file"/>The <literal>&quot;ssl-ca-file&quot;</literal> property</title>
<indexterm><primary>SoupSession:ssl-ca-file</primary></indexterm><programlisting>  &quot;ssl-ca-file&quot;              <link linkend="gchararray">gchararray</link>            : Read / Write</programlisting>
<para>File containing SSL CA certificates.</para><para>Default value: NULL</para>
</refsect2>
<refsect2><title><anchor id="SoupSession--timeout"/>The <literal>&quot;timeout&quot;</literal> property</title>
<indexterm><primary>SoupSession:timeout</primary></indexterm><programlisting>  &quot;timeout&quot;                  <link linkend="guint">guint</link>                 : Read / Write</programlisting>
<para>Value in seconds to timeout a blocking I/O.</para><para>Default value: 0</para>
</refsect2>
<refsect2><title><anchor id="SoupSession--use-ntlm"/>The <literal>&quot;use-ntlm&quot;</literal> property</title>
<indexterm><primary>SoupSession:use-ntlm</primary></indexterm><programlisting>  &quot;use-ntlm&quot;                 <link linkend="gboolean">gboolean</link>              : Read / Write</programlisting>
<para>Whether or not to use NTLM authentication.</para><para>Default value: FALSE</para>
</refsect2>
<refsect2><title><anchor id="SoupSession--user-agent"/>The <literal>&quot;user-agent&quot;</literal> property</title>
<indexterm><primary>SoupSession:user-agent</primary></indexterm><programlisting>  &quot;user-agent&quot;               <link linkend="gchararray">gchararray</link>            : Read / Write</programlisting>
<para>
If non-<link linkend="NULL:CAPS"><literal>NULL</literal></link>, the value to use for the "User-Agent" header
on <link linkend="SoupMessage"><type>SoupMessage</type></link><!-- -->s sent from this session.
</para>
<para>
RFC 2616 says: "The User-Agent request-header field
contains information about the user agent originating the
request. This is for statistical purposes, the tracing of
protocol violations, and automated recognition of user
agents for the sake of tailoring responses to avoid
particular user agent limitations. User agents SHOULD
include this field with requests."
</para>
<para>
The User-Agent header contains a list of one or more
product tokens, separated by whitespace, with the most
significant product token coming first. The tokens must be
brief, ASCII, and mostly alphanumeric (although "-", "_",
and "." are also allowed), and may optionally include a "/"
followed by a version string. You may also put comments,
enclosed in parentheses, between or after the tokens.
</para>
<para>
If you set a <link linkend="user-agent"><literal>user_agent</literal></link> property that has trailing
whitespace, <link linkend="SoupSession"><type>SoupSession</type></link> will append its own product token
(eg, "<literal>libsoup/2.3.2</literal>") to the end of the
header for you.</para>
<para>

</para><para>Default value: NULL</para>
</refsect2>

</refsect1>

<refsect1 role="signals">
<title role="signals.title">Signal Details</title>
<refsect2><title><anchor id="SoupSession-authenticate"/>The <literal>&quot;authenticate&quot;</literal> signal</title>
<indexterm><primary>SoupSession::authenticate</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="SoupSession">SoupSession</link> *session,
                                                        <link linkend="SoupMessage">SoupMessage</link> *msg,
                                                        <link linkend="SoupAuth">SoupAuth</link>    *auth,
                                                        <link linkend="gboolean">gboolean</link>     retrying,
                                                        <link linkend="gpointer">gpointer</link>     user_data)      : Run First</programlisting>
<para>
Emitted when the session requires authentication. If
credentials are available call <link linkend="soup-auth-authenticate"><function>soup_auth_authenticate()</function></link> on
<parameter>auth</parameter>. If these credentials fail, the signal will be
emitted again, with <parameter>retrying</parameter> set to <link linkend="TRUE:CAPS"><literal>TRUE</literal></link>, which will
continue until you return without calling
<link linkend="soup-auth-authenticate"><function>soup_auth_authenticate()</function></link> on <parameter>auth</parameter>.
</para>
<para>
Note that this may be emitted before <parameter>msg</parameter>'s body has been
fully read.
</para>
<para>
If you call <link linkend="soup-session-pause-message"><function>soup_session_pause_message()</function></link> on <parameter>msg</parameter> before
returning, then you can authenticate <parameter>auth</parameter> asynchronously
(as long as you <link linkend="g-object-ref"><function>g_object_ref()</function></link> it to make sure it doesn't
get destroyed), and then unpause <parameter>msg</parameter> when you are ready
for it to continue.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>session</parameter>&nbsp;:</term>
<listitem><simpara> the session
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> the <link linkend="SoupMessage"><type>SoupMessage</type></link> being sent
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>auth</parameter>&nbsp;:</term>
<listitem><simpara> the <link linkend="SoupAuth"><type>SoupAuth</type></link> to authenticate
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>retrying</parameter>&nbsp;:</term>
<listitem><simpara> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> if this is the second (or later) attempt
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&nbsp;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist></refsect2><refsect2><title><anchor id="SoupSession-request-started"/>The <literal>&quot;request-started&quot;</literal> signal</title>
<indexterm><primary>SoupSession::request-started</primary></indexterm><programlisting><link linkend="void">void</link>                user_function                      (<link linkend="SoupSession">SoupSession</link> *session,
                                                        <link linkend="SoupMessage">SoupMessage</link> *msg,
                                                        <link linkend="SoupSocket">SoupSocket</link>  *socket,
                                                        <link linkend="gpointer">gpointer</link>     user_data)      : Run First</programlisting>
<para>
Emitted just before a request is sent.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>session</parameter>&nbsp;:</term>
<listitem><simpara> the session
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>msg</parameter>&nbsp;:</term>
<listitem><simpara> the request being sent
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>socket</parameter>&nbsp;:</term>
<listitem><simpara> the socket the request is being sent on
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>user_data</parameter>&nbsp;:</term>
<listitem><simpara>user data set when the signal handler was connected.</simpara></listitem></varlistentry>
</variablelist></refsect2>
</refsect1>




<refsect1><refsect2 /><refsect2 /></refsect1>
</refentry>

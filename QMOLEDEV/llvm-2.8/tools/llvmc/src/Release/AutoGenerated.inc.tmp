//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// llvmc-based driver: auto-generated code
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

#include "llvm/CompilerDriver/BuiltinOptions.h"
#include "llvm/CompilerDriver/CompilationGraph.h"
#include "llvm/CompilerDriver/Error.h"
#include "llvm/CompilerDriver/Tool.h"

#include "llvm/Support/CommandLine.h"
#include "llvm/Support/raw_ostream.h"

#include <algorithm>
#include <cstdlib>
#include <iterator>
#include <stdexcept>

using namespace llvm;
using namespace llvmc;

inline const char* checkCString(const char* s)
{ return s == NULL ? "" : s; }

namespace llvmc {
namespace autogenerated {

cl::opt<std::string> Parameter_compatibility_version("compatibility_version"
, cl::Hidden, cl::desc("Compatibility version number"));

cl::opt<std::string> Parameter_filelist("filelist"
, cl::Hidden, cl::desc("Link the files listed in file"));

cl::opt<bool> Switch_clang("clang"
, cl::desc("Use Clang instead of llvm-gcc"));

cl::opt<bool> Switch_pthread("pthread"
, cl::desc("Enable threads"));

cl::opt<std::string> Parameter_current_version("current_version"
, cl::Hidden, cl::desc("Current version number"));

cl::list<std::string> List_framework("framework"
, cl::desc("Specifies a framework to link against"));

cl::list<std::string> List_Wo_comma_("Wo,"
, cl::Prefix, cl::CommaSeparated, cl::desc("Pass options to opt"));

cl::opt<bool> Switch_opt("opt"
, cl::desc("Enable opt"));

cl::list<std::string> List_Wllc_comma_("Wllc,"
, cl::Prefix, cl::CommaSeparated, cl::desc("Pass options to llc"));

cl::opt<bool> Switch_fPIC("fPIC"
, cl::Hidden, cl::desc("Relocation model: PIC"));

cl::list<std::string> List_include("include"
, cl::desc("Include the named file prior to preprocessing"));

cl::opt<std::string> Parameter_linker("linker"
, cl::desc("Choose linker (possible values: gcc, g++)"));

cl::opt<bool> Switch_mfix_dash_and_dash_continue("mfix-and-continue"
, cl::Hidden, cl::desc("Needed by gdb to load .o files dynamically"));

cl::opt<bool> Switch_single_module("single_module"
, cl::Hidden, cl::desc("Build the library so it contains only one module"));

cl::opt<std::string> Parameter_mtune("mtune"
, cl::Hidden, cl::desc("Target a specific CPU type"));

cl::list<std::string> List_Wl_comma_("Wl,"
, cl::Prefix, cl::desc("Pass options to linker"));

cl::opt<std::string> Parameter_MF("MF"
, cl::Hidden, cl::desc("Specify a file to write dependencies to"));

cl::opt<std::string> Parameter_install_name("install_name"
, cl::Hidden, cl::desc("File name the library will be installed in"));

cl::list<std::string> List_Xpreprocessor("Xpreprocessor"
, cl::Hidden, cl::desc("Pass options to preprocessor"));

cl::list<std::string> List_MT("MT"
, cl::Hidden, cl::desc("Change the name of the rule emitted by dependency generation"));

cl::list<std::string> List_D("D"
, cl::Prefix, cl::desc("Define a macro"));

cl::opt<bool> Switch_E("E"
, cl::desc("Stop after the preprocessing stage, do not run the compiler"));

cl::opt<bool> Switch_mdynamic_dash_no_dash_pic("mdynamic-no-pic"
, cl::Hidden, cl::desc("Relocation model: dynamic-no-pic"));

cl::list<std::string> List_F("F"
, cl::Prefix, cl::desc("Add a directory to framework search path"));

cl::list<std::string> List_I("I"
, cl::Prefix, cl::desc("Add a directory to include path"));

cl::list<std::string> List_Wa_comma_("Wa,"
, cl::Prefix, cl::CommaSeparated, cl::desc("Pass options to assembler"));

cl::opt<std::string> Parameter_march("march"
, cl::Hidden, cl::desc("A synonym for -mtune"));

cl::list<std::string> List_L("L"
, cl::Prefix, cl::desc("Add a directory to link path"));

cl::opt<bool> Switch_S("S"
, cl::desc("Stop after compilation, do not assemble"));

cl::opt<std::string> Parameter_mcpu("mcpu"
, cl::Hidden, cl::desc("A deprecated synonym for -mtune"));

cl::opt<bool> Switch_m64("m64"
, cl::Hidden, cl::desc("Generate code for a 64-bit environment"));

cl::opt<bool> Switch_shared("shared"
, cl::desc("Create a DLL instead of the regular executable"));

cl::list<std::string> List_iquote("iquote"
, cl::Hidden, cl::desc("Search dir only for files requested with #inlcude \"file\""));

cl::opt<std::string> Parameter_arch("arch"
, cl::Hidden, cl::desc("Compile for the specified target architecture"));

cl::opt<bool> Switch_O0("O0"
, cl::ZeroOrMore, cl::desc("Turn off optimization"));

cl::opt<bool> Switch_O1("O1"
, cl::ZeroOrMore, cl::desc("Optimization level 1"));

cl::opt<bool> Switch_O2("O2"
, cl::ZeroOrMore, cl::desc("Optimization level 2"));

cl::opt<bool> Switch_O3("O3"
, cl::ZeroOrMore, cl::desc("Optimization level 3"));

cl::opt<bool> Switch_c("c"
, cl::desc("Compile and assemble, but do not link"));

cl::opt<bool> Switch_prebind("prebind"
, cl::Hidden, cl::desc("Prebind all undefined symbols"));

cl::list<std::string> List_l("l"
, cl::Prefix, cl::desc("Search a library when linking"));

cl::list<std::string> List_m("m"
, cl::Prefix, cl::Hidden, cl::desc("Enable or disable various extensions (-mmmx, -msse, etc.)"));

cl::opt<bool> Switch_m32("m32"
, cl::Hidden, cl::desc("Generate code for a 32-bit environment"));

cl::list<std::string> List_weak_framework("weak_framework"
, cl::Hidden, cl::desc("Specifies a framework to weakly link against"));

cl::list<std::string> List_Xassembler("Xassembler"
, cl::Hidden, cl::desc("Pass options to assembler"));

cl::opt<bool> Switch_emit_dash_llvm("emit-llvm"
, cl::desc("Emit LLVM .ll files instead of native object files"));

cl::opt<bool> Switch_dynamiclib("dynamiclib"
, cl::Hidden, cl::desc("Produce a dynamic library"));

cl::opt<bool> Switch_fsyntax_dash_only("fsyntax-only"
, cl::desc("Stop after checking the input for syntax errors"));

cl::list<std::string> List_Xlinker("Xlinker"
, cl::Hidden, cl::desc("Pass options to linker"));

cl::opt<bool> Switch_dead_strip("dead_strip"
, cl::Hidden, cl::desc("Remove unreachable blocks of code"));

cl::list<std::string> SinkOption(cl::Sink);

} // End namespace autogenerated.
} // End namespace llvmc.

namespace hooks {
    std::string ConvertToMAttr(const std::vector<std::string>& Arg);
} // End namespace hooks.

namespace {

using namespace llvmc::autogenerated;

class as : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "as";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "object-code";
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("as is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("o");

        cmd = "as";

        if (!autogenerated::List_Wa_comma_.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_Wa_comma_.begin(), 
                 E = autogenerated::List_Wa_comma_.end(); B != E; ++B)
            {
                unsigned pos = autogenerated::List_Wa_comma_.getPosition(B - autogenerated::List_Wa_comma_.begin());
                vec.push_back(std::make_pair(pos, *B));
            }
        }
        if (autogenerated::Switch_c) {
            stop_compilation = true;
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* as::InputLanguages_[] = {"assembler", 0};

class clang_c : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "clang_c";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("clang_c is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("bc");

        cmd = "clang";
        vec.push_back(std::make_pair(0, "-x"));
        vec.push_back(std::make_pair(0, "c"));

        if (autogenerated::Switch_E) {
            vec.push_back(std::make_pair(autogenerated::Switch_E.getPosition(), "-E"));
            stop_compilation = true;
            output_suffix = "i";
        }
        if ((autogenerated::Switch_E)
             && (OutputFilename.empty())) {
            no_out_file = true;
        }
        if (autogenerated::Switch_fsyntax_dash_only) {
            stop_compilation = true;
        }
        if (autogenerated::Switch_S && autogenerated::Switch_emit_dash_llvm) {
            vec.push_back(std::make_pair(65536, "-emit-llvm"));
            stop_compilation = true;
            output_suffix = "ll";
        }
        if (! (autogenerated::Switch_S && autogenerated::Switch_emit_dash_llvm)) {
            vec.push_back(std::make_pair(65536, "-emit-llvm-bc"));
        }
        if (autogenerated::Switch_c && autogenerated::Switch_emit_dash_llvm) {
            stop_compilation = true;
        }
        if (!autogenerated::List_include.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_include.begin(),
            E = autogenerated::List_include.end(); B != E;) {
                unsigned pos = autogenerated::List_include.getPosition(B - autogenerated::List_include.begin());
                vec.push_back(std::make_pair(pos, "-include"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_I.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_I.begin(),
            E = autogenerated::List_I.end(); B != E;) {
                unsigned pos = autogenerated::List_I.getPosition(B - autogenerated::List_I.begin());
                vec.push_back(std::make_pair(pos, "-I" + *B));
                ++B;
            }
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        if (!autogenerated::SinkOption.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::SinkOption.begin(), E = autogenerated::SinkOption.end(); B != E; ++B)
                vec.push_back(std::make_pair(autogenerated::SinkOption.getPosition(B - autogenerated::SinkOption.begin()), *B));
        }
        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* clang_c::InputLanguages_[] = {"c", 0};

class clang_cpp : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "clang_cpp";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("clang_cpp is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("bc");

        cmd = "clang";
        vec.push_back(std::make_pair(0, "-x"));
        vec.push_back(std::make_pair(0, "c++"));

        if (autogenerated::Switch_E) {
            vec.push_back(std::make_pair(autogenerated::Switch_E.getPosition(), "-E"));
            stop_compilation = true;
            output_suffix = "i";
        }
        if ((autogenerated::Switch_E)
             && (OutputFilename.empty())) {
            no_out_file = true;
        }
        if (autogenerated::Switch_fsyntax_dash_only) {
            stop_compilation = true;
        }
        if (autogenerated::Switch_S && autogenerated::Switch_emit_dash_llvm) {
            vec.push_back(std::make_pair(65536, "-emit-llvm"));
            stop_compilation = true;
            output_suffix = "ll";
        }
        if (! (autogenerated::Switch_S && autogenerated::Switch_emit_dash_llvm)) {
            vec.push_back(std::make_pair(65536, "-emit-llvm-bc"));
        }
        if (autogenerated::Switch_c && autogenerated::Switch_emit_dash_llvm) {
            stop_compilation = true;
        }
        if (!autogenerated::List_include.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_include.begin(),
            E = autogenerated::List_include.end(); B != E;) {
                unsigned pos = autogenerated::List_include.getPosition(B - autogenerated::List_include.begin());
                vec.push_back(std::make_pair(pos, "-include"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_I.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_I.begin(),
            E = autogenerated::List_I.end(); B != E;) {
                unsigned pos = autogenerated::List_I.getPosition(B - autogenerated::List_I.begin());
                vec.push_back(std::make_pair(pos, "-I" + *B));
                ++B;
            }
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        if (!autogenerated::SinkOption.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::SinkOption.begin(), E = autogenerated::SinkOption.end(); B != E; ++B)
                vec.push_back(std::make_pair(autogenerated::SinkOption.getPosition(B - autogenerated::SinkOption.begin()), *B));
        }
        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* clang_cpp::InputLanguages_[] = {"c++", 0};

class clang_objective_c : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "clang_objective_c";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("clang_objective_c is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("bc");

        cmd = "clang";
        vec.push_back(std::make_pair(0, "-x"));
        vec.push_back(std::make_pair(0, "objective-c"));

        if (autogenerated::Switch_E) {
            vec.push_back(std::make_pair(autogenerated::Switch_E.getPosition(), "-E"));
            stop_compilation = true;
            output_suffix = "mi";
        }
        if ((autogenerated::Switch_E)
             && (OutputFilename.empty())) {
            no_out_file = true;
        }
        if (autogenerated::Switch_fsyntax_dash_only) {
            stop_compilation = true;
        }
        if (autogenerated::Switch_S && autogenerated::Switch_emit_dash_llvm) {
            vec.push_back(std::make_pair(65536, "-emit-llvm"));
            stop_compilation = true;
            output_suffix = "ll";
        }
        if (! (autogenerated::Switch_S && autogenerated::Switch_emit_dash_llvm)) {
            vec.push_back(std::make_pair(65536, "-emit-llvm-bc"));
        }
        if (autogenerated::Switch_c && autogenerated::Switch_emit_dash_llvm) {
            stop_compilation = true;
        }
        if (!autogenerated::List_include.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_include.begin(),
            E = autogenerated::List_include.end(); B != E;) {
                unsigned pos = autogenerated::List_include.getPosition(B - autogenerated::List_include.begin());
                vec.push_back(std::make_pair(pos, "-include"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_I.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_I.begin(),
            E = autogenerated::List_I.end(); B != E;) {
                unsigned pos = autogenerated::List_I.getPosition(B - autogenerated::List_I.begin());
                vec.push_back(std::make_pair(pos, "-I" + *B));
                ++B;
            }
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        if (!autogenerated::SinkOption.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::SinkOption.begin(), E = autogenerated::SinkOption.end(); B != E; ++B)
                vec.push_back(std::make_pair(autogenerated::SinkOption.getPosition(B - autogenerated::SinkOption.begin()), *B));
        }
        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* clang_objective_c::InputLanguages_[] = {"objective-c", 0};

class clang_objective_cpp : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "clang_objective_cpp";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("clang_objective_cpp is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("bc");

        cmd = "clang";
        vec.push_back(std::make_pair(0, "-x"));
        vec.push_back(std::make_pair(0, "objective-c++"));

        if (autogenerated::Switch_E) {
            vec.push_back(std::make_pair(autogenerated::Switch_E.getPosition(), "-E"));
            stop_compilation = true;
            output_suffix = "mi";
        }
        if ((autogenerated::Switch_E)
             && (OutputFilename.empty())) {
            no_out_file = true;
        }
        if (autogenerated::Switch_fsyntax_dash_only) {
            stop_compilation = true;
        }
        if (autogenerated::Switch_S && autogenerated::Switch_emit_dash_llvm) {
            vec.push_back(std::make_pair(65536, "-emit-llvm"));
            stop_compilation = true;
            output_suffix = "ll";
        }
        if (! (autogenerated::Switch_S && autogenerated::Switch_emit_dash_llvm)) {
            vec.push_back(std::make_pair(65536, "-emit-llvm-bc"));
        }
        if (autogenerated::Switch_c && autogenerated::Switch_emit_dash_llvm) {
            stop_compilation = true;
        }
        if (!autogenerated::List_include.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_include.begin(),
            E = autogenerated::List_include.end(); B != E;) {
                unsigned pos = autogenerated::List_include.getPosition(B - autogenerated::List_include.begin());
                vec.push_back(std::make_pair(pos, "-include"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_I.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_I.begin(),
            E = autogenerated::List_I.end(); B != E;) {
                unsigned pos = autogenerated::List_I.getPosition(B - autogenerated::List_I.begin());
                vec.push_back(std::make_pair(pos, "-I" + *B));
                ++B;
            }
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        if (!autogenerated::SinkOption.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::SinkOption.begin(), E = autogenerated::SinkOption.end(); B != E; ++B)
                vec.push_back(std::make_pair(autogenerated::SinkOption.getPosition(B - autogenerated::SinkOption.begin()), *B));
        }
        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* clang_objective_cpp::InputLanguages_[] = {"objective-c++", 0};

class llc : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llc";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "assembler";
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("llc is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("s");

        cmd = "llc";

        if (autogenerated::Switch_S) {
            stop_compilation = true;
        }
        if (autogenerated::Switch_O0) {
            vec.push_back(std::make_pair(autogenerated::Switch_O0.getPosition(), "-O0"));
        }
        if (autogenerated::Switch_O1) {
            vec.push_back(std::make_pair(autogenerated::Switch_O1.getPosition(), "-O1"));
        }
        if (autogenerated::Switch_O2) {
            vec.push_back(std::make_pair(autogenerated::Switch_O2.getPosition(), "-O2"));
        }
        if (autogenerated::Switch_O3) {
            vec.push_back(std::make_pair(autogenerated::Switch_O3.getPosition(), "-O3"));
        }
        if (autogenerated::Switch_fPIC) {
            vec.push_back(std::make_pair(65536, "-relocation-model=pic"));
        }
        if (autogenerated::Switch_mdynamic_dash_no_dash_pic) {
            vec.push_back(std::make_pair(65536, "-relocation-model=dynamic-no-pic"));
        }
        if (!autogenerated::Parameter_march.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_mtune.getPosition(), "-mcpu=" + autogenerated::Parameter_mtune));
        }
        if (!autogenerated::Parameter_mtune.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_mtune.getPosition(), "-mcpu=" + autogenerated::Parameter_mtune));
        }
        if (!autogenerated::Parameter_mcpu.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_mcpu.getPosition(), "-mcpu=" + autogenerated::Parameter_mcpu));
        }
        if (!autogenerated::List_m.empty()) {
            vec.push_back(std::make_pair(autogenerated::List_m.getPosition(0), hooks::ConvertToMAttr(autogenerated::List_m)));
        }
        if (!autogenerated::List_Wllc_comma_.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_Wllc_comma_.begin(), 
                 E = autogenerated::List_Wllc_comma_.end(); B != E; ++B)
            {
                unsigned pos = autogenerated::List_Wllc_comma_.getPosition(B - autogenerated::List_Wllc_comma_.begin());
                vec.push_back(std::make_pair(pos, *B));
            }
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* llc::InputLanguages_[] = {"llvm-assembler", "llvm-bitcode", 0};

class llvm_as : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_as";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("llvm_as is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("bc");

        cmd = "llvm-as";

        if (autogenerated::Switch_emit_dash_llvm) {
            stop_compilation = true;
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* llvm_as::InputLanguages_[] = {"llvm-assembler", 0};

class llvm_gcc_assembler : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_gcc_assembler";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "object-code";
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("llvm_gcc_assembler is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("o");

        cmd = "llvm-gcc";
        vec.push_back(std::make_pair(0, "-c"));
        vec.push_back(std::make_pair(0, "-x"));
        vec.push_back(std::make_pair(0, "assembler"));

        if (autogenerated::Switch_c) {
            stop_compilation = true;
        }
        if (!autogenerated::Parameter_arch.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_arch.getPosition(), "-arch"));
            vec.push_back(std::make_pair(autogenerated::Parameter_arch.getPosition(), autogenerated::Parameter_arch));
        }
        if (!autogenerated::List_Xassembler.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_Xassembler.begin(),
            E = autogenerated::List_Xassembler.end(); B != E;) {
                unsigned pos = autogenerated::List_Xassembler.getPosition(B - autogenerated::List_Xassembler.begin());
                vec.push_back(std::make_pair(pos, "-Xassembler"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (autogenerated::Switch_m32) {
            vec.push_back(std::make_pair(autogenerated::Switch_m32.getPosition(), "-m32"));
        }
        if (autogenerated::Switch_m64) {
            vec.push_back(std::make_pair(autogenerated::Switch_m64.getPosition(), "-m64"));
        }
        if (!autogenerated::List_Wa_comma_.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_Wa_comma_.begin(),
            E = autogenerated::List_Wa_comma_.end(); B != E;) {
                unsigned pos = autogenerated::List_Wa_comma_.getPosition(B - autogenerated::List_Wa_comma_.begin());
                vec.push_back(std::make_pair(pos, "-Wa," + *B));
                ++B;
            }
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* llvm_gcc_assembler::InputLanguages_[] = {"assembler", 0};

class llvm_gcc_c : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_gcc_c";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("llvm_gcc_c is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("bc");

        cmd = "llvm-gcc";
        vec.push_back(std::make_pair(0, "-x"));
        vec.push_back(std::make_pair(0, "c"));

        if ((!OutputFilename.empty())
             && (InputFilenames.size() > 1)
             && ((autogenerated::Switch_S)
             || (autogenerated::Switch_c))) {
            PrintError("cannot specify -o with -c or -S with multiple files");
            return 1;
        }
        if (autogenerated::Switch_E) {
            vec.push_back(std::make_pair(autogenerated::Switch_E.getPosition(), "-E"));
            stop_compilation = true;
            output_suffix = "i";
        }
        if ((autogenerated::Switch_E)
             && (OutputFilename.empty())) {
            no_out_file = true;
        }
        if (autogenerated::Switch_emit_dash_llvm && autogenerated::Switch_S) {
            output_suffix = "ll";
            stop_compilation = true;
        }
        if (autogenerated::Switch_emit_dash_llvm && autogenerated::Switch_c) {
            stop_compilation = true;
        }
        if (autogenerated::Switch_fsyntax_dash_only) {
            vec.push_back(std::make_pair(autogenerated::Switch_fsyntax_dash_only.getPosition(), "-fsyntax-only"));
            no_out_file = true;
            stop_compilation = true;
        }
        if (autogenerated::Switch_S && autogenerated::Switch_emit_dash_llvm) {
            vec.push_back(std::make_pair(autogenerated::Switch_S.getPosition(), "-S"));
            vec.push_back(std::make_pair(autogenerated::Switch_emit_dash_llvm.getPosition(), "-emit-llvm"));
        }
        if (! ((autogenerated::Switch_S && autogenerated::Switch_emit_dash_llvm)
             || (autogenerated::Switch_fsyntax_dash_only))) {
            vec.push_back(std::make_pair(65536, "-c"));
            vec.push_back(std::make_pair(65536, "-emit-llvm"));
        }
        if (!autogenerated::List_Xpreprocessor.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_Xpreprocessor.begin(),
            E = autogenerated::List_Xpreprocessor.end(); B != E;) {
                unsigned pos = autogenerated::List_Xpreprocessor.getPosition(B - autogenerated::List_Xpreprocessor.begin());
                vec.push_back(std::make_pair(pos, "-Xpreprocessor"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_include.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_include.begin(),
            E = autogenerated::List_include.end(); B != E;) {
                unsigned pos = autogenerated::List_include.getPosition(B - autogenerated::List_include.begin());
                vec.push_back(std::make_pair(pos, "-include"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_iquote.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_iquote.begin(),
            E = autogenerated::List_iquote.end(); B != E;) {
                unsigned pos = autogenerated::List_iquote.getPosition(B - autogenerated::List_iquote.begin());
                vec.push_back(std::make_pair(pos, "-iquote"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!(SaveTemps == SaveTempsEnum::Unset)) {
            vec.push_back(std::make_pair(65536, "-save-temps"));
        }
        if (!autogenerated::List_I.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_I.begin(),
            E = autogenerated::List_I.end(); B != E;) {
                unsigned pos = autogenerated::List_I.getPosition(B - autogenerated::List_I.begin());
                vec.push_back(std::make_pair(pos, "-I" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_F.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_F.begin(),
            E = autogenerated::List_F.end(); B != E;) {
                unsigned pos = autogenerated::List_F.getPosition(B - autogenerated::List_F.begin());
                vec.push_back(std::make_pair(pos, "-F" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_D.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_D.begin(),
            E = autogenerated::List_D.end(); B != E;) {
                unsigned pos = autogenerated::List_D.getPosition(B - autogenerated::List_D.begin());
                vec.push_back(std::make_pair(pos, "-D" + *B));
                ++B;
            }
        }
        if (!autogenerated::Parameter_arch.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_arch.getPosition(), "-arch"));
            vec.push_back(std::make_pair(autogenerated::Parameter_arch.getPosition(), autogenerated::Parameter_arch));
        }
        if (!autogenerated::Parameter_march.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_march.getPosition(), "-march=" + autogenerated::Parameter_march));
        }
        if (!autogenerated::Parameter_mtune.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_mtune.getPosition(), "-mtune=" + autogenerated::Parameter_mtune));
        }
        if (!autogenerated::Parameter_mcpu.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_mcpu.getPosition(), "-mcpu=" + autogenerated::Parameter_mcpu));
        }
        if (!autogenerated::List_m.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_m.begin(),
            E = autogenerated::List_m.end(); B != E;) {
                unsigned pos = autogenerated::List_m.getPosition(B - autogenerated::List_m.begin());
                vec.push_back(std::make_pair(pos, "-m" + *B));
                ++B;
            }
        }
        if (autogenerated::Switch_mfix_dash_and_dash_continue) {
            vec.push_back(std::make_pair(autogenerated::Switch_mfix_dash_and_dash_continue.getPosition(), "-mfix-and-continue"));
        }
        if (autogenerated::Switch_m32) {
            vec.push_back(std::make_pair(autogenerated::Switch_m32.getPosition(), "-m32"));
        }
        if (autogenerated::Switch_m64) {
            vec.push_back(std::make_pair(autogenerated::Switch_m64.getPosition(), "-m64"));
        }
        if (autogenerated::Switch_O0) {
            vec.push_back(std::make_pair(autogenerated::Switch_O0.getPosition(), "-O0"));
        }
        if (autogenerated::Switch_O1) {
            vec.push_back(std::make_pair(autogenerated::Switch_O1.getPosition(), "-O1"));
        }
        if (autogenerated::Switch_O2) {
            vec.push_back(std::make_pair(autogenerated::Switch_O2.getPosition(), "-O2"));
        }
        if (autogenerated::Switch_O3) {
            vec.push_back(std::make_pair(autogenerated::Switch_O3.getPosition(), "-O3"));
        }
        if (autogenerated::Switch_fPIC) {
            vec.push_back(std::make_pair(autogenerated::Switch_fPIC.getPosition(), "-fPIC"));
        }
        if (autogenerated::Switch_mdynamic_dash_no_dash_pic) {
            vec.push_back(std::make_pair(autogenerated::Switch_mdynamic_dash_no_dash_pic.getPosition(), "-mdynamic-no-pic"));
        }
        if (!autogenerated::Parameter_MF.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_MF.getPosition(), "-MF"));
            vec.push_back(std::make_pair(autogenerated::Parameter_MF.getPosition(), autogenerated::Parameter_MF));
        }
        if (!autogenerated::List_MT.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_MT.begin(),
            E = autogenerated::List_MT.end(); B != E;) {
                unsigned pos = autogenerated::List_MT.getPosition(B - autogenerated::List_MT.begin());
                vec.push_back(std::make_pair(pos, "-MT"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        if (!autogenerated::SinkOption.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::SinkOption.begin(), E = autogenerated::SinkOption.end(); B != E; ++B)
                vec.push_back(std::make_pair(autogenerated::SinkOption.getPosition(B - autogenerated::SinkOption.begin()), *B));
        }
        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* llvm_gcc_c::InputLanguages_[] = {"c", 0};

class llvm_gcc_c_pch : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_gcc_c_pch";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("llvm_gcc_c_pch is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("gch");

        cmd = "llvm-gcc";
        vec.push_back(std::make_pair(0, "-x"));
        vec.push_back(std::make_pair(0, "c-header"));

        if ((!OutputFilename.empty())
             && (InputFilenames.size() > 1)
             && ((autogenerated::Switch_S)
             || (autogenerated::Switch_c))) {
            PrintError("cannot specify -o with -c or -S with multiple files");
            return 1;
        }
        if (autogenerated::Switch_E) {
            vec.push_back(std::make_pair(autogenerated::Switch_E.getPosition(), "-E"));
            stop_compilation = true;
            output_suffix = "i";
        }
        if ((autogenerated::Switch_E)
             && (OutputFilename.empty())) {
            no_out_file = true;
        }
        if (autogenerated::Switch_emit_dash_llvm && autogenerated::Switch_S) {
            output_suffix = "ll";
            stop_compilation = true;
        }
        if (autogenerated::Switch_emit_dash_llvm && autogenerated::Switch_c) {
            stop_compilation = true;
        }
        if (autogenerated::Switch_fsyntax_dash_only) {
            vec.push_back(std::make_pair(autogenerated::Switch_fsyntax_dash_only.getPosition(), "-fsyntax-only"));
            no_out_file = true;
            stop_compilation = true;
        }
        if (autogenerated::Switch_S && autogenerated::Switch_emit_dash_llvm) {
            vec.push_back(std::make_pair(autogenerated::Switch_S.getPosition(), "-S"));
            vec.push_back(std::make_pair(autogenerated::Switch_emit_dash_llvm.getPosition(), "-emit-llvm"));
        }
        if (! ((autogenerated::Switch_S && autogenerated::Switch_emit_dash_llvm)
             || (autogenerated::Switch_fsyntax_dash_only))) {
            vec.push_back(std::make_pair(65536, "-c"));
            vec.push_back(std::make_pair(65536, "-emit-llvm"));
        }
        if (!autogenerated::List_Xpreprocessor.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_Xpreprocessor.begin(),
            E = autogenerated::List_Xpreprocessor.end(); B != E;) {
                unsigned pos = autogenerated::List_Xpreprocessor.getPosition(B - autogenerated::List_Xpreprocessor.begin());
                vec.push_back(std::make_pair(pos, "-Xpreprocessor"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_include.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_include.begin(),
            E = autogenerated::List_include.end(); B != E;) {
                unsigned pos = autogenerated::List_include.getPosition(B - autogenerated::List_include.begin());
                vec.push_back(std::make_pair(pos, "-include"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_iquote.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_iquote.begin(),
            E = autogenerated::List_iquote.end(); B != E;) {
                unsigned pos = autogenerated::List_iquote.getPosition(B - autogenerated::List_iquote.begin());
                vec.push_back(std::make_pair(pos, "-iquote"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!(SaveTemps == SaveTempsEnum::Unset)) {
            vec.push_back(std::make_pair(65536, "-save-temps"));
        }
        if (!autogenerated::List_I.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_I.begin(),
            E = autogenerated::List_I.end(); B != E;) {
                unsigned pos = autogenerated::List_I.getPosition(B - autogenerated::List_I.begin());
                vec.push_back(std::make_pair(pos, "-I" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_F.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_F.begin(),
            E = autogenerated::List_F.end(); B != E;) {
                unsigned pos = autogenerated::List_F.getPosition(B - autogenerated::List_F.begin());
                vec.push_back(std::make_pair(pos, "-F" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_D.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_D.begin(),
            E = autogenerated::List_D.end(); B != E;) {
                unsigned pos = autogenerated::List_D.getPosition(B - autogenerated::List_D.begin());
                vec.push_back(std::make_pair(pos, "-D" + *B));
                ++B;
            }
        }
        if (!autogenerated::Parameter_arch.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_arch.getPosition(), "-arch"));
            vec.push_back(std::make_pair(autogenerated::Parameter_arch.getPosition(), autogenerated::Parameter_arch));
        }
        if (!autogenerated::Parameter_march.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_march.getPosition(), "-march=" + autogenerated::Parameter_march));
        }
        if (!autogenerated::Parameter_mtune.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_mtune.getPosition(), "-mtune=" + autogenerated::Parameter_mtune));
        }
        if (!autogenerated::Parameter_mcpu.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_mcpu.getPosition(), "-mcpu=" + autogenerated::Parameter_mcpu));
        }
        if (!autogenerated::List_m.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_m.begin(),
            E = autogenerated::List_m.end(); B != E;) {
                unsigned pos = autogenerated::List_m.getPosition(B - autogenerated::List_m.begin());
                vec.push_back(std::make_pair(pos, "-m" + *B));
                ++B;
            }
        }
        if (autogenerated::Switch_mfix_dash_and_dash_continue) {
            vec.push_back(std::make_pair(autogenerated::Switch_mfix_dash_and_dash_continue.getPosition(), "-mfix-and-continue"));
        }
        if (autogenerated::Switch_m32) {
            vec.push_back(std::make_pair(autogenerated::Switch_m32.getPosition(), "-m32"));
        }
        if (autogenerated::Switch_m64) {
            vec.push_back(std::make_pair(autogenerated::Switch_m64.getPosition(), "-m64"));
        }
        if (autogenerated::Switch_O0) {
            vec.push_back(std::make_pair(autogenerated::Switch_O0.getPosition(), "-O0"));
        }
        if (autogenerated::Switch_O1) {
            vec.push_back(std::make_pair(autogenerated::Switch_O1.getPosition(), "-O1"));
        }
        if (autogenerated::Switch_O2) {
            vec.push_back(std::make_pair(autogenerated::Switch_O2.getPosition(), "-O2"));
        }
        if (autogenerated::Switch_O3) {
            vec.push_back(std::make_pair(autogenerated::Switch_O3.getPosition(), "-O3"));
        }
        if (autogenerated::Switch_fPIC) {
            vec.push_back(std::make_pair(autogenerated::Switch_fPIC.getPosition(), "-fPIC"));
        }
        if (autogenerated::Switch_mdynamic_dash_no_dash_pic) {
            vec.push_back(std::make_pair(autogenerated::Switch_mdynamic_dash_no_dash_pic.getPosition(), "-mdynamic-no-pic"));
        }
        if (!autogenerated::Parameter_MF.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_MF.getPosition(), "-MF"));
            vec.push_back(std::make_pair(autogenerated::Parameter_MF.getPosition(), autogenerated::Parameter_MF));
        }
        if (!autogenerated::List_MT.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_MT.begin(),
            E = autogenerated::List_MT.end(); B != E;) {
                unsigned pos = autogenerated::List_MT.getPosition(B - autogenerated::List_MT.begin());
                vec.push_back(std::make_pair(pos, "-MT"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        if (!autogenerated::SinkOption.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::SinkOption.begin(), E = autogenerated::SinkOption.end(); B != E; ++B)
                vec.push_back(std::make_pair(autogenerated::SinkOption.getPosition(B - autogenerated::SinkOption.begin()), *B));
        }
        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* llvm_gcc_c_pch::InputLanguages_[] = {"c-header", 0};

class llvm_gcc_cpp : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_gcc_cpp";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("llvm_gcc_cpp is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("bc");

        cmd = "llvm-g++";
        vec.push_back(std::make_pair(0, "-x"));
        vec.push_back(std::make_pair(0, "c++"));

        if ((!OutputFilename.empty())
             && (InputFilenames.size() > 1)
             && ((autogenerated::Switch_S)
             || (autogenerated::Switch_c))) {
            PrintError("cannot specify -o with -c or -S with multiple files");
            return 1;
        }
        if (autogenerated::Switch_E) {
            vec.push_back(std::make_pair(autogenerated::Switch_E.getPosition(), "-E"));
            stop_compilation = true;
            output_suffix = "i";
        }
        if ((autogenerated::Switch_E)
             && (OutputFilename.empty())) {
            no_out_file = true;
        }
        if (autogenerated::Switch_emit_dash_llvm && autogenerated::Switch_S) {
            output_suffix = "ll";
            stop_compilation = true;
        }
        if (autogenerated::Switch_emit_dash_llvm && autogenerated::Switch_c) {
            stop_compilation = true;
        }
        if (autogenerated::Switch_fsyntax_dash_only) {
            vec.push_back(std::make_pair(autogenerated::Switch_fsyntax_dash_only.getPosition(), "-fsyntax-only"));
            no_out_file = true;
            stop_compilation = true;
        }
        if (autogenerated::Switch_S && autogenerated::Switch_emit_dash_llvm) {
            vec.push_back(std::make_pair(autogenerated::Switch_S.getPosition(), "-S"));
            vec.push_back(std::make_pair(autogenerated::Switch_emit_dash_llvm.getPosition(), "-emit-llvm"));
        }
        if (! ((autogenerated::Switch_S && autogenerated::Switch_emit_dash_llvm)
             || (autogenerated::Switch_fsyntax_dash_only))) {
            vec.push_back(std::make_pair(65536, "-c"));
            vec.push_back(std::make_pair(65536, "-emit-llvm"));
        }
        if (!autogenerated::List_Xpreprocessor.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_Xpreprocessor.begin(),
            E = autogenerated::List_Xpreprocessor.end(); B != E;) {
                unsigned pos = autogenerated::List_Xpreprocessor.getPosition(B - autogenerated::List_Xpreprocessor.begin());
                vec.push_back(std::make_pair(pos, "-Xpreprocessor"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_include.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_include.begin(),
            E = autogenerated::List_include.end(); B != E;) {
                unsigned pos = autogenerated::List_include.getPosition(B - autogenerated::List_include.begin());
                vec.push_back(std::make_pair(pos, "-include"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_iquote.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_iquote.begin(),
            E = autogenerated::List_iquote.end(); B != E;) {
                unsigned pos = autogenerated::List_iquote.getPosition(B - autogenerated::List_iquote.begin());
                vec.push_back(std::make_pair(pos, "-iquote"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!(SaveTemps == SaveTempsEnum::Unset)) {
            vec.push_back(std::make_pair(65536, "-save-temps"));
        }
        if (!autogenerated::List_I.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_I.begin(),
            E = autogenerated::List_I.end(); B != E;) {
                unsigned pos = autogenerated::List_I.getPosition(B - autogenerated::List_I.begin());
                vec.push_back(std::make_pair(pos, "-I" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_F.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_F.begin(),
            E = autogenerated::List_F.end(); B != E;) {
                unsigned pos = autogenerated::List_F.getPosition(B - autogenerated::List_F.begin());
                vec.push_back(std::make_pair(pos, "-F" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_D.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_D.begin(),
            E = autogenerated::List_D.end(); B != E;) {
                unsigned pos = autogenerated::List_D.getPosition(B - autogenerated::List_D.begin());
                vec.push_back(std::make_pair(pos, "-D" + *B));
                ++B;
            }
        }
        if (!autogenerated::Parameter_arch.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_arch.getPosition(), "-arch"));
            vec.push_back(std::make_pair(autogenerated::Parameter_arch.getPosition(), autogenerated::Parameter_arch));
        }
        if (!autogenerated::Parameter_march.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_march.getPosition(), "-march=" + autogenerated::Parameter_march));
        }
        if (!autogenerated::Parameter_mtune.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_mtune.getPosition(), "-mtune=" + autogenerated::Parameter_mtune));
        }
        if (!autogenerated::Parameter_mcpu.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_mcpu.getPosition(), "-mcpu=" + autogenerated::Parameter_mcpu));
        }
        if (!autogenerated::List_m.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_m.begin(),
            E = autogenerated::List_m.end(); B != E;) {
                unsigned pos = autogenerated::List_m.getPosition(B - autogenerated::List_m.begin());
                vec.push_back(std::make_pair(pos, "-m" + *B));
                ++B;
            }
        }
        if (autogenerated::Switch_mfix_dash_and_dash_continue) {
            vec.push_back(std::make_pair(autogenerated::Switch_mfix_dash_and_dash_continue.getPosition(), "-mfix-and-continue"));
        }
        if (autogenerated::Switch_m32) {
            vec.push_back(std::make_pair(autogenerated::Switch_m32.getPosition(), "-m32"));
        }
        if (autogenerated::Switch_m64) {
            vec.push_back(std::make_pair(autogenerated::Switch_m64.getPosition(), "-m64"));
        }
        if (autogenerated::Switch_O0) {
            vec.push_back(std::make_pair(autogenerated::Switch_O0.getPosition(), "-O0"));
        }
        if (autogenerated::Switch_O1) {
            vec.push_back(std::make_pair(autogenerated::Switch_O1.getPosition(), "-O1"));
        }
        if (autogenerated::Switch_O2) {
            vec.push_back(std::make_pair(autogenerated::Switch_O2.getPosition(), "-O2"));
        }
        if (autogenerated::Switch_O3) {
            vec.push_back(std::make_pair(autogenerated::Switch_O3.getPosition(), "-O3"));
        }
        if (autogenerated::Switch_fPIC) {
            vec.push_back(std::make_pair(autogenerated::Switch_fPIC.getPosition(), "-fPIC"));
        }
        if (autogenerated::Switch_mdynamic_dash_no_dash_pic) {
            vec.push_back(std::make_pair(autogenerated::Switch_mdynamic_dash_no_dash_pic.getPosition(), "-mdynamic-no-pic"));
        }
        if (!autogenerated::Parameter_MF.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_MF.getPosition(), "-MF"));
            vec.push_back(std::make_pair(autogenerated::Parameter_MF.getPosition(), autogenerated::Parameter_MF));
        }
        if (!autogenerated::List_MT.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_MT.begin(),
            E = autogenerated::List_MT.end(); B != E;) {
                unsigned pos = autogenerated::List_MT.getPosition(B - autogenerated::List_MT.begin());
                vec.push_back(std::make_pair(pos, "-MT"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        if (!autogenerated::SinkOption.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::SinkOption.begin(), E = autogenerated::SinkOption.end(); B != E; ++B)
                vec.push_back(std::make_pair(autogenerated::SinkOption.getPosition(B - autogenerated::SinkOption.begin()), *B));
        }
        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* llvm_gcc_cpp::InputLanguages_[] = {"c++", 0};

class llvm_gcc_cpp_linker : public JoinTool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_gcc_cpp_linker";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "executable";
    }

    bool IsJoin() const {
        return true;
    }

    bool WorksOnEmpty() const {
        if ((!autogenerated::Parameter_filelist.empty())
             && ((autogenerated::Parameter_linker == "g++")
             || (autogenerated::Parameter_linker == "c++"))) {
            return true;
        }
        else {
            return false;
        }
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("out");

        cmd = "llvm-g++";

        if (autogenerated::Switch_pthread) {
            vec.push_back(std::make_pair(65536, "-lpthread"));
        }
        if (!autogenerated::List_L.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_L.begin(),
            E = autogenerated::List_L.end(); B != E;) {
                unsigned pos = autogenerated::List_L.getPosition(B - autogenerated::List_L.begin());
                vec.push_back(std::make_pair(pos, "-L" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_F.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_F.begin(),
            E = autogenerated::List_F.end(); B != E;) {
                unsigned pos = autogenerated::List_F.getPosition(B - autogenerated::List_F.begin());
                vec.push_back(std::make_pair(pos, "-F" + *B));
                ++B;
            }
        }
        if (!autogenerated::Parameter_arch.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_arch.getPosition(), "-arch"));
            vec.push_back(std::make_pair(autogenerated::Parameter_arch.getPosition(), autogenerated::Parameter_arch));
        }
        if (!autogenerated::List_framework.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_framework.begin(),
            E = autogenerated::List_framework.end(); B != E;) {
                unsigned pos = autogenerated::List_framework.getPosition(B - autogenerated::List_framework.begin());
                vec.push_back(std::make_pair(pos, "-framework"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_weak_framework.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_weak_framework.begin(),
            E = autogenerated::List_weak_framework.end(); B != E;) {
                unsigned pos = autogenerated::List_weak_framework.getPosition(B - autogenerated::List_weak_framework.begin());
                vec.push_back(std::make_pair(pos, "-weak_framework"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::Parameter_filelist.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_filelist.getPosition(), "-filelist"));
            vec.push_back(std::make_pair(autogenerated::Parameter_filelist.getPosition(), autogenerated::Parameter_filelist));
        }
        if (autogenerated::Switch_m32) {
            vec.push_back(std::make_pair(autogenerated::Switch_m32.getPosition(), "-m32"));
        }
        if (autogenerated::Switch_m64) {
            vec.push_back(std::make_pair(autogenerated::Switch_m64.getPosition(), "-m64"));
        }
        if (!autogenerated::List_l.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_l.begin(),
            E = autogenerated::List_l.end(); B != E;) {
                unsigned pos = autogenerated::List_l.getPosition(B - autogenerated::List_l.begin());
                vec.push_back(std::make_pair(pos, "-l" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_Xlinker.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_Xlinker.begin(),
            E = autogenerated::List_Xlinker.end(); B != E;) {
                unsigned pos = autogenerated::List_Xlinker.getPosition(B - autogenerated::List_Xlinker.begin());
                vec.push_back(std::make_pair(pos, "-Xlinker"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_Wl_comma_.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_Wl_comma_.begin(),
            E = autogenerated::List_Wl_comma_.end(); B != E;) {
                unsigned pos = autogenerated::List_Wl_comma_.getPosition(B - autogenerated::List_Wl_comma_.begin());
                vec.push_back(std::make_pair(pos, "-Wl," + *B));
                ++B;
            }
        }
        if (autogenerated::Switch_shared) {
            vec.push_back(std::make_pair(autogenerated::Switch_shared.getPosition(), "-shared"));
        }
        if (autogenerated::Switch_dynamiclib) {
            vec.push_back(std::make_pair(autogenerated::Switch_dynamiclib.getPosition(), "-dynamiclib"));
        }
        if (autogenerated::Switch_prebind) {
            vec.push_back(std::make_pair(autogenerated::Switch_prebind.getPosition(), "-prebind"));
        }
        if (autogenerated::Switch_dead_strip) {
            vec.push_back(std::make_pair(autogenerated::Switch_dead_strip.getPosition(), "-dead_strip"));
        }
        if (autogenerated::Switch_single_module) {
            vec.push_back(std::make_pair(autogenerated::Switch_single_module.getPosition(), "-single_module"));
        }
        if (!autogenerated::Parameter_compatibility_version.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_compatibility_version.getPosition(), "-compatibility_version"));
            vec.push_back(std::make_pair(autogenerated::Parameter_compatibility_version.getPosition(), autogenerated::Parameter_compatibility_version));
        }
        if (!autogenerated::Parameter_current_version.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_current_version.getPosition(), "-current_version"));
            vec.push_back(std::make_pair(autogenerated::Parameter_current_version.getPosition(), autogenerated::Parameter_current_version));
        }
        if (!autogenerated::Parameter_install_name.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_install_name.getPosition(), "-install_name"));
            vec.push_back(std::make_pair(autogenerated::Parameter_install_name.getPosition(), autogenerated::Parameter_install_name));
        }

        for (PathVector::const_iterator B = inFiles.begin(),
            E = inFiles.end(); B != E; ++B)
        {
            vec.push_back(std::make_pair(InputFilenames.getPosition(B - inFiles.begin()), B->str()));
        }
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(sys::Path(),
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("out");

        cmd = "llvm-g++";

        if (autogenerated::Switch_pthread) {
            vec.push_back(std::make_pair(65536, "-lpthread"));
        }
        if (!autogenerated::List_L.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_L.begin(),
            E = autogenerated::List_L.end(); B != E;) {
                unsigned pos = autogenerated::List_L.getPosition(B - autogenerated::List_L.begin());
                vec.push_back(std::make_pair(pos, "-L" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_F.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_F.begin(),
            E = autogenerated::List_F.end(); B != E;) {
                unsigned pos = autogenerated::List_F.getPosition(B - autogenerated::List_F.begin());
                vec.push_back(std::make_pair(pos, "-F" + *B));
                ++B;
            }
        }
        if (!autogenerated::Parameter_arch.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_arch.getPosition(), "-arch"));
            vec.push_back(std::make_pair(autogenerated::Parameter_arch.getPosition(), autogenerated::Parameter_arch));
        }
        if (!autogenerated::List_framework.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_framework.begin(),
            E = autogenerated::List_framework.end(); B != E;) {
                unsigned pos = autogenerated::List_framework.getPosition(B - autogenerated::List_framework.begin());
                vec.push_back(std::make_pair(pos, "-framework"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_weak_framework.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_weak_framework.begin(),
            E = autogenerated::List_weak_framework.end(); B != E;) {
                unsigned pos = autogenerated::List_weak_framework.getPosition(B - autogenerated::List_weak_framework.begin());
                vec.push_back(std::make_pair(pos, "-weak_framework"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::Parameter_filelist.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_filelist.getPosition(), "-filelist"));
            vec.push_back(std::make_pair(autogenerated::Parameter_filelist.getPosition(), autogenerated::Parameter_filelist));
        }
        if (autogenerated::Switch_m32) {
            vec.push_back(std::make_pair(autogenerated::Switch_m32.getPosition(), "-m32"));
        }
        if (autogenerated::Switch_m64) {
            vec.push_back(std::make_pair(autogenerated::Switch_m64.getPosition(), "-m64"));
        }
        if (!autogenerated::List_l.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_l.begin(),
            E = autogenerated::List_l.end(); B != E;) {
                unsigned pos = autogenerated::List_l.getPosition(B - autogenerated::List_l.begin());
                vec.push_back(std::make_pair(pos, "-l" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_Xlinker.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_Xlinker.begin(),
            E = autogenerated::List_Xlinker.end(); B != E;) {
                unsigned pos = autogenerated::List_Xlinker.getPosition(B - autogenerated::List_Xlinker.begin());
                vec.push_back(std::make_pair(pos, "-Xlinker"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_Wl_comma_.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_Wl_comma_.begin(),
            E = autogenerated::List_Wl_comma_.end(); B != E;) {
                unsigned pos = autogenerated::List_Wl_comma_.getPosition(B - autogenerated::List_Wl_comma_.begin());
                vec.push_back(std::make_pair(pos, "-Wl," + *B));
                ++B;
            }
        }
        if (autogenerated::Switch_shared) {
            vec.push_back(std::make_pair(autogenerated::Switch_shared.getPosition(), "-shared"));
        }
        if (autogenerated::Switch_dynamiclib) {
            vec.push_back(std::make_pair(autogenerated::Switch_dynamiclib.getPosition(), "-dynamiclib"));
        }
        if (autogenerated::Switch_prebind) {
            vec.push_back(std::make_pair(autogenerated::Switch_prebind.getPosition(), "-prebind"));
        }
        if (autogenerated::Switch_dead_strip) {
            vec.push_back(std::make_pair(autogenerated::Switch_dead_strip.getPosition(), "-dead_strip"));
        }
        if (autogenerated::Switch_single_module) {
            vec.push_back(std::make_pair(autogenerated::Switch_single_module.getPosition(), "-single_module"));
        }
        if (!autogenerated::Parameter_compatibility_version.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_compatibility_version.getPosition(), "-compatibility_version"));
            vec.push_back(std::make_pair(autogenerated::Parameter_compatibility_version.getPosition(), autogenerated::Parameter_compatibility_version));
        }
        if (!autogenerated::Parameter_current_version.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_current_version.getPosition(), "-current_version"));
            vec.push_back(std::make_pair(autogenerated::Parameter_current_version.getPosition(), autogenerated::Parameter_current_version));
        }
        if (!autogenerated::Parameter_install_name.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_install_name.getPosition(), "-install_name"));
            vec.push_back(std::make_pair(autogenerated::Parameter_install_name.getPosition(), autogenerated::Parameter_install_name));
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* llvm_gcc_cpp_linker::InputLanguages_[] = {"dynamic-library", "object-code", "static-library", 0};

class llvm_gcc_cpp_pch : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_gcc_cpp_pch";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("llvm_gcc_cpp_pch is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("gch");

        cmd = "llvm-g++";
        vec.push_back(std::make_pair(0, "-x"));
        vec.push_back(std::make_pair(0, "c++-header"));

        if ((!OutputFilename.empty())
             && (InputFilenames.size() > 1)
             && ((autogenerated::Switch_S)
             || (autogenerated::Switch_c))) {
            PrintError("cannot specify -o with -c or -S with multiple files");
            return 1;
        }
        if (autogenerated::Switch_E) {
            vec.push_back(std::make_pair(autogenerated::Switch_E.getPosition(), "-E"));
            stop_compilation = true;
            output_suffix = "i";
        }
        if ((autogenerated::Switch_E)
             && (OutputFilename.empty())) {
            no_out_file = true;
        }
        if (autogenerated::Switch_emit_dash_llvm && autogenerated::Switch_S) {
            output_suffix = "ll";
            stop_compilation = true;
        }
        if (autogenerated::Switch_emit_dash_llvm && autogenerated::Switch_c) {
            stop_compilation = true;
        }
        if (autogenerated::Switch_fsyntax_dash_only) {
            vec.push_back(std::make_pair(autogenerated::Switch_fsyntax_dash_only.getPosition(), "-fsyntax-only"));
            no_out_file = true;
            stop_compilation = true;
        }
        if (autogenerated::Switch_S && autogenerated::Switch_emit_dash_llvm) {
            vec.push_back(std::make_pair(autogenerated::Switch_S.getPosition(), "-S"));
            vec.push_back(std::make_pair(autogenerated::Switch_emit_dash_llvm.getPosition(), "-emit-llvm"));
        }
        if (! ((autogenerated::Switch_S && autogenerated::Switch_emit_dash_llvm)
             || (autogenerated::Switch_fsyntax_dash_only))) {
            vec.push_back(std::make_pair(65536, "-c"));
            vec.push_back(std::make_pair(65536, "-emit-llvm"));
        }
        if (!autogenerated::List_Xpreprocessor.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_Xpreprocessor.begin(),
            E = autogenerated::List_Xpreprocessor.end(); B != E;) {
                unsigned pos = autogenerated::List_Xpreprocessor.getPosition(B - autogenerated::List_Xpreprocessor.begin());
                vec.push_back(std::make_pair(pos, "-Xpreprocessor"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_include.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_include.begin(),
            E = autogenerated::List_include.end(); B != E;) {
                unsigned pos = autogenerated::List_include.getPosition(B - autogenerated::List_include.begin());
                vec.push_back(std::make_pair(pos, "-include"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_iquote.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_iquote.begin(),
            E = autogenerated::List_iquote.end(); B != E;) {
                unsigned pos = autogenerated::List_iquote.getPosition(B - autogenerated::List_iquote.begin());
                vec.push_back(std::make_pair(pos, "-iquote"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!(SaveTemps == SaveTempsEnum::Unset)) {
            vec.push_back(std::make_pair(65536, "-save-temps"));
        }
        if (!autogenerated::List_I.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_I.begin(),
            E = autogenerated::List_I.end(); B != E;) {
                unsigned pos = autogenerated::List_I.getPosition(B - autogenerated::List_I.begin());
                vec.push_back(std::make_pair(pos, "-I" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_F.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_F.begin(),
            E = autogenerated::List_F.end(); B != E;) {
                unsigned pos = autogenerated::List_F.getPosition(B - autogenerated::List_F.begin());
                vec.push_back(std::make_pair(pos, "-F" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_D.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_D.begin(),
            E = autogenerated::List_D.end(); B != E;) {
                unsigned pos = autogenerated::List_D.getPosition(B - autogenerated::List_D.begin());
                vec.push_back(std::make_pair(pos, "-D" + *B));
                ++B;
            }
        }
        if (!autogenerated::Parameter_arch.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_arch.getPosition(), "-arch"));
            vec.push_back(std::make_pair(autogenerated::Parameter_arch.getPosition(), autogenerated::Parameter_arch));
        }
        if (!autogenerated::Parameter_march.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_march.getPosition(), "-march=" + autogenerated::Parameter_march));
        }
        if (!autogenerated::Parameter_mtune.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_mtune.getPosition(), "-mtune=" + autogenerated::Parameter_mtune));
        }
        if (!autogenerated::Parameter_mcpu.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_mcpu.getPosition(), "-mcpu=" + autogenerated::Parameter_mcpu));
        }
        if (!autogenerated::List_m.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_m.begin(),
            E = autogenerated::List_m.end(); B != E;) {
                unsigned pos = autogenerated::List_m.getPosition(B - autogenerated::List_m.begin());
                vec.push_back(std::make_pair(pos, "-m" + *B));
                ++B;
            }
        }
        if (autogenerated::Switch_mfix_dash_and_dash_continue) {
            vec.push_back(std::make_pair(autogenerated::Switch_mfix_dash_and_dash_continue.getPosition(), "-mfix-and-continue"));
        }
        if (autogenerated::Switch_m32) {
            vec.push_back(std::make_pair(autogenerated::Switch_m32.getPosition(), "-m32"));
        }
        if (autogenerated::Switch_m64) {
            vec.push_back(std::make_pair(autogenerated::Switch_m64.getPosition(), "-m64"));
        }
        if (autogenerated::Switch_O0) {
            vec.push_back(std::make_pair(autogenerated::Switch_O0.getPosition(), "-O0"));
        }
        if (autogenerated::Switch_O1) {
            vec.push_back(std::make_pair(autogenerated::Switch_O1.getPosition(), "-O1"));
        }
        if (autogenerated::Switch_O2) {
            vec.push_back(std::make_pair(autogenerated::Switch_O2.getPosition(), "-O2"));
        }
        if (autogenerated::Switch_O3) {
            vec.push_back(std::make_pair(autogenerated::Switch_O3.getPosition(), "-O3"));
        }
        if (autogenerated::Switch_fPIC) {
            vec.push_back(std::make_pair(autogenerated::Switch_fPIC.getPosition(), "-fPIC"));
        }
        if (autogenerated::Switch_mdynamic_dash_no_dash_pic) {
            vec.push_back(std::make_pair(autogenerated::Switch_mdynamic_dash_no_dash_pic.getPosition(), "-mdynamic-no-pic"));
        }
        if (!autogenerated::Parameter_MF.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_MF.getPosition(), "-MF"));
            vec.push_back(std::make_pair(autogenerated::Parameter_MF.getPosition(), autogenerated::Parameter_MF));
        }
        if (!autogenerated::List_MT.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_MT.begin(),
            E = autogenerated::List_MT.end(); B != E;) {
                unsigned pos = autogenerated::List_MT.getPosition(B - autogenerated::List_MT.begin());
                vec.push_back(std::make_pair(pos, "-MT"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        if (!autogenerated::SinkOption.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::SinkOption.begin(), E = autogenerated::SinkOption.end(); B != E; ++B)
                vec.push_back(std::make_pair(autogenerated::SinkOption.getPosition(B - autogenerated::SinkOption.begin()), *B));
        }
        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* llvm_gcc_cpp_pch::InputLanguages_[] = {"c++-header", 0};

class llvm_gcc_linker : public JoinTool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_gcc_linker";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "executable";
    }

    bool IsJoin() const {
        return true;
    }

    bool WorksOnEmpty() const {
        if ((!autogenerated::Parameter_filelist.empty())
             && (! ((autogenerated::Parameter_linker == "g++")
             || (autogenerated::Parameter_linker == "c++")))) {
            return true;
        }
        else {
            return false;
        }
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("out");

        cmd = "llvm-gcc";

        if (autogenerated::Switch_pthread) {
            vec.push_back(std::make_pair(65536, "-lpthread"));
        }
        if (!autogenerated::List_L.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_L.begin(),
            E = autogenerated::List_L.end(); B != E;) {
                unsigned pos = autogenerated::List_L.getPosition(B - autogenerated::List_L.begin());
                vec.push_back(std::make_pair(pos, "-L" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_F.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_F.begin(),
            E = autogenerated::List_F.end(); B != E;) {
                unsigned pos = autogenerated::List_F.getPosition(B - autogenerated::List_F.begin());
                vec.push_back(std::make_pair(pos, "-F" + *B));
                ++B;
            }
        }
        if (!autogenerated::Parameter_arch.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_arch.getPosition(), "-arch"));
            vec.push_back(std::make_pair(autogenerated::Parameter_arch.getPosition(), autogenerated::Parameter_arch));
        }
        if (!autogenerated::List_framework.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_framework.begin(),
            E = autogenerated::List_framework.end(); B != E;) {
                unsigned pos = autogenerated::List_framework.getPosition(B - autogenerated::List_framework.begin());
                vec.push_back(std::make_pair(pos, "-framework"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_weak_framework.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_weak_framework.begin(),
            E = autogenerated::List_weak_framework.end(); B != E;) {
                unsigned pos = autogenerated::List_weak_framework.getPosition(B - autogenerated::List_weak_framework.begin());
                vec.push_back(std::make_pair(pos, "-weak_framework"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::Parameter_filelist.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_filelist.getPosition(), "-filelist"));
            vec.push_back(std::make_pair(autogenerated::Parameter_filelist.getPosition(), autogenerated::Parameter_filelist));
        }
        if (autogenerated::Switch_m32) {
            vec.push_back(std::make_pair(autogenerated::Switch_m32.getPosition(), "-m32"));
        }
        if (autogenerated::Switch_m64) {
            vec.push_back(std::make_pair(autogenerated::Switch_m64.getPosition(), "-m64"));
        }
        if (!autogenerated::List_l.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_l.begin(),
            E = autogenerated::List_l.end(); B != E;) {
                unsigned pos = autogenerated::List_l.getPosition(B - autogenerated::List_l.begin());
                vec.push_back(std::make_pair(pos, "-l" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_Xlinker.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_Xlinker.begin(),
            E = autogenerated::List_Xlinker.end(); B != E;) {
                unsigned pos = autogenerated::List_Xlinker.getPosition(B - autogenerated::List_Xlinker.begin());
                vec.push_back(std::make_pair(pos, "-Xlinker"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_Wl_comma_.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_Wl_comma_.begin(),
            E = autogenerated::List_Wl_comma_.end(); B != E;) {
                unsigned pos = autogenerated::List_Wl_comma_.getPosition(B - autogenerated::List_Wl_comma_.begin());
                vec.push_back(std::make_pair(pos, "-Wl," + *B));
                ++B;
            }
        }
        if (autogenerated::Switch_shared) {
            vec.push_back(std::make_pair(autogenerated::Switch_shared.getPosition(), "-shared"));
        }
        if (autogenerated::Switch_dynamiclib) {
            vec.push_back(std::make_pair(autogenerated::Switch_dynamiclib.getPosition(), "-dynamiclib"));
        }
        if (autogenerated::Switch_prebind) {
            vec.push_back(std::make_pair(autogenerated::Switch_prebind.getPosition(), "-prebind"));
        }
        if (autogenerated::Switch_dead_strip) {
            vec.push_back(std::make_pair(autogenerated::Switch_dead_strip.getPosition(), "-dead_strip"));
        }
        if (autogenerated::Switch_single_module) {
            vec.push_back(std::make_pair(autogenerated::Switch_single_module.getPosition(), "-single_module"));
        }
        if (!autogenerated::Parameter_compatibility_version.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_compatibility_version.getPosition(), "-compatibility_version"));
            vec.push_back(std::make_pair(autogenerated::Parameter_compatibility_version.getPosition(), autogenerated::Parameter_compatibility_version));
        }
        if (!autogenerated::Parameter_current_version.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_current_version.getPosition(), "-current_version"));
            vec.push_back(std::make_pair(autogenerated::Parameter_current_version.getPosition(), autogenerated::Parameter_current_version));
        }
        if (!autogenerated::Parameter_install_name.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_install_name.getPosition(), "-install_name"));
            vec.push_back(std::make_pair(autogenerated::Parameter_install_name.getPosition(), autogenerated::Parameter_install_name));
        }

        for (PathVector::const_iterator B = inFiles.begin(),
            E = inFiles.end(); B != E; ++B)
        {
            vec.push_back(std::make_pair(InputFilenames.getPosition(B - inFiles.begin()), B->str()));
        }
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(sys::Path(),
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("out");

        cmd = "llvm-gcc";

        if (autogenerated::Switch_pthread) {
            vec.push_back(std::make_pair(65536, "-lpthread"));
        }
        if (!autogenerated::List_L.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_L.begin(),
            E = autogenerated::List_L.end(); B != E;) {
                unsigned pos = autogenerated::List_L.getPosition(B - autogenerated::List_L.begin());
                vec.push_back(std::make_pair(pos, "-L" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_F.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_F.begin(),
            E = autogenerated::List_F.end(); B != E;) {
                unsigned pos = autogenerated::List_F.getPosition(B - autogenerated::List_F.begin());
                vec.push_back(std::make_pair(pos, "-F" + *B));
                ++B;
            }
        }
        if (!autogenerated::Parameter_arch.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_arch.getPosition(), "-arch"));
            vec.push_back(std::make_pair(autogenerated::Parameter_arch.getPosition(), autogenerated::Parameter_arch));
        }
        if (!autogenerated::List_framework.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_framework.begin(),
            E = autogenerated::List_framework.end(); B != E;) {
                unsigned pos = autogenerated::List_framework.getPosition(B - autogenerated::List_framework.begin());
                vec.push_back(std::make_pair(pos, "-framework"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_weak_framework.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_weak_framework.begin(),
            E = autogenerated::List_weak_framework.end(); B != E;) {
                unsigned pos = autogenerated::List_weak_framework.getPosition(B - autogenerated::List_weak_framework.begin());
                vec.push_back(std::make_pair(pos, "-weak_framework"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::Parameter_filelist.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_filelist.getPosition(), "-filelist"));
            vec.push_back(std::make_pair(autogenerated::Parameter_filelist.getPosition(), autogenerated::Parameter_filelist));
        }
        if (autogenerated::Switch_m32) {
            vec.push_back(std::make_pair(autogenerated::Switch_m32.getPosition(), "-m32"));
        }
        if (autogenerated::Switch_m64) {
            vec.push_back(std::make_pair(autogenerated::Switch_m64.getPosition(), "-m64"));
        }
        if (!autogenerated::List_l.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_l.begin(),
            E = autogenerated::List_l.end(); B != E;) {
                unsigned pos = autogenerated::List_l.getPosition(B - autogenerated::List_l.begin());
                vec.push_back(std::make_pair(pos, "-l" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_Xlinker.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_Xlinker.begin(),
            E = autogenerated::List_Xlinker.end(); B != E;) {
                unsigned pos = autogenerated::List_Xlinker.getPosition(B - autogenerated::List_Xlinker.begin());
                vec.push_back(std::make_pair(pos, "-Xlinker"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_Wl_comma_.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_Wl_comma_.begin(),
            E = autogenerated::List_Wl_comma_.end(); B != E;) {
                unsigned pos = autogenerated::List_Wl_comma_.getPosition(B - autogenerated::List_Wl_comma_.begin());
                vec.push_back(std::make_pair(pos, "-Wl," + *B));
                ++B;
            }
        }
        if (autogenerated::Switch_shared) {
            vec.push_back(std::make_pair(autogenerated::Switch_shared.getPosition(), "-shared"));
        }
        if (autogenerated::Switch_dynamiclib) {
            vec.push_back(std::make_pair(autogenerated::Switch_dynamiclib.getPosition(), "-dynamiclib"));
        }
        if (autogenerated::Switch_prebind) {
            vec.push_back(std::make_pair(autogenerated::Switch_prebind.getPosition(), "-prebind"));
        }
        if (autogenerated::Switch_dead_strip) {
            vec.push_back(std::make_pair(autogenerated::Switch_dead_strip.getPosition(), "-dead_strip"));
        }
        if (autogenerated::Switch_single_module) {
            vec.push_back(std::make_pair(autogenerated::Switch_single_module.getPosition(), "-single_module"));
        }
        if (!autogenerated::Parameter_compatibility_version.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_compatibility_version.getPosition(), "-compatibility_version"));
            vec.push_back(std::make_pair(autogenerated::Parameter_compatibility_version.getPosition(), autogenerated::Parameter_compatibility_version));
        }
        if (!autogenerated::Parameter_current_version.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_current_version.getPosition(), "-current_version"));
            vec.push_back(std::make_pair(autogenerated::Parameter_current_version.getPosition(), autogenerated::Parameter_current_version));
        }
        if (!autogenerated::Parameter_install_name.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_install_name.getPosition(), "-install_name"));
            vec.push_back(std::make_pair(autogenerated::Parameter_install_name.getPosition(), autogenerated::Parameter_install_name));
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* llvm_gcc_linker::InputLanguages_[] = {"dynamic-library", "object-code", "static-library", 0};

class llvm_gcc_m : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_gcc_m";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("llvm_gcc_m is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("bc");

        cmd = "llvm-gcc";
        vec.push_back(std::make_pair(0, "-x"));
        vec.push_back(std::make_pair(0, "objective-c"));

        if ((!OutputFilename.empty())
             && (InputFilenames.size() > 1)
             && ((autogenerated::Switch_S)
             || (autogenerated::Switch_c))) {
            PrintError("cannot specify -o with -c or -S with multiple files");
            return 1;
        }
        if (autogenerated::Switch_E) {
            vec.push_back(std::make_pair(autogenerated::Switch_E.getPosition(), "-E"));
            stop_compilation = true;
            output_suffix = "mi";
        }
        if ((autogenerated::Switch_E)
             && (OutputFilename.empty())) {
            no_out_file = true;
        }
        if (autogenerated::Switch_emit_dash_llvm && autogenerated::Switch_S) {
            output_suffix = "ll";
            stop_compilation = true;
        }
        if (autogenerated::Switch_emit_dash_llvm && autogenerated::Switch_c) {
            stop_compilation = true;
        }
        if (autogenerated::Switch_fsyntax_dash_only) {
            vec.push_back(std::make_pair(autogenerated::Switch_fsyntax_dash_only.getPosition(), "-fsyntax-only"));
            no_out_file = true;
            stop_compilation = true;
        }
        if (autogenerated::Switch_S && autogenerated::Switch_emit_dash_llvm) {
            vec.push_back(std::make_pair(autogenerated::Switch_S.getPosition(), "-S"));
            vec.push_back(std::make_pair(autogenerated::Switch_emit_dash_llvm.getPosition(), "-emit-llvm"));
        }
        if (! ((autogenerated::Switch_S && autogenerated::Switch_emit_dash_llvm)
             || (autogenerated::Switch_fsyntax_dash_only))) {
            vec.push_back(std::make_pair(65536, "-c"));
            vec.push_back(std::make_pair(65536, "-emit-llvm"));
        }
        if (!autogenerated::List_Xpreprocessor.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_Xpreprocessor.begin(),
            E = autogenerated::List_Xpreprocessor.end(); B != E;) {
                unsigned pos = autogenerated::List_Xpreprocessor.getPosition(B - autogenerated::List_Xpreprocessor.begin());
                vec.push_back(std::make_pair(pos, "-Xpreprocessor"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_include.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_include.begin(),
            E = autogenerated::List_include.end(); B != E;) {
                unsigned pos = autogenerated::List_include.getPosition(B - autogenerated::List_include.begin());
                vec.push_back(std::make_pair(pos, "-include"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_iquote.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_iquote.begin(),
            E = autogenerated::List_iquote.end(); B != E;) {
                unsigned pos = autogenerated::List_iquote.getPosition(B - autogenerated::List_iquote.begin());
                vec.push_back(std::make_pair(pos, "-iquote"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!(SaveTemps == SaveTempsEnum::Unset)) {
            vec.push_back(std::make_pair(65536, "-save-temps"));
        }
        if (!autogenerated::List_I.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_I.begin(),
            E = autogenerated::List_I.end(); B != E;) {
                unsigned pos = autogenerated::List_I.getPosition(B - autogenerated::List_I.begin());
                vec.push_back(std::make_pair(pos, "-I" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_F.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_F.begin(),
            E = autogenerated::List_F.end(); B != E;) {
                unsigned pos = autogenerated::List_F.getPosition(B - autogenerated::List_F.begin());
                vec.push_back(std::make_pair(pos, "-F" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_D.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_D.begin(),
            E = autogenerated::List_D.end(); B != E;) {
                unsigned pos = autogenerated::List_D.getPosition(B - autogenerated::List_D.begin());
                vec.push_back(std::make_pair(pos, "-D" + *B));
                ++B;
            }
        }
        if (!autogenerated::Parameter_arch.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_arch.getPosition(), "-arch"));
            vec.push_back(std::make_pair(autogenerated::Parameter_arch.getPosition(), autogenerated::Parameter_arch));
        }
        if (!autogenerated::Parameter_march.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_march.getPosition(), "-march=" + autogenerated::Parameter_march));
        }
        if (!autogenerated::Parameter_mtune.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_mtune.getPosition(), "-mtune=" + autogenerated::Parameter_mtune));
        }
        if (!autogenerated::Parameter_mcpu.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_mcpu.getPosition(), "-mcpu=" + autogenerated::Parameter_mcpu));
        }
        if (!autogenerated::List_m.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_m.begin(),
            E = autogenerated::List_m.end(); B != E;) {
                unsigned pos = autogenerated::List_m.getPosition(B - autogenerated::List_m.begin());
                vec.push_back(std::make_pair(pos, "-m" + *B));
                ++B;
            }
        }
        if (autogenerated::Switch_mfix_dash_and_dash_continue) {
            vec.push_back(std::make_pair(autogenerated::Switch_mfix_dash_and_dash_continue.getPosition(), "-mfix-and-continue"));
        }
        if (autogenerated::Switch_m32) {
            vec.push_back(std::make_pair(autogenerated::Switch_m32.getPosition(), "-m32"));
        }
        if (autogenerated::Switch_m64) {
            vec.push_back(std::make_pair(autogenerated::Switch_m64.getPosition(), "-m64"));
        }
        if (autogenerated::Switch_O0) {
            vec.push_back(std::make_pair(autogenerated::Switch_O0.getPosition(), "-O0"));
        }
        if (autogenerated::Switch_O1) {
            vec.push_back(std::make_pair(autogenerated::Switch_O1.getPosition(), "-O1"));
        }
        if (autogenerated::Switch_O2) {
            vec.push_back(std::make_pair(autogenerated::Switch_O2.getPosition(), "-O2"));
        }
        if (autogenerated::Switch_O3) {
            vec.push_back(std::make_pair(autogenerated::Switch_O3.getPosition(), "-O3"));
        }
        if (autogenerated::Switch_fPIC) {
            vec.push_back(std::make_pair(autogenerated::Switch_fPIC.getPosition(), "-fPIC"));
        }
        if (autogenerated::Switch_mdynamic_dash_no_dash_pic) {
            vec.push_back(std::make_pair(autogenerated::Switch_mdynamic_dash_no_dash_pic.getPosition(), "-mdynamic-no-pic"));
        }
        if (!autogenerated::Parameter_MF.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_MF.getPosition(), "-MF"));
            vec.push_back(std::make_pair(autogenerated::Parameter_MF.getPosition(), autogenerated::Parameter_MF));
        }
        if (!autogenerated::List_MT.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_MT.begin(),
            E = autogenerated::List_MT.end(); B != E;) {
                unsigned pos = autogenerated::List_MT.getPosition(B - autogenerated::List_MT.begin());
                vec.push_back(std::make_pair(pos, "-MT"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        if (!autogenerated::SinkOption.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::SinkOption.begin(), E = autogenerated::SinkOption.end(); B != E; ++B)
                vec.push_back(std::make_pair(autogenerated::SinkOption.getPosition(B - autogenerated::SinkOption.begin()), *B));
        }
        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* llvm_gcc_m::InputLanguages_[] = {"objective-c", 0};

class llvm_gcc_m_pch : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_gcc_m_pch";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("llvm_gcc_m_pch is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("gch");

        cmd = "llvm-gcc";
        vec.push_back(std::make_pair(0, "-x"));
        vec.push_back(std::make_pair(0, "objective-c-header"));

        if ((!OutputFilename.empty())
             && (InputFilenames.size() > 1)
             && ((autogenerated::Switch_S)
             || (autogenerated::Switch_c))) {
            PrintError("cannot specify -o with -c or -S with multiple files");
            return 1;
        }
        if (autogenerated::Switch_E) {
            vec.push_back(std::make_pair(autogenerated::Switch_E.getPosition(), "-E"));
            stop_compilation = true;
            output_suffix = "mi";
        }
        if ((autogenerated::Switch_E)
             && (OutputFilename.empty())) {
            no_out_file = true;
        }
        if (autogenerated::Switch_emit_dash_llvm && autogenerated::Switch_S) {
            output_suffix = "ll";
            stop_compilation = true;
        }
        if (autogenerated::Switch_emit_dash_llvm && autogenerated::Switch_c) {
            stop_compilation = true;
        }
        if (autogenerated::Switch_fsyntax_dash_only) {
            vec.push_back(std::make_pair(autogenerated::Switch_fsyntax_dash_only.getPosition(), "-fsyntax-only"));
            no_out_file = true;
            stop_compilation = true;
        }
        if (autogenerated::Switch_S && autogenerated::Switch_emit_dash_llvm) {
            vec.push_back(std::make_pair(autogenerated::Switch_S.getPosition(), "-S"));
            vec.push_back(std::make_pair(autogenerated::Switch_emit_dash_llvm.getPosition(), "-emit-llvm"));
        }
        if (! ((autogenerated::Switch_S && autogenerated::Switch_emit_dash_llvm)
             || (autogenerated::Switch_fsyntax_dash_only))) {
            vec.push_back(std::make_pair(65536, "-c"));
            vec.push_back(std::make_pair(65536, "-emit-llvm"));
        }
        if (!autogenerated::List_Xpreprocessor.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_Xpreprocessor.begin(),
            E = autogenerated::List_Xpreprocessor.end(); B != E;) {
                unsigned pos = autogenerated::List_Xpreprocessor.getPosition(B - autogenerated::List_Xpreprocessor.begin());
                vec.push_back(std::make_pair(pos, "-Xpreprocessor"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_include.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_include.begin(),
            E = autogenerated::List_include.end(); B != E;) {
                unsigned pos = autogenerated::List_include.getPosition(B - autogenerated::List_include.begin());
                vec.push_back(std::make_pair(pos, "-include"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_iquote.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_iquote.begin(),
            E = autogenerated::List_iquote.end(); B != E;) {
                unsigned pos = autogenerated::List_iquote.getPosition(B - autogenerated::List_iquote.begin());
                vec.push_back(std::make_pair(pos, "-iquote"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!(SaveTemps == SaveTempsEnum::Unset)) {
            vec.push_back(std::make_pair(65536, "-save-temps"));
        }
        if (!autogenerated::List_I.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_I.begin(),
            E = autogenerated::List_I.end(); B != E;) {
                unsigned pos = autogenerated::List_I.getPosition(B - autogenerated::List_I.begin());
                vec.push_back(std::make_pair(pos, "-I" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_F.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_F.begin(),
            E = autogenerated::List_F.end(); B != E;) {
                unsigned pos = autogenerated::List_F.getPosition(B - autogenerated::List_F.begin());
                vec.push_back(std::make_pair(pos, "-F" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_D.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_D.begin(),
            E = autogenerated::List_D.end(); B != E;) {
                unsigned pos = autogenerated::List_D.getPosition(B - autogenerated::List_D.begin());
                vec.push_back(std::make_pair(pos, "-D" + *B));
                ++B;
            }
        }
        if (!autogenerated::Parameter_arch.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_arch.getPosition(), "-arch"));
            vec.push_back(std::make_pair(autogenerated::Parameter_arch.getPosition(), autogenerated::Parameter_arch));
        }
        if (!autogenerated::Parameter_march.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_march.getPosition(), "-march=" + autogenerated::Parameter_march));
        }
        if (!autogenerated::Parameter_mtune.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_mtune.getPosition(), "-mtune=" + autogenerated::Parameter_mtune));
        }
        if (!autogenerated::Parameter_mcpu.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_mcpu.getPosition(), "-mcpu=" + autogenerated::Parameter_mcpu));
        }
        if (!autogenerated::List_m.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_m.begin(),
            E = autogenerated::List_m.end(); B != E;) {
                unsigned pos = autogenerated::List_m.getPosition(B - autogenerated::List_m.begin());
                vec.push_back(std::make_pair(pos, "-m" + *B));
                ++B;
            }
        }
        if (autogenerated::Switch_mfix_dash_and_dash_continue) {
            vec.push_back(std::make_pair(autogenerated::Switch_mfix_dash_and_dash_continue.getPosition(), "-mfix-and-continue"));
        }
        if (autogenerated::Switch_m32) {
            vec.push_back(std::make_pair(autogenerated::Switch_m32.getPosition(), "-m32"));
        }
        if (autogenerated::Switch_m64) {
            vec.push_back(std::make_pair(autogenerated::Switch_m64.getPosition(), "-m64"));
        }
        if (autogenerated::Switch_O0) {
            vec.push_back(std::make_pair(autogenerated::Switch_O0.getPosition(), "-O0"));
        }
        if (autogenerated::Switch_O1) {
            vec.push_back(std::make_pair(autogenerated::Switch_O1.getPosition(), "-O1"));
        }
        if (autogenerated::Switch_O2) {
            vec.push_back(std::make_pair(autogenerated::Switch_O2.getPosition(), "-O2"));
        }
        if (autogenerated::Switch_O3) {
            vec.push_back(std::make_pair(autogenerated::Switch_O3.getPosition(), "-O3"));
        }
        if (autogenerated::Switch_fPIC) {
            vec.push_back(std::make_pair(autogenerated::Switch_fPIC.getPosition(), "-fPIC"));
        }
        if (autogenerated::Switch_mdynamic_dash_no_dash_pic) {
            vec.push_back(std::make_pair(autogenerated::Switch_mdynamic_dash_no_dash_pic.getPosition(), "-mdynamic-no-pic"));
        }
        if (!autogenerated::Parameter_MF.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_MF.getPosition(), "-MF"));
            vec.push_back(std::make_pair(autogenerated::Parameter_MF.getPosition(), autogenerated::Parameter_MF));
        }
        if (!autogenerated::List_MT.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_MT.begin(),
            E = autogenerated::List_MT.end(); B != E;) {
                unsigned pos = autogenerated::List_MT.getPosition(B - autogenerated::List_MT.begin());
                vec.push_back(std::make_pair(pos, "-MT"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        if (!autogenerated::SinkOption.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::SinkOption.begin(), E = autogenerated::SinkOption.end(); B != E; ++B)
                vec.push_back(std::make_pair(autogenerated::SinkOption.getPosition(B - autogenerated::SinkOption.begin()), *B));
        }
        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* llvm_gcc_m_pch::InputLanguages_[] = {"objective-c-header", 0};

class llvm_gcc_mxx : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_gcc_mxx";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("llvm_gcc_mxx is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("bc");

        cmd = "llvm-gcc";
        vec.push_back(std::make_pair(0, "-x"));
        vec.push_back(std::make_pair(0, "objective-c++"));

        if ((!OutputFilename.empty())
             && (InputFilenames.size() > 1)
             && ((autogenerated::Switch_S)
             || (autogenerated::Switch_c))) {
            PrintError("cannot specify -o with -c or -S with multiple files");
            return 1;
        }
        if (autogenerated::Switch_E) {
            vec.push_back(std::make_pair(autogenerated::Switch_E.getPosition(), "-E"));
            stop_compilation = true;
            output_suffix = "mi";
        }
        if ((autogenerated::Switch_E)
             && (OutputFilename.empty())) {
            no_out_file = true;
        }
        if (autogenerated::Switch_emit_dash_llvm && autogenerated::Switch_S) {
            output_suffix = "ll";
            stop_compilation = true;
        }
        if (autogenerated::Switch_emit_dash_llvm && autogenerated::Switch_c) {
            stop_compilation = true;
        }
        if (autogenerated::Switch_fsyntax_dash_only) {
            vec.push_back(std::make_pair(autogenerated::Switch_fsyntax_dash_only.getPosition(), "-fsyntax-only"));
            no_out_file = true;
            stop_compilation = true;
        }
        if (autogenerated::Switch_S && autogenerated::Switch_emit_dash_llvm) {
            vec.push_back(std::make_pair(autogenerated::Switch_S.getPosition(), "-S"));
            vec.push_back(std::make_pair(autogenerated::Switch_emit_dash_llvm.getPosition(), "-emit-llvm"));
        }
        if (! ((autogenerated::Switch_S && autogenerated::Switch_emit_dash_llvm)
             || (autogenerated::Switch_fsyntax_dash_only))) {
            vec.push_back(std::make_pair(65536, "-c"));
            vec.push_back(std::make_pair(65536, "-emit-llvm"));
        }
        if (!autogenerated::List_Xpreprocessor.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_Xpreprocessor.begin(),
            E = autogenerated::List_Xpreprocessor.end(); B != E;) {
                unsigned pos = autogenerated::List_Xpreprocessor.getPosition(B - autogenerated::List_Xpreprocessor.begin());
                vec.push_back(std::make_pair(pos, "-Xpreprocessor"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_include.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_include.begin(),
            E = autogenerated::List_include.end(); B != E;) {
                unsigned pos = autogenerated::List_include.getPosition(B - autogenerated::List_include.begin());
                vec.push_back(std::make_pair(pos, "-include"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_iquote.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_iquote.begin(),
            E = autogenerated::List_iquote.end(); B != E;) {
                unsigned pos = autogenerated::List_iquote.getPosition(B - autogenerated::List_iquote.begin());
                vec.push_back(std::make_pair(pos, "-iquote"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!(SaveTemps == SaveTempsEnum::Unset)) {
            vec.push_back(std::make_pair(65536, "-save-temps"));
        }
        if (!autogenerated::List_I.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_I.begin(),
            E = autogenerated::List_I.end(); B != E;) {
                unsigned pos = autogenerated::List_I.getPosition(B - autogenerated::List_I.begin());
                vec.push_back(std::make_pair(pos, "-I" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_F.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_F.begin(),
            E = autogenerated::List_F.end(); B != E;) {
                unsigned pos = autogenerated::List_F.getPosition(B - autogenerated::List_F.begin());
                vec.push_back(std::make_pair(pos, "-F" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_D.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_D.begin(),
            E = autogenerated::List_D.end(); B != E;) {
                unsigned pos = autogenerated::List_D.getPosition(B - autogenerated::List_D.begin());
                vec.push_back(std::make_pair(pos, "-D" + *B));
                ++B;
            }
        }
        if (!autogenerated::Parameter_arch.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_arch.getPosition(), "-arch"));
            vec.push_back(std::make_pair(autogenerated::Parameter_arch.getPosition(), autogenerated::Parameter_arch));
        }
        if (!autogenerated::Parameter_march.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_march.getPosition(), "-march=" + autogenerated::Parameter_march));
        }
        if (!autogenerated::Parameter_mtune.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_mtune.getPosition(), "-mtune=" + autogenerated::Parameter_mtune));
        }
        if (!autogenerated::Parameter_mcpu.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_mcpu.getPosition(), "-mcpu=" + autogenerated::Parameter_mcpu));
        }
        if (!autogenerated::List_m.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_m.begin(),
            E = autogenerated::List_m.end(); B != E;) {
                unsigned pos = autogenerated::List_m.getPosition(B - autogenerated::List_m.begin());
                vec.push_back(std::make_pair(pos, "-m" + *B));
                ++B;
            }
        }
        if (autogenerated::Switch_mfix_dash_and_dash_continue) {
            vec.push_back(std::make_pair(autogenerated::Switch_mfix_dash_and_dash_continue.getPosition(), "-mfix-and-continue"));
        }
        if (autogenerated::Switch_m32) {
            vec.push_back(std::make_pair(autogenerated::Switch_m32.getPosition(), "-m32"));
        }
        if (autogenerated::Switch_m64) {
            vec.push_back(std::make_pair(autogenerated::Switch_m64.getPosition(), "-m64"));
        }
        if (autogenerated::Switch_O0) {
            vec.push_back(std::make_pair(autogenerated::Switch_O0.getPosition(), "-O0"));
        }
        if (autogenerated::Switch_O1) {
            vec.push_back(std::make_pair(autogenerated::Switch_O1.getPosition(), "-O1"));
        }
        if (autogenerated::Switch_O2) {
            vec.push_back(std::make_pair(autogenerated::Switch_O2.getPosition(), "-O2"));
        }
        if (autogenerated::Switch_O3) {
            vec.push_back(std::make_pair(autogenerated::Switch_O3.getPosition(), "-O3"));
        }
        if (autogenerated::Switch_fPIC) {
            vec.push_back(std::make_pair(autogenerated::Switch_fPIC.getPosition(), "-fPIC"));
        }
        if (autogenerated::Switch_mdynamic_dash_no_dash_pic) {
            vec.push_back(std::make_pair(autogenerated::Switch_mdynamic_dash_no_dash_pic.getPosition(), "-mdynamic-no-pic"));
        }
        if (!autogenerated::Parameter_MF.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_MF.getPosition(), "-MF"));
            vec.push_back(std::make_pair(autogenerated::Parameter_MF.getPosition(), autogenerated::Parameter_MF));
        }
        if (!autogenerated::List_MT.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_MT.begin(),
            E = autogenerated::List_MT.end(); B != E;) {
                unsigned pos = autogenerated::List_MT.getPosition(B - autogenerated::List_MT.begin());
                vec.push_back(std::make_pair(pos, "-MT"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        if (!autogenerated::SinkOption.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::SinkOption.begin(), E = autogenerated::SinkOption.end(); B != E; ++B)
                vec.push_back(std::make_pair(autogenerated::SinkOption.getPosition(B - autogenerated::SinkOption.begin()), *B));
        }
        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* llvm_gcc_mxx::InputLanguages_[] = {"objective-c++", 0};

class llvm_gcc_mxx_pch : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_gcc_mxx_pch";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("llvm_gcc_mxx_pch is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("gch");

        cmd = "llvm-gcc";
        vec.push_back(std::make_pair(0, "-x"));
        vec.push_back(std::make_pair(0, "objective-c++-header"));

        if ((!OutputFilename.empty())
             && (InputFilenames.size() > 1)
             && ((autogenerated::Switch_S)
             || (autogenerated::Switch_c))) {
            PrintError("cannot specify -o with -c or -S with multiple files");
            return 1;
        }
        if (autogenerated::Switch_E) {
            vec.push_back(std::make_pair(autogenerated::Switch_E.getPosition(), "-E"));
            stop_compilation = true;
            output_suffix = "mi";
        }
        if ((autogenerated::Switch_E)
             && (OutputFilename.empty())) {
            no_out_file = true;
        }
        if (autogenerated::Switch_emit_dash_llvm && autogenerated::Switch_S) {
            output_suffix = "ll";
            stop_compilation = true;
        }
        if (autogenerated::Switch_emit_dash_llvm && autogenerated::Switch_c) {
            stop_compilation = true;
        }
        if (autogenerated::Switch_fsyntax_dash_only) {
            vec.push_back(std::make_pair(autogenerated::Switch_fsyntax_dash_only.getPosition(), "-fsyntax-only"));
            no_out_file = true;
            stop_compilation = true;
        }
        if (autogenerated::Switch_S && autogenerated::Switch_emit_dash_llvm) {
            vec.push_back(std::make_pair(autogenerated::Switch_S.getPosition(), "-S"));
            vec.push_back(std::make_pair(autogenerated::Switch_emit_dash_llvm.getPosition(), "-emit-llvm"));
        }
        if (! ((autogenerated::Switch_S && autogenerated::Switch_emit_dash_llvm)
             || (autogenerated::Switch_fsyntax_dash_only))) {
            vec.push_back(std::make_pair(65536, "-c"));
            vec.push_back(std::make_pair(65536, "-emit-llvm"));
        }
        if (!autogenerated::List_Xpreprocessor.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_Xpreprocessor.begin(),
            E = autogenerated::List_Xpreprocessor.end(); B != E;) {
                unsigned pos = autogenerated::List_Xpreprocessor.getPosition(B - autogenerated::List_Xpreprocessor.begin());
                vec.push_back(std::make_pair(pos, "-Xpreprocessor"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_include.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_include.begin(),
            E = autogenerated::List_include.end(); B != E;) {
                unsigned pos = autogenerated::List_include.getPosition(B - autogenerated::List_include.begin());
                vec.push_back(std::make_pair(pos, "-include"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!autogenerated::List_iquote.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_iquote.begin(),
            E = autogenerated::List_iquote.end(); B != E;) {
                unsigned pos = autogenerated::List_iquote.getPosition(B - autogenerated::List_iquote.begin());
                vec.push_back(std::make_pair(pos, "-iquote"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }
        if (!(SaveTemps == SaveTempsEnum::Unset)) {
            vec.push_back(std::make_pair(65536, "-save-temps"));
        }
        if (!autogenerated::List_I.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_I.begin(),
            E = autogenerated::List_I.end(); B != E;) {
                unsigned pos = autogenerated::List_I.getPosition(B - autogenerated::List_I.begin());
                vec.push_back(std::make_pair(pos, "-I" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_F.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_F.begin(),
            E = autogenerated::List_F.end(); B != E;) {
                unsigned pos = autogenerated::List_F.getPosition(B - autogenerated::List_F.begin());
                vec.push_back(std::make_pair(pos, "-F" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_D.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_D.begin(),
            E = autogenerated::List_D.end(); B != E;) {
                unsigned pos = autogenerated::List_D.getPosition(B - autogenerated::List_D.begin());
                vec.push_back(std::make_pair(pos, "-D" + *B));
                ++B;
            }
        }
        if (!autogenerated::Parameter_arch.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_arch.getPosition(), "-arch"));
            vec.push_back(std::make_pair(autogenerated::Parameter_arch.getPosition(), autogenerated::Parameter_arch));
        }
        if (!autogenerated::Parameter_march.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_march.getPosition(), "-march=" + autogenerated::Parameter_march));
        }
        if (!autogenerated::Parameter_mtune.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_mtune.getPosition(), "-mtune=" + autogenerated::Parameter_mtune));
        }
        if (!autogenerated::Parameter_mcpu.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_mcpu.getPosition(), "-mcpu=" + autogenerated::Parameter_mcpu));
        }
        if (!autogenerated::List_m.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_m.begin(),
            E = autogenerated::List_m.end(); B != E;) {
                unsigned pos = autogenerated::List_m.getPosition(B - autogenerated::List_m.begin());
                vec.push_back(std::make_pair(pos, "-m" + *B));
                ++B;
            }
        }
        if (autogenerated::Switch_mfix_dash_and_dash_continue) {
            vec.push_back(std::make_pair(autogenerated::Switch_mfix_dash_and_dash_continue.getPosition(), "-mfix-and-continue"));
        }
        if (autogenerated::Switch_m32) {
            vec.push_back(std::make_pair(autogenerated::Switch_m32.getPosition(), "-m32"));
        }
        if (autogenerated::Switch_m64) {
            vec.push_back(std::make_pair(autogenerated::Switch_m64.getPosition(), "-m64"));
        }
        if (autogenerated::Switch_O0) {
            vec.push_back(std::make_pair(autogenerated::Switch_O0.getPosition(), "-O0"));
        }
        if (autogenerated::Switch_O1) {
            vec.push_back(std::make_pair(autogenerated::Switch_O1.getPosition(), "-O1"));
        }
        if (autogenerated::Switch_O2) {
            vec.push_back(std::make_pair(autogenerated::Switch_O2.getPosition(), "-O2"));
        }
        if (autogenerated::Switch_O3) {
            vec.push_back(std::make_pair(autogenerated::Switch_O3.getPosition(), "-O3"));
        }
        if (autogenerated::Switch_fPIC) {
            vec.push_back(std::make_pair(autogenerated::Switch_fPIC.getPosition(), "-fPIC"));
        }
        if (autogenerated::Switch_mdynamic_dash_no_dash_pic) {
            vec.push_back(std::make_pair(autogenerated::Switch_mdynamic_dash_no_dash_pic.getPosition(), "-mdynamic-no-pic"));
        }
        if (!autogenerated::Parameter_MF.empty()) {
            vec.push_back(std::make_pair(autogenerated::Parameter_MF.getPosition(), "-MF"));
            vec.push_back(std::make_pair(autogenerated::Parameter_MF.getPosition(), autogenerated::Parameter_MF));
        }
        if (!autogenerated::List_MT.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_MT.begin(),
            E = autogenerated::List_MT.end(); B != E;) {
                unsigned pos = autogenerated::List_MT.getPosition(B - autogenerated::List_MT.begin());
                vec.push_back(std::make_pair(pos, "-MT"));
                vec.push_back(std::make_pair(pos, *B));
                ++B;
            }
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        if (!autogenerated::SinkOption.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::SinkOption.begin(), E = autogenerated::SinkOption.end(); B != E; ++B)
                vec.push_back(std::make_pair(autogenerated::SinkOption.getPosition(B - autogenerated::SinkOption.begin()), *B));
        }
        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* llvm_gcc_mxx_pch::InputLanguages_[] = {"objective-c++-header", 0};

class llvm_ld : public JoinTool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_ld";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "executable";
    }

    bool IsJoin() const {
        return true;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("out");

        cmd = "llvm-ld";
        vec.push_back(std::make_pair(0, "-native"));
        vec.push_back(std::make_pair(0, "-disable-internalize"));

        if (autogenerated::Switch_pthread) {
            vec.push_back(std::make_pair(65536, "-lpthread"));
        }
        if (!autogenerated::List_L.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_L.begin(),
            E = autogenerated::List_L.end(); B != E;) {
                unsigned pos = autogenerated::List_L.getPosition(B - autogenerated::List_L.begin());
                vec.push_back(std::make_pair(pos, "-L" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_l.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_l.begin(),
            E = autogenerated::List_l.end(); B != E;) {
                unsigned pos = autogenerated::List_l.getPosition(B - autogenerated::List_l.begin());
                vec.push_back(std::make_pair(pos, "-l" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_Wl_comma_.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_Wl_comma_.begin(), 
                 E = autogenerated::List_Wl_comma_.end(); B != E; ++B)
            {
                unsigned pos = autogenerated::List_Wl_comma_.getPosition(B - autogenerated::List_Wl_comma_.begin());
                vec.push_back(std::make_pair(pos, *B));
            }
        }

        for (PathVector::const_iterator B = inFiles.begin(),
            E = inFiles.end(); B != E; ++B)
        {
            vec.push_back(std::make_pair(InputFilenames.getPosition(B - inFiles.begin()), B->str()));
        }
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(sys::Path(),
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("out");

        cmd = "llvm-ld";
        vec.push_back(std::make_pair(0, "-native"));
        vec.push_back(std::make_pair(0, "-disable-internalize"));

        if (autogenerated::Switch_pthread) {
            vec.push_back(std::make_pair(65536, "-lpthread"));
        }
        if (!autogenerated::List_L.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_L.begin(),
            E = autogenerated::List_L.end(); B != E;) {
                unsigned pos = autogenerated::List_L.getPosition(B - autogenerated::List_L.begin());
                vec.push_back(std::make_pair(pos, "-L" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_l.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_l.begin(),
            E = autogenerated::List_l.end(); B != E;) {
                unsigned pos = autogenerated::List_l.getPosition(B - autogenerated::List_l.begin());
                vec.push_back(std::make_pair(pos, "-l" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_Wl_comma_.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_Wl_comma_.begin(), 
                 E = autogenerated::List_Wl_comma_.end(); B != E; ++B)
            {
                unsigned pos = autogenerated::List_Wl_comma_.getPosition(B - autogenerated::List_Wl_comma_.begin());
                vec.push_back(std::make_pair(pos, *B));
            }
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* llvm_ld::InputLanguages_[] = {"object-code", 0};

class opt : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "opt";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("opt is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("bc");

        cmd = "opt";
        vec.push_back(std::make_pair(0, "-f"));

        if (!autogenerated::List_Wo_comma_.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_Wo_comma_.begin(), 
                 E = autogenerated::List_Wo_comma_.end(); B != E; ++B)
            {
                unsigned pos = autogenerated::List_Wo_comma_.getPosition(B - autogenerated::List_Wo_comma_.begin());
                vec.push_back(std::make_pair(pos, *B));
            }
        }
        if (autogenerated::Switch_O1) {
            vec.push_back(std::make_pair(autogenerated::Switch_O1.getPosition(), "-O1"));
        }
        if (autogenerated::Switch_O2) {
            vec.push_back(std::make_pair(autogenerated::Switch_O2.getPosition(), "-O2"));
        }
        if (autogenerated::Switch_O3) {
            vec.push_back(std::make_pair(autogenerated::Switch_O3.getPosition(), "-O3"));
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* opt::InputLanguages_[] = {"llvm-bitcode", 0};

class Edge0: public Edge {
public:
    Edge0() : Edge("clang_c") {}

    int Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (autogenerated::Switch_clang) {
            ret += 2;
        }
        return ret;
    }

};

class Edge1: public Edge {
public:
    Edge1() : Edge("clang_cpp") {}

    int Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (autogenerated::Switch_clang) {
            ret += 2;
        }
        return ret;
    }

};

class Edge2: public Edge {
public:
    Edge2() : Edge("clang_objective_c") {}

    int Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (autogenerated::Switch_clang) {
            ret += 2;
        }
        return ret;
    }

};

class Edge3: public Edge {
public:
    Edge3() : Edge("clang_objective_cpp") {}

    int Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (autogenerated::Switch_clang) {
            ret += 2;
        }
        return ret;
    }

};

class Edge8: public Edge {
public:
    Edge8() : Edge("as") {}

    int Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (autogenerated::Switch_clang) {
            ret += 2;
        }
        return ret;
    }

};

class Edge25: public Edge {
public:
    Edge25() : Edge("llvm_as") {}

    int Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (autogenerated::Switch_emit_dash_llvm) {
            ret += 2;
        }
        return ret;
    }

};

class Edge26: public Edge {
public:
    Edge26() : Edge("opt") {}

    int Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (autogenerated::Switch_opt) {
            ret += 2;
        }
        return ret;
    }

};

class Edge27: public Edge {
public:
    Edge27() : Edge("opt") {}

    int Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (autogenerated::Switch_opt) {
            ret += 2;
        }
        return ret;
    }

};

class Edge28: public Edge {
public:
    Edge28() : Edge("opt") {}

    int Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (autogenerated::Switch_opt) {
            ret += 2;
        }
        return ret;
    }

};

class Edge29: public Edge {
public:
    Edge29() : Edge("opt") {}

    int Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (autogenerated::Switch_opt) {
            ret += 2;
        }
        return ret;
    }

};

class Edge30: public Edge {
public:
    Edge30() : Edge("opt") {}

    int Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (autogenerated::Switch_opt) {
            ret += 2;
        }
        return ret;
    }

};

class Edge34: public Edge {
public:
    Edge34() : Edge("llvm_gcc_cpp_linker") {}

    int Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if ((InLangs.count("c++") != 0)
             || (InLangs.count("objective-c++") != 0)) {
            ret += 2;
        }
        if ((autogenerated::Parameter_linker == "g++")
             || (autogenerated::Parameter_linker == "c++")) {
            ret += 2;
        }
        return ret;
    }

};

class Edge36: public Edge {
public:
    Edge36() : Edge("llvm_gcc_cpp_linker") {}

    int Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if ((InLangs.count("c++") != 0)
             || (InLangs.count("objective-c++") != 0)) {
            ret += 2;
        }
        if ((autogenerated::Parameter_linker == "g++")
             || (autogenerated::Parameter_linker == "c++")) {
            ret += 2;
        }
        return ret;
    }

};

} // End anonymous namespace.

namespace llvmc {
namespace autogenerated {

int PreprocessOptions () {
    if (! (autogenerated::Switch_O0 || autogenerated::Switch_O1 || autogenerated::Switch_O2 || autogenerated::Switch_O3)) {
        autogenerated::Switch_O2 = true;
    }
    if ((autogenerated::Switch_O3)
         && (autogenerated::Switch_O0 || autogenerated::Switch_O1 || autogenerated::Switch_O2)) {
        autogenerated::Switch_O0 = false;
        autogenerated::Switch_O1 = false;
        autogenerated::Switch_O2 = false;
    }
    if ((autogenerated::Switch_O2)
         && (autogenerated::Switch_O0 || autogenerated::Switch_O1)) {
        autogenerated::Switch_O0 = false;
        autogenerated::Switch_O1 = false;
    }
    if (autogenerated::Switch_O1 && autogenerated::Switch_O0) {
        autogenerated::Switch_O0 = false;
    }

    return 0;
}

int PopulateLanguageMap (LanguageMap& langMap) {
    langMap["cc"] = "c++";
    langMap["cp"] = "c++";
    langMap["cxx"] = "c++";
    langMap["cpp"] = "c++";
    langMap["CPP"] = "c++";
    langMap["c++"] = "c++";
    langMap["C"] = "c++";
    langMap["hpp"] = "c++-header";
    langMap["c"] = "c";
    langMap["h"] = "c-header";
    langMap["i"] = "c-cpp-output";
    langMap["mi"] = "objective-c-cpp-output";
    langMap["mm"] = "objective-c++";
    langMap["hmm"] = "objective-c++-header";
    langMap["m"] = "objective-c";
    langMap["hm"] = "objective-c-header";
    langMap["s"] = "assembler";
    langMap["S"] = "assembler-with-cpp";
    langMap["ll"] = "llvm-assembler";
    langMap["bc"] = "llvm-bitcode";
    langMap["o"] = "object-code";
    langMap["*empty*"] = "object-code";
    langMap["a"] = "static-library";
    langMap["lib"] = "static-library";
    langMap["so"] = "dynamic-library";
    langMap["dylib"] = "dynamic-library";
    langMap["dll"] = "dynamic-library";
    langMap["out"] = "executable";

    return 0;
}

int PopulateCompilationGraph (CompilationGraph& G) {
    G.insertNode(new as());
    G.insertNode(new clang_c());
    G.insertNode(new clang_cpp());
    G.insertNode(new clang_objective_c());
    G.insertNode(new clang_objective_cpp());
    G.insertNode(new llc());
    G.insertNode(new llvm_as());
    G.insertNode(new llvm_gcc_assembler());
    G.insertNode(new llvm_gcc_c());
    G.insertNode(new llvm_gcc_c_pch());
    G.insertNode(new llvm_gcc_cpp());
    G.insertNode(new llvm_gcc_cpp_linker());
    G.insertNode(new llvm_gcc_cpp_pch());
    G.insertNode(new llvm_gcc_linker());
    G.insertNode(new llvm_gcc_m());
    G.insertNode(new llvm_gcc_m_pch());
    G.insertNode(new llvm_gcc_mxx());
    G.insertNode(new llvm_gcc_mxx_pch());
    G.insertNode(new llvm_ld());
    G.insertNode(new opt());

    if (int ret = G.insertEdge("root", new Edge0()))
        return ret;
    if (int ret = G.insertEdge("root", new Edge1()))
        return ret;
    if (int ret = G.insertEdge("root", new Edge2()))
        return ret;
    if (int ret = G.insertEdge("root", new Edge3()))
        return ret;
    if (int ret = G.insertEdge("clang_c", new SimpleEdge("llc")))
        return ret;
    if (int ret = G.insertEdge("clang_cpp", new SimpleEdge("llc")))
        return ret;
    if (int ret = G.insertEdge("clang_objective_c", new SimpleEdge("llc")))
        return ret;
    if (int ret = G.insertEdge("clang_objective_cpp", new SimpleEdge("llc")))
        return ret;
    if (int ret = G.insertEdge("llc", new Edge8()))
        return ret;
    if (int ret = G.insertEdge("as", new SimpleEdge("llvm_ld")))
        return ret;
    if (int ret = G.insertEdge("root", new SimpleEdge("llvm_gcc_c")))
        return ret;
    if (int ret = G.insertEdge("root", new SimpleEdge("llvm_gcc_assembler")))
        return ret;
    if (int ret = G.insertEdge("root", new SimpleEdge("llvm_gcc_cpp")))
        return ret;
    if (int ret = G.insertEdge("root", new SimpleEdge("llvm_gcc_m")))
        return ret;
    if (int ret = G.insertEdge("root", new SimpleEdge("llvm_gcc_mxx")))
        return ret;
    if (int ret = G.insertEdge("root", new SimpleEdge("llc")))
        return ret;
    if (int ret = G.insertEdge("root", new SimpleEdge("llvm_gcc_c_pch")))
        return ret;
    if (int ret = G.insertEdge("root", new SimpleEdge("llvm_gcc_cpp_pch")))
        return ret;
    if (int ret = G.insertEdge("root", new SimpleEdge("llvm_gcc_m_pch")))
        return ret;
    if (int ret = G.insertEdge("root", new SimpleEdge("llvm_gcc_mxx_pch")))
        return ret;
    if (int ret = G.insertEdge("llvm_gcc_c", new SimpleEdge("llc")))
        return ret;
    if (int ret = G.insertEdge("llvm_gcc_cpp", new SimpleEdge("llc")))
        return ret;
    if (int ret = G.insertEdge("llvm_gcc_m", new SimpleEdge("llc")))
        return ret;
    if (int ret = G.insertEdge("llvm_gcc_mxx", new SimpleEdge("llc")))
        return ret;
    if (int ret = G.insertEdge("llvm_as", new SimpleEdge("llc")))
        return ret;
    if (int ret = G.insertEdge("root", new Edge25()))
        return ret;
    if (int ret = G.insertEdge("llvm_gcc_c", new Edge26()))
        return ret;
    if (int ret = G.insertEdge("llvm_gcc_cpp", new Edge27()))
        return ret;
    if (int ret = G.insertEdge("llvm_gcc_m", new Edge28()))
        return ret;
    if (int ret = G.insertEdge("llvm_gcc_mxx", new Edge29()))
        return ret;
    if (int ret = G.insertEdge("llvm_as", new Edge30()))
        return ret;
    if (int ret = G.insertEdge("opt", new SimpleEdge("llc")))
        return ret;
    if (int ret = G.insertEdge("llc", new SimpleEdge("llvm_gcc_assembler")))
        return ret;
    if (int ret = G.insertEdge("llvm_gcc_assembler", new SimpleEdge("llvm_gcc_linker")))
        return ret;
    if (int ret = G.insertEdge("llvm_gcc_assembler", new Edge34()))
        return ret;
    if (int ret = G.insertEdge("root", new SimpleEdge("llvm_gcc_linker")))
        return ret;
    if (int ret = G.insertEdge("root", new Edge36()))
        return ret;

    return 0;
}

} // End namespace autogenerated.
} // End namespace llvmc.


//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// llvmc-based driver: auto-generated code
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

#include "llvm/CompilerDriver/BuiltinOptions.h"
#include "llvm/CompilerDriver/CompilationGraph.h"
#include "llvm/CompilerDriver/Error.h"
#include "llvm/CompilerDriver/Tool.h"

#include "llvm/Support/CommandLine.h"
#include "llvm/Support/raw_ostream.h"

#include <algorithm>
#include <cstdlib>
#include <iterator>
#include <stdexcept>

using namespace llvm;
using namespace llvmc;

inline const char* checkCString(const char* s)
{ return s == NULL ? "" : s; }

namespace llvmc {
namespace autogenerated {

cl::opt<bool> Switch_dummy1("dummy1"
, cl::desc("none"));


} // End namespace autogenerated.
} // End namespace llvmc.

namespace hooks {
} // End namespace hooks.

namespace {

using namespace llvmc::autogenerated;

class dummy_tool : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "dummy_tool";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "dummy_lang";
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("dummy_tool is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("");

        cmd = "dummy_cmd";

        if (autogenerated::Switch_dummy1) {
            vec.push_back(std::make_pair(autogenerated::Switch_dummy1.getPosition(), "-dummy1"));
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* dummy_tool::InputLanguages_[] = {"dummy_lang", 0};

} // End anonymous namespace.

namespace llvmc {
namespace autogenerated {

int PreprocessOptions () {

    return 0;
}

int PopulateLanguageMap (LanguageMap& langMap) {
    langMap["dummy"] = "dummy_lang";
    langMap["DUM"] = "dummy_lang";
    langMap["DUM2"] = "dummy_lang_2";

    return 0;
}

int PopulateCompilationGraph (CompilationGraph& G) {
    G.insertNode(new dummy_tool());

    if (int ret = G.insertEdge("root", new SimpleEdge("dummy_tool")))
        return ret;

    return 0;
}

} // End namespace autogenerated.
} // End namespace llvmc.

